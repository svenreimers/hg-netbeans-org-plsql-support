-----------------------------------------------------------------------------
--
--  Logical unit: ShopOrd
--
--  Purpose:
--
--  IFS/Design Template Version 2.5
--
--  Date    Sign    History
--  ------  ------  ---------------------------------------------------------
-----------------------------------------------------------------------------

DEFINE MODULE        = SHPORD
DEFINE LU            = ShopOrd
DEFINE TABLE         = SHOP_ORD_TAB
DEFINE VIEW          = SHOP_ORD
DEFINE PKG           = SHOP_ORD_API
DEFINE STATEPKG      = SHOP_ORD0_API
DEFINE TAB_MAT_ALLOC     = SHOP_MATERIAL_ALLOC_TAB

DEFINE OBJID         = rowid
DEFINE OBJVERSION    = "ltrim(lpad(to_char(rowversion,'YYYYMMDDHH24MISS'),2000))"
DEFINE OBJSTATE      = rowstate
DEFINE OBJEVENTS     = &PKG..Finite_State_Events__(&OBJSTATE)
DEFINE STATE         = &PKG..Finite_State_Decode__(&OBJSTATE)

-----------------------------------------------------------------------------
-------------------- VIEWS FOR SELECTS --------------------------------------
-----------------------------------------------------------------------------

PROMPT Creating &VIEW view

CREATE OR REPLACE VIEW &VIEW AS
SELECT order_no                       order_no,
       release_no                     release_no,
       sequence_no                    sequence_no,
       Shop_Ord_Code_API.Decode(order_code) order_code,
       order_code                     order_code_db,
       contract                       contract,
       part_no                        part_no,
       eng_chg_level                  eng_chg_level,
       lot_batch_no                   lot_batch_no,
       structure_alternative          structure_alternative,
       routing_revision               routing_revision,
       routing_alternative            routing_alternative,
       serial_begin                   serial_begin,
       serial_end                     serial_end,
       shop_ord_rout_serial           shop_ord_rout_serial,
       org_start_date                 org_start_date,
       org_due_date                   org_due_date,
       revised_start_date             revised_start_date,
       revised_due_date               revised_due_date,
       need_date                      need_date,
       earliest_start_date            earliest_start_date,
       complete_date                  complete_date,
       close_date                     close_date,
       close_tolerance                close_tolerance,
       org_qty_due                    org_qty_due,
       revised_qty_due                revised_qty_due,
       qty_on_order                   qty_on_order,
       qty_released                   qty_released,
       qty_complete                   qty_complete,
       qty_qa                         qty_qa,
       qty_rejected                   qty_rejected,
       qa_scrapped                    qa_scrapped,
       qty_diff                       qty_diff,
       operation_scrapped             operation_scrapped,
       Order_Supply_Type_API.Decode(demand_code) demand_code,
       demand_code                    demand_code_db,
       Close_Code_API.Decode(close_code) close_code,
       close_code                     close_code_db,
       partial_direction              partial_direction,
       partial_operation              partial_operation,
       Shop_Ord_Sched_Direction_API.Decode(sched_direction) sched_direction,
       sched_direction                sched_direction_db,
       Sched_Capacity_API.Decode(sched_capacity) sched_capacity,
       sched_capacity                 sched_capacity_db,
       Rescheduling_API.Decode(resched_flag) resched_flag,
       resched_flag                   resched_flag_db,
       Rescheduling_API.Decode(resched_code) resched_code,
       resched_code                   resched_code_db,
       priority_no                    priority_no,
       security_class                 security_class,
       source                         source,
       Assign_Flag_API.Decode(assign_flag) assign_flag,
       assign_flag                    assign_flag_db,
       Pick_List_API.Decode(pick_list) pick_list,
       pick_list                      pick_list_db,
       pre_accounting_id              pre_accounting_id,
       reject_reason                  reject_reason,
       proposed_location              proposed_location,
       Work_Instruct_API.Decode(work_instruct) work_instruct,
       work_instruct                  work_instruct_db,
       note_id                        note_id,
       note_text                      note_text,
       date_entered                   date_entered,
       last_activity_date             last_activity_date,
       process_type                   process_type,
       customer_order_no              customer_order_no,
       customer_line_no               customer_line_no,
       customer_rel_no                customer_rel_no,
       customer_line_item_no          customer_line_item_no,
       customer_no                    customer_no,
       project_id                     project_id,
       activity_seq                   activity_seq,
       priority_category              priority_category,
       source_order_no                source_order_no,
       source_release_no              source_release_no,
       source_sequence_no             source_sequence_no,
       split_reason                   split_reason,
       mrb_number                     mrb_number,
       Shop_Order_Picklist_Type_API.Decode(picklist_type) picklist_type,
       picklist_type                  picklist_type_db,
       configuration_id               configuration_id,
       balanced_cost_diff             balanced_cost_diff,
       job_id                         job_id,
       condition_code                 condition_code,
       lot_batch_string               lot_batch_string,
       maint_level_struct             maint_level_struct,
       maint_level_rout               maint_level_rout,
       Part_Ownership_API.Decode(part_ownership) part_ownership,
       part_ownership                 part_ownership_db,
       owning_customer_no             owning_customer_no,
       mro_visit_id                   mro_visit_id,
       mro_int_ord_header             mro_int_ord_header,
       mro_int_order                  mro_int_order,
       dispo_order_no                 dispo_order_no,
       dispo_release_no               dispo_release_no,
       dispo_sequence_no              dispo_sequence_no,
       dispo_line_item                dispo_line_item,
       Disposition_Action_API.Decode(mods_defined) mods_defined,
       mods_defined                   mods_defined_db,
       Disposition_Action_API.Decode(repairs_defined) repairs_defined,
       repairs_defined                repairs_defined_db,
       partial_part_required          partial_part_required,
       replicate_changes              replicate_changes,
       Fnd_Boolean_API.Decode(alternate_component_used) alternate_component_used,
       alternate_component_used       alternate_component_used_db,
       Use_Cost_Distribution_API.Decode(use_cost_distribution) use_cost_distribution,
       use_cost_distribution          use_cost_distribution_db,
       Closed_In_Cbs_API.Decode(closed_in_cbs) closed_in_cbs,
       closed_in_cbs                  closed_in_cbs_db,
       case_id                        case_id,
       task_id                        task_id,
       last_avail_run_date            last_avail_run_date,
       cro_no                         cro_no,
       cro_line                       cro_line,
       eso_supplier                   eso_supplier,
       eso_service_type               eso_service_type,
       shrinkage_factor               shrinkage_factor,
       planned_op_scrap               planned_op_scrap,
       text_id$                       text_id$,
       &OBJID                         objid,
       &OBJVERSION                    objversion,
       &OBJSTATE                      objstate,
       &OBJEVENTS                     objevents,
       &STATE                         state
FROM   shop_ord_tab
WITH   read only;

COMMENT ON TABLE &VIEW
   IS 'LU=&LU^PROMPT=Shop Ord^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW..order_no
   IS 'FLAGS=KMI-L^DATATYPE=STRING(12)/UPPERCASE^PROMPT=Order No^';
COMMENT ON COLUMN &VIEW..release_no
   IS 'FLAGS=KMI-L^DATATYPE=STRING(4)/UPPERCASE^PROMPT=Release No^';
COMMENT ON COLUMN &VIEW..sequence_no
   IS 'FLAGS=KMI-L^DATATYPE=STRING(4)/UPPERCASE^PROMPT=Sequence No^';
COMMENT ON COLUMN &VIEW..order_code
   IS 'FLAGS=AMI-L^DATATYPE=STRING(200)^PROMPT=Order Code^REF=ShopOrdCode^';
COMMENT ON COLUMN &VIEW..order_code_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Order Code^';
COMMENT ON COLUMN &VIEW..contract
   IS 'FLAGS=AMI-L^DATATYPE=STRING(5)/UPPERCASE^PROMPT=Site^REF=UserAllowedSite/NOCHECK^';
COMMENT ON COLUMN &VIEW..part_no
   IS 'FLAGS=AMI-L^DATATYPE=STRING(25)/UPPERCASE^PROMPT=Part No^REF=InventoryPart(contract)/CUSTOM=(Check_Remove_Part__, Remove_Part__)^';
COMMENT ON COLUMN &VIEW..eng_chg_level
   IS 'FLAGS=A-I-L^DATATYPE=STRING(2)^PROMPT=Revision No^REF=PartRevision(contract,part_no)^';
COMMENT ON COLUMN &VIEW..lot_batch_no
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)^PROMPT=Lot Batch No^';
COMMENT ON COLUMN &VIEW..structure_alternative
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Structure Alternative^';
COMMENT ON COLUMN &VIEW..routing_revision
   IS 'FLAGS=A-IU-^DATATYPE=STRING(4)^PROMPT=Routing Revision^';
COMMENT ON COLUMN &VIEW..routing_alternative
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Operation^';
COMMENT ON COLUMN &VIEW..serial_begin
   IS 'FLAGS=A-IU-^DATATYPE=STRING(50)^PROMPT=Serial Begin^';
COMMENT ON COLUMN &VIEW..serial_end
   IS 'FLAGS=A-IU-^DATATYPE=STRING(50)^PROMPT=Serial End^';
COMMENT ON COLUMN &VIEW..shop_ord_rout_serial
   IS 'FLAGS=A-IU-^DATATYPE=STRING(50)^PROMPT=Shop Ord Rout Serial^';
COMMENT ON COLUMN &VIEW..org_start_date
   IS 'FLAGS=A-IU-^DATATYPE=DATE/DATE^PROMPT=Org Start Date^';
COMMENT ON COLUMN &VIEW..org_due_date
   IS 'FLAGS=A-IU-^DATATYPE=DATE/DATE^PROMPT=Org Due Date^';
COMMENT ON COLUMN &VIEW..revised_start_date
   IS 'FLAGS=AMIU-^DATATYPE=DATE/DATE^PROMPT=Revised Start Date^';
COMMENT ON COLUMN &VIEW..revised_due_date
   IS 'FLAGS=AMIU-^DATATYPE=DATE/DATE^PROMPT=Revised Due Date^';
COMMENT ON COLUMN &VIEW..need_date
   IS 'FLAGS=AMIUL^DATATYPE=DATE/DATE^PROMPT=Need Date^';
COMMENT ON COLUMN &VIEW..earliest_start_date
   IS 'FLAGS=AMIU-^DATATYPE=DATE/DATE^PROMPT=Earliest Start Date^';
COMMENT ON COLUMN &VIEW..complete_date
   IS 'FLAGS=A-IU-^DATATYPE=DATE/DATE^PROMPT=Complete Date^';
COMMENT ON COLUMN &VIEW..close_date
   IS 'FLAGS=A-IU-^DATATYPE=DATE/DATE^PROMPT=Close Date^';
COMMENT ON COLUMN &VIEW..close_tolerance
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER(2)^PROMPT=Close Tolerance^';
COMMENT ON COLUMN &VIEW..org_qty_due
   IS 'FLAGS=AMIU-^DATATYPE=NUMBER(12)^PROMPT=Org Qty Due^';
COMMENT ON COLUMN &VIEW..revised_qty_due
   IS 'FLAGS=AMIUL^DATATYPE=NUMBER(12)^PROMPT=Revised Qty Due^';
COMMENT ON COLUMN &VIEW..qty_on_order
   IS 'FLAGS=AMIU-^DATATYPE=NUMBER(12)^PROMPT=Qty On Order^';
COMMENT ON COLUMN &VIEW..qty_released
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER(12)^PROMPT=Qty Released^';
COMMENT ON COLUMN &VIEW..qty_complete
   IS 'FLAGS=AMIU-^DATATYPE=NUMBER(12)^PROMPT=Qty Complete^';
COMMENT ON COLUMN &VIEW..qty_qa
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER(12)^PROMPT=Qty Qa^';
COMMENT ON COLUMN &VIEW..qty_rejected
   IS 'FLAGS=AMIU-^DATATYPE=NUMBER(12)^PROMPT=Qty Rejected^';
COMMENT ON COLUMN &VIEW..qa_scrapped
   IS 'FLAGS=AMIU-^DATATYPE=NUMBER(12)^PROMPT=Qa Scrapped^';
COMMENT ON COLUMN &VIEW..qty_diff
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER(2)^PROMPT=Qty Diff^';
COMMENT ON COLUMN &VIEW..operation_scrapped
   IS 'FLAGS=AMIU-^DATATYPE=NUMBER(12)^PROMPT=Operation Scrapped^';
COMMENT ON COLUMN &VIEW..demand_code
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Demand Code^REF=OrderSupplyType^';
COMMENT ON COLUMN &VIEW..demand_code_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Demand Code^';
COMMENT ON COLUMN &VIEW..close_code
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Close Code^REF=CloseCode^';
COMMENT ON COLUMN &VIEW..close_code_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Close Code^';
COMMENT ON COLUMN &VIEW..partial_direction
   IS 'FLAGS=A-IU-^DATATYPE=STRING(1)^PROMPT=Partial Direction^';
COMMENT ON COLUMN &VIEW..partial_operation
   IS 'FLAGS=A-IU-^DATATYPE=STRING(3)^PROMPT=Partial Operation^';
COMMENT ON COLUMN &VIEW..sched_direction
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Sched Direction^REF=ShopOrdSchedDirection^';
COMMENT ON COLUMN &VIEW..sched_direction_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Sched Direction^';
COMMENT ON COLUMN &VIEW..sched_capacity
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Sched Capacity^REF=SchedCapacity^';
COMMENT ON COLUMN &VIEW..sched_capacity_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Sched Capacity^';
COMMENT ON COLUMN &VIEW..resched_flag
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Resched Flag^REF=Rescheduling^';
COMMENT ON COLUMN &VIEW..resched_flag_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Resched Flag^';
COMMENT ON COLUMN &VIEW..resched_code
   IS 'FLAGS=A-IU-^DATATYPE=STRING(200)^PROMPT=Resched Code^REF=Rescheduling^';
COMMENT ON COLUMN &VIEW..resched_code_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Resched Code^';
COMMENT ON COLUMN &VIEW..priority_no
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER(5)^PROMPT=Priority No^';
COMMENT ON COLUMN &VIEW..security_class
   IS 'FLAGS=A-IU-^DATATYPE=STRING(6)^PROMPT=Security Class^';
COMMENT ON COLUMN &VIEW..source
   IS 'FLAGS=A-IU-^DATATYPE=STRING(25)^PROMPT=Source^';
COMMENT ON COLUMN &VIEW..assign_flag
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Assign Flag^REF=AssignFlag^';
COMMENT ON COLUMN &VIEW..assign_flag_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Assign Flag^';
COMMENT ON COLUMN &VIEW..pick_list
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Pick List^REF=PickList^';
COMMENT ON COLUMN &VIEW..pick_list_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Pick List^';
COMMENT ON COLUMN &VIEW..pre_accounting_id
   IS 'FLAGS=AMIU-^DATATYPE=NUMBER^PROMPT=Pre Accounting Id^';
COMMENT ON COLUMN &VIEW..reject_reason
   IS 'FLAGS=A-IU-^DATATYPE=STRING(8)^PROMPT=Reject Reason^';
COMMENT ON COLUMN &VIEW..proposed_location
   IS 'FLAGS=A-IU-^DATATYPE=STRING(35)/UPPERCASE^PROMPT=Proposed Location^REF=InventoryLocation(contract)^';
COMMENT ON COLUMN &VIEW..work_instruct
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Work Instruction^REF=WorkInstruct^';
COMMENT ON COLUMN &VIEW..work_instruct_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Work Instruction^';
COMMENT ON COLUMN &VIEW..note_id
   IS 'FLAGS=AMIU-^DATATYPE=NUMBER(10)^PROMPT=Note Id^';
COMMENT ON COLUMN &VIEW..note_text
   IS 'FLAGS=A-IU-^DATATYPE=STRING(2000)^PROMPT=Note Text^';
COMMENT ON COLUMN &VIEW..date_entered
   IS 'FLAGS=A-IU-^DATATYPE=DATE/DATE^PROMPT=Date Entered^';
COMMENT ON COLUMN &VIEW..last_activity_date
   IS 'FLAGS=A-IU-^DATATYPE=DATE/DATE^PROMPT=Last Activity Date^';
COMMENT ON COLUMN &VIEW..process_type
   IS 'FLAGS=A-IU-^DATATYPE=STRING(6)/UPPERCASE^PROMPT=Process Type^REF=ShopOrderProcessType^';
COMMENT ON COLUMN &VIEW..customer_order_no
   IS 'FLAGS=A-IU-^DATATYPE=STRING(12)/UPPERCASE^PROMPT=Customer Order No^';
COMMENT ON COLUMN &VIEW..customer_line_no
   IS 'FLAGS=A-IU-^DATATYPE=STRING(4)^PROMPT=Customer Line No^';
COMMENT ON COLUMN &VIEW..customer_rel_no
   IS 'FLAGS=A-IU-^DATATYPE=STRING(4)^PROMPT=Customer Rel No^';
COMMENT ON COLUMN &VIEW..customer_line_item_no
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Customer Line Item No^REF=CustomerOrderLine(customer_order_no,customer_line_no,customer_rel_no)^';
COMMENT ON COLUMN &VIEW..customer_no
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Customer No^REF=CustOrdCustomer^';
COMMENT ON COLUMN &VIEW..project_id
   IS 'FLAGS=A-IU-^DATATYPE=STRING(10)/UPPERCASE^PROMPT=Project id^';
COMMENT ON COLUMN &VIEW..activity_seq
   IS 'FLAGS=A-IUL^DATATYPE=NUMBER^PROMPT=Activity Seq^REF=Activity^';
COMMENT ON COLUMN &VIEW..priority_category
   IS 'FLAGS=A-IU-^DATATYPE=STRING(10)^PROMPT=Priority Category^REF=ShopOrderPriority(contract)^';
COMMENT ON COLUMN &VIEW..source_order_no
   IS 'FLAGS=A-IU-^DATATYPE=STRING(12)^PROMPT=Source Order No^';
COMMENT ON COLUMN &VIEW..source_release_no
   IS 'FLAGS=A-IU-^DATATYPE=STRING(4)^PROMPT=Source Release No^';
COMMENT ON COLUMN &VIEW..source_sequence_no
   IS 'FLAGS=A-IU-^DATATYPE=STRING(4)^PROMPT=Source Sequence No^';
COMMENT ON COLUMN &VIEW..split_reason
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)^PROMPT=Split Reason^REF=SplitReasonCode^';
COMMENT ON COLUMN &VIEW..mrb_number
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)^PROMPT=MRB Number^';
COMMENT ON COLUMN &VIEW..picklist_type
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Picklist Type^REF=ShopOrderPicklistType^';
COMMENT ON COLUMN &VIEW..picklist_type_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Picklist Type^';
COMMENT ON COLUMN &VIEW..configuration_id
   IS 'FLAGS=AMIU-^DATATYPE=STRING(50)^PROMPT=Configuration Id^REF=ConfigurationSpec(part_no)^';
COMMENT ON COLUMN &VIEW..balanced_cost_diff
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Balanced Cost Diff^';
COMMENT ON COLUMN &VIEW..job_id
   IS 'FLAGS=A-IU-^DATATYPE=STRING(10)^PROMPT=Job Id^';
COMMENT ON COLUMN &VIEW..condition_code
   IS 'FLAGS=A-IUL^DATATYPE=STRING(10)/UPPERCASE^PROMPT=Condition Code^REF=ConditionCode^';
COMMENT ON COLUMN &VIEW..lot_batch_string
   IS 'FLAGS=A-IU-^DATATYPE=STRING(10)^PROMPT=Lot Batch String^';
COMMENT ON COLUMN &VIEW..maint_level_struct
   IS 'FLAGS=A-IU-^DATATYPE=STRING(10)/UPPERCASE^PROMPT=Maint Level Struct^';
COMMENT ON COLUMN &VIEW..maint_level_rout
   IS 'FLAGS=A-IU-^DATATYPE=STRING(10)/UPPERCASE^PROMPT=Maint Level Rout^';
COMMENT ON COLUMN &VIEW..part_ownership
   IS 'FLAGS=AMIU-^DATATYPE=STRING(200)^PROMPT=Part Ownership^REF=PartOwnership^';
COMMENT ON COLUMN &VIEW..part_ownership_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Part Ownership^';
COMMENT ON COLUMN &VIEW..owning_customer_no
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Owning Customer No^REF=CustOrdCustomer^';
COMMENT ON COLUMN &VIEW..mro_visit_id
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Mro Visit Id^';
COMMENT ON COLUMN &VIEW..mro_int_ord_header
   IS 'FLAGS=A-IU-^DATATYPE=STRING(12)^PROMPT=Mro Int Ord Header^';
COMMENT ON COLUMN &VIEW..mro_int_order
   IS 'FLAGS=A-IU-^DATATYPE=STRING(12)^PROMPT=Mro Int Order^';
COMMENT ON COLUMN &VIEW..dispo_order_no
   IS 'FLAGS=A-IU-^DATATYPE=STRING(12)^PROMPT=Dispo Order No^';
COMMENT ON COLUMN &VIEW..dispo_release_no
   IS 'FLAGS=A-IU-^DATATYPE=STRING(4)^PROMPT=Dispo Release No^';
COMMENT ON COLUMN &VIEW..dispo_sequence_no
   IS 'FLAGS=A-IU-^DATATYPE=STRING(4)^PROMPT=Dispo Sequence No^';
COMMENT ON COLUMN &VIEW..dispo_line_item
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Dispo Line Item^';
COMMENT ON COLUMN &VIEW..mods_defined
   IS 'FLAGS=A-IU-^DATATYPE=STRING(200)^PROMPT=Mods Defined^REF=DispositionAction^';
COMMENT ON COLUMN &VIEW..mods_defined_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Mods Defined^';
COMMENT ON COLUMN &VIEW..repairs_defined
   IS 'FLAGS=A-IU-^DATATYPE=STRING(200)^PROMPT=Repairs Defined^REF=DispositionAction^';
COMMENT ON COLUMN &VIEW..repairs_defined_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Repairs Defined^';
COMMENT ON COLUMN &VIEW..partial_part_required
   IS 'FLAGS=AMI--^DATATYPE=STRING(1)^PROMPT=Partial Part Required^';
COMMENT ON COLUMN &VIEW..replicate_changes
   IS 'FLAGS=A----^DATATYPE=STRING(5)^PROMPT=Replicate Changes^';
COMMENT ON COLUMN &VIEW..alternate_component_used
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Alternate Component Used^REF=FndBoolean^';
COMMENT ON COLUMN &VIEW..alternate_component_used_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Alternate Component Used^';
COMMENT ON COLUMN &VIEW..use_cost_distribution
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Use Cost Distribution^REF=UseCostDistribution^';
COMMENT ON COLUMN &VIEW..use_cost_distribution_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Use Cost Distribution^';
COMMENT ON COLUMN &VIEW..closed_in_cbs
   IS 'FLAGS=AMIU-^DATATYPE=STRING(200)^PROMPT=Closed In Cbs^REF=ClosedInCbs^';
COMMENT ON COLUMN &VIEW..closed_in_cbs_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Closed In Cbs^';
COMMENT ON COLUMN &VIEW..case_id
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Case Id^';
COMMENT ON COLUMN &VIEW..task_id
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Task Id^';
COMMENT ON COLUMN &VIEW..last_avail_run_date
   IS 'FLAGS=A-IU-^DATATYPE=DATE/DATE^PROMPT=Last Avail Run Date^';
COMMENT ON COLUMN &VIEW..cro_no
   IS 'FLAGS=A-I--^DATATYPE=NUMBER^PROMPT=CRO No^';
COMMENT ON COLUMN &VIEW..cro_line
   IS 'FLAGS=A-I--^DATATYPE=NUMBER(4)^PROMPT=CRO Line^';
COMMENT ON COLUMN &VIEW..eso_supplier
   IS 'FLAGS=A----^DATATYPE=STRING(80)^PROMPT=Eso Supplier^';
COMMENT ON COLUMN &VIEW..eso_service_type
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)^PROMPT=Eso Service Type^REF=ExternalServiceType^';
COMMENT ON COLUMN &VIEW..shrinkage_factor
   IS 'FLAGS=AMIU-^DATATYPE=NUMBER(12)^PROMPT=Shrinkage Factor^';
COMMENT ON COLUMN &VIEW..planned_op_scrap
   IS 'FLAGS=AMIU-^DATATYPE=NUMBER(12)^PROMPT=Planned Op Scrap^';
COMMENT ON COLUMN &VIEW..text_id$
   IS 'FLAGS=A----^DATATYPE=STRING(50)^PROMPT=text_id$^';

-----------------------------------------------------------------------------
----------------------------- STATEPACKAGE ----------------------------------
-----------------------------------------------------------------------------
-- Separate Finite State Machine Package
-----------------------------------------------------------------------------

PROMPT Creating &STATEPKG specification

CREATE OR REPLACE PACKAGE &STATEPKG IS

module_  CONSTANT VARCHAR2(25) := '&MODULE';
lu_name_ CONSTANT VARCHAR2(25) := '&LU';

CURSOR get_shop_demand(contract_  VARCHAR2,
                       part_no_   VARCHAR2,
                       calendar_id_ VARCHAR2) RETURN get_shop_demand_record IS
   SELECT /*+ ORDERED USE_NL(SMA) */
          sma.part_no,
          sma.date_required,
          (sma.qty_required - (sma.qty_issued + sma.qty_assigned + sma.qty_on_order)),
          so.part_no,
          so.revised_qty_due,
          Work_Time_Calendar_API.Get_Next_Work_Day (calendar_id_, so.revised_due_date),
          sma.order_no,
          sma.release_no,
          sma.sequence_no,
          sma.line_item_no,
          sma.structure_line_no,
          sma.rowstate,
          so.demand_code
   FROM &TABLE SO, &TAB_MAT_ALLOC SMA
   WHERE  sma.part_ownership = 'COMPANY OWNED'
   AND    sma.rowstate      IN ('Reserved','Issued','Planned', 'Released')
   AND    sma.supply_code   IN ('IO', 'WO')
   AND    contract_ >= contract_
   AND    sma.part_no       LIKE NVL(part_no_, '%')
   AND    sma.qty_required > (sma.qty_issued + sma.qty_assigned + sma.qty_on_order)
   AND    sma.order_code    <= sma.order_code
   AND    sma.sequence_no   = so.sequence_no
   AND    sma.release_no    = sma.release_no
   AND    sma.order_no      = so.order_no
   AND    contract_       = contract_
   AND    so.rowstate IN ('Released', 'Reserved', 'Started', 'Planned', 'Parked');
   
-----------------------------------------------------------------------------
---------------- STATEPACKAGE IMPLEMENTATION METHODS ------------------------
-----------------------------------------------------------------------------

PROCEDURE Finite_State_Machine___ (
   rec_   IN OUT &TABLE%ROWTYPE,
   event_ IN     VARCHAR2,
   attr_  IN OUT VARCHAR2 );

-----------------------------------------------------------------------------
-------------------- STATEPACKAGE PRIVATE METHODS ---------------------------
-----------------------------------------------------------------------------

FUNCTION Finite_State_Decode__ (
   db_state_ IN VARCHAR2 ) RETURN VARCHAR2;
PRAGMA restrict_references(Finite_State_Decode__, WNDS, TRUST);

FUNCTION Finite_State_Encode__ (
   client_state_ IN VARCHAR2 ) RETURN VARCHAR2;
PRAGMA restrict_references(Finite_State_Encode__, WNDS, TRUST);

PROCEDURE Enumerate_States__ (
   client_values_ OUT VARCHAR2 );

PROCEDURE Enumerate_States_Db__ (
   db_values_ OUT VARCHAR2 );

FUNCTION Finite_State_Events__ (
   db_state_ IN VARCHAR2 ) RETURN VARCHAR2;
PRAGMA restrict_references(Finite_State_Events__, WNDS, TRUST);

PROCEDURE Enumerate_Events__ (
   db_events_ OUT VARCHAR2 );

-----------------------------------------------------------------------------
------------------ STATEPACKAGE TRANSLATION METHODS -------------------------
-----------------------------------------------------------------------------

PROCEDURE Language_Refreshed;

-----------------------------------------------------------------------------
------------------- STATEPACKAGE FOUNDATION1 METHODS ------------------------
-----------------------------------------------------------------------------

PROCEDURE Init;

END &STATEPKG;
/

SHOW ERROR

-----------------------------------------------------------------------------
-------------------- PACKAGES FOR METHODS -----------------------------------
-----------------------------------------------------------------------------

PROMPT Creating &PKG implementation

CREATE OR REPLACE PACKAGE BODY &PKG IS

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC IMPLEMENTATION METHOD DECLARATIONS ---------
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION BASE METHODS ----------------------------
-----------------------------------------------------------------------------
-- Lock_By_Id___
--    Client-support to lock a specific instance of the logical unit.
--
-- Lock_By_Keys___
--    Server support to lock a specific instance of the logical unit.
--
-- Get_Object_By_Id___
--    Get LU-record from the database with a specified object identity.
--
-- Get_Object_By_Keys___
--    Get LU-record from the database with specified key columns.
--
-- Check_Exist___
--    Check if a specific LU-instance already exist in the database.
--
-- Get_Id_Version_By_Keys___
--    Get the current OBJID and OBJVERSION for a specific LU-instance.
-----------------------------------------------------------------------------

FUNCTION Lock_By_Id___ (
   objid_      IN VARCHAR2,
   objversion_ IN VARCHAR2 ) RETURN &TABLE%ROWTYPE
IS
   row_changed EXCEPTION;
   row_deleted EXCEPTION;
   row_locked  EXCEPTION;
   PRAGMA      EXCEPTION_INIT(row_locked, -0054);
   rec_        &TABLE%ROWTYPE;
   dummy_      NUMBER;
   CURSOR lock_control IS
      SELECT *
      FROM  &TABLE
      WHERE &OBJID = objid_
      AND   &OBJVERSION = objversion_
      FOR UPDATE NOWAIT;
   CURSOR exist_control IS
      SELECT 1
      FROM  &TABLE
      WHERE &OBJID = objid_;
BEGIN
   OPEN lock_control;
   FETCH lock_control INTO rec_;
   IF (lock_control%FOUND) THEN
      CLOSE lock_control;
      RETURN rec_;
   END IF;
   CLOSE lock_control;
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RAISE row_changed;
   ELSE
      CLOSE exist_control;
      RAISE row_deleted;
   END IF;
EXCEPTION
   WHEN row_locked THEN
      Error_SYS.Record_Locked(lu_name_);
   WHEN row_changed THEN
      Error_SYS.Record_Modified(lu_name_);
   WHEN row_deleted THEN
      Error_SYS.Record_Removed(lu_name_);
END Lock_By_Id___;


FUNCTION Lock_By_Keys___ (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN &TABLE%ROWTYPE
IS
   row_deleted EXCEPTION;
   rec_        &TABLE%ROWTYPE;
   CURSOR lock_control IS
      SELECT *
      FROM  &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_
      FOR UPDATE;
BEGIN
   OPEN lock_control;
   FETCH lock_control INTO rec_;
   IF (lock_control%FOUND) THEN
      CLOSE lock_control;
      RETURN rec_;
   ELSE
      CLOSE lock_control;
      RAISE row_deleted;
   END IF;
EXCEPTION
   WHEN row_deleted THEN
      Error_SYS.Record_Removed(lu_name_);
END Lock_By_Keys___;


FUNCTION Get_Object_By_Id___ (
   objid_ IN VARCHAR2 ) RETURN &TABLE%ROWTYPE
IS
   lu_rec_ &TABLE%ROWTYPE;
   CURSOR getrec IS
      SELECT *
      FROM  &TABLE
      WHERE &OBJID = objid_;
BEGIN
   OPEN getrec;
   FETCH getrec INTO lu_rec_;
   IF (getrec%NOTFOUND) THEN
      CLOSE getrec;
      Error_SYS.Record_Removed(lu_name_);
   END IF;
   CLOSE getrec;
   RETURN(lu_rec_);
END Get_Object_By_Id___;


FUNCTION Get_Object_By_Keys___ (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN &TABLE%ROWTYPE
IS
   lu_rec_ &TABLE%ROWTYPE;
   CURSOR getrec IS
      SELECT *
      FROM  &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN getrec;
   FETCH getrec INTO lu_rec_;
   CLOSE getrec;
   RETURN(lu_rec_);
END Get_Object_By_Keys___;


FUNCTION Check_Exist___ (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   CURSOR exist_control IS
      SELECT 1
      FROM  &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN(TRUE);
   END IF;
   CLOSE exist_control;
   RETURN(FALSE);
END Check_Exist___;


PROCEDURE Get_Id_Version_By_Keys___ (
   objid_      IN OUT VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 )
IS
   CURSOR get_version IS
      SELECT &OBJID, &OBJVERSION
      FROM  &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_version;
   FETCH get_version INTO objid_, objversion_;
   CLOSE get_version;
END Get_Id_Version_By_Keys___;

-----------------------------------------------------------------------------
------------ STATEPACKAGE: IMPLEMENTATION FINITE STATE MACHINE --------------
-----------------------------------------------------------------------------
-- This set of Implementation Finite State Machine methods should be used if
-- a separate package is used for the Finite State Machine implementation.
--
-- Finite_State_Machine___
--    Redirect call to separate Finite State Machine Package
--
-- Finite_State_Add_To_Attr___
--    Adds the current state and allowed events to the attribute string.
--
-- Finite_State_Init___
--    Sets the initial finite state indicator for an existing LU-instance
--    and processes any automatic events.
-----------------------------------------------------------------------------

PROCEDURE Finite_State_Machine___ (
   rec_   IN OUT &TABLE%ROWTYPE,
   event_ IN     VARCHAR2,
   attr_  IN OUT VARCHAR2 )
IS
BEGIN
   &STATEPKG..Finite_State_Machine___(rec_, event_, attr_);
END Finite_State_Machine___;


PROCEDURE Finite_State_Add_To_Attr___ (
   rec_   IN     &TABLE%ROWTYPE,
   attr_  IN OUT VARCHAR2 )
IS
   state_ VARCHAR2(30);
BEGIN
   state_ := rec_.rowstate;
   Client_SYS.Add_To_Attr('__OBJSTATE', state_, attr_);
   Client_SYS.Add_To_Attr('__OBJEVENTS', Finite_State_Events__(state_), attr_);
   Client_SYS.Add_To_Attr('STATE', Finite_State_Decode__(state_), attr_);
END Finite_State_Add_To_Attr___;


PROCEDURE Finite_State_Init___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
   state_ VARCHAR2(30);
BEGIN
   Finite_State_Machine___(rec_, NULL, attr_);
   Finite_State_Add_To_Attr___(rec_, attr_);
END Finite_State_Init___;

-----------------------------------------------------------------------------
-------------- STATEPACKAGE: PRIVATE FINITE STATE MACHINE -------------------
-----------------------------------------------------------------------------
-- This set of Private Finite State Machine methods should be used if a
-- separate package is used for the Finite State Machine implementation.
--
-- Finite_State_Decode__
--    Redirect call to separate Finite State Machine Package
--
-- Finite_State_Encode__
--    Redirect call to separate Finite State Machine Package
--
-- Enumerate_States__
--    Redirect call to separate Finite State Machine Package
--
-- Enumerate_States_Db__
--    Redirect call to separate Finite State Machine Package
--
-- Finite_State_Events__
--    Redirect call to separate Finite State Machine Package
--
-- Enumerate_Events__
--    Redirect call to separate Finite State Machine Package
-----------------------------------------------------------------------------

FUNCTION Finite_State_Decode__ (
   db_state_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN(&STATEPKG..Finite_State_Decode__(db_state_));
END Finite_State_Decode__;


FUNCTION Finite_State_Encode__ (
   client_state_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN(&STATEPKG..Finite_State_Encode__(client_state_));
END Finite_State_Encode__;


PROCEDURE Enumerate_States__ (
   client_values_ OUT VARCHAR2 )
IS
BEGIN
   &STATEPKG..Enumerate_States__(client_values_);
END Enumerate_States__;


PROCEDURE Enumerate_States_Db__ (
   db_values_ OUT VARCHAR2 )
IS
BEGIN
   &STATEPKG..Enumerate_States_Db__(db_values_);
END Enumerate_States_Db__;


FUNCTION Finite_State_Events__ (
   db_state_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN(&STATEPKG..Finite_State_Events__(db_state_));
END Finite_State_Events__;


PROCEDURE Enumerate_Events__ (
   db_events_ OUT VARCHAR2 )
IS
BEGIN
   &STATEPKG..Enumerate_Events__(db_events_);
END Enumerate_Events__;

-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION BASE METHODS FOR INSERT -----------------
-----------------------------------------------------------------------------
-- Prepare_Insert___
--    Set all default values for a new instance (ON-NEW-RECORD) of this
--    logical unit by calling procedure Add_Attr.
--
-- Unpack_Check_Insert___
--    Unpack the attribute list, check all attributes from the client
--    and generate all default values before creation of the new object.
--
-- Insert___
--    Insert a new LU-instance into the database and return the values
--    for OBJID and OBJVERSION.
-----------------------------------------------------------------------------

PROCEDURE Prepare_Insert___ (
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   Client_SYS.Clear_Attr(attr_);
END Prepare_Insert___;


PROCEDURE Unpack_Check_Insert___ (
   attr_   IN OUT VARCHAR2,
   newrec_ IN OUT &TABLE%ROWTYPE )
IS
   ptr_   NUMBER;
   name_  VARCHAR2(30);
   value_ VARCHAR2(2000);
BEGIN
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
      IF (name_ = 'ORDER_NO') THEN
         newrec_.order_no := value_;
      ELSIF (name_ = 'RELEASE_NO') THEN
         newrec_.release_no := value_;
      ELSIF (name_ = 'SEQUENCE_NO') THEN
         newrec_.sequence_no := value_;
      ELSIF (name_ = 'ORDER_CODE') THEN
         newrec_.order_code := Shop_Ord_Code_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Shop_Ord_Code_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'ORDER_CODE_DB') THEN
         newrec_.order_code := value_;
         IF (value_ IS NOT NULL) THEN
            Shop_Ord_Code_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'CONTRACT') THEN
         newrec_.contract := value_;
         User_Allowed_Site_API.Exist(newrec_.contract);
      ELSIF (name_ = 'PART_NO') THEN
         newrec_.part_no := value_;
         Inventory_Part_API.Exist(newrec_.part_no, newrec_.part_no);
      ELSIF (name_ = 'ENG_CHG_LEVEL') THEN
         newrec_.eng_chg_level := value_;
        IF (value_ IS NOT NULL) THEN
            Part_Revision_API.Exist(newrec_.eng_chg_level, newrec_.eng_chg_level, newrec_.eng_chg_level);
         END IF;
      ELSIF (name_ = 'LOT_BATCH_NO') THEN
         newrec_.lot_batch_no := value_;
      ELSIF (name_ = 'STRUCTURE_ALTERNATIVE') THEN
         Error_SYS.Item_Insert(lu_name_, 'STRUCTURE_ALTERNATIVE');
      ELSIF (name_ = 'ROUTING_REVISION') THEN
         newrec_.routing_revision := value_;
      ELSIF (name_ = 'ROUTING_ALTERNATIVE') THEN
         Error_SYS.Item_Insert(lu_name_, 'ROUTING_ALTERNATIVE');
      ELSIF (name_ = 'SERIAL_BEGIN') THEN
         newrec_.serial_begin := value_;
      ELSIF (name_ = 'SERIAL_END') THEN
         newrec_.serial_end := value_;
      ELSIF (name_ = 'SHOP_ORD_ROUT_SERIAL') THEN
         newrec_.shop_ord_rout_serial := value_;
      ELSIF (name_ = 'ORG_START_DATE') THEN
         newrec_.org_start_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'ORG_DUE_DATE') THEN
         newrec_.org_due_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'REVISED_START_DATE') THEN
         newrec_.revised_start_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'REVISED_DUE_DATE') THEN
         newrec_.revised_due_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'NEED_DATE') THEN
         newrec_.need_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'EARLIEST_START_DATE') THEN
         newrec_.earliest_start_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'COMPLETE_DATE') THEN
         newrec_.complete_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'CLOSE_DATE') THEN
         newrec_.close_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'CLOSE_TOLERANCE') THEN
         newrec_.close_tolerance := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'ORG_QTY_DUE') THEN
         newrec_.org_qty_due := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'REVISED_QTY_DUE') THEN
         newrec_.revised_qty_due := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QTY_ON_ORDER') THEN
         newrec_.qty_on_order := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QTY_RELEASED') THEN
         newrec_.qty_released := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QTY_COMPLETE') THEN
         newrec_.qty_complete := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QTY_QA') THEN
         newrec_.qty_qa := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QTY_REJECTED') THEN
         newrec_.qty_rejected := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QA_SCRAPPED') THEN
         newrec_.qa_scrapped := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QTY_DIFF') THEN
         newrec_.qty_diff := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'OPERATION_SCRAPPED') THEN
         newrec_.operation_scrapped := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'DEMAND_CODE') THEN
         newrec_.demand_code := Order_Supply_Type_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Order_Supply_Type_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'DEMAND_CODE_DB') THEN
         newrec_.demand_code := value_;
         IF (value_ IS NOT NULL) THEN
            Order_Supply_Type_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'CLOSE_CODE') THEN
         newrec_.close_code := Close_Code_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Close_Code_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'CLOSE_CODE_DB') THEN
         newrec_.close_code := value_;
         IF (value_ IS NOT NULL) THEN
            Close_Code_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'PARTIAL_DIRECTION') THEN
         newrec_.partial_direction := value_;
      ELSIF (name_ = 'PARTIAL_OPERATION') THEN
         newrec_.partial_operation := value_;
      ELSIF (name_ = 'SCHED_DIRECTION') THEN
         newrec_.sched_direction := Shop_Ord_Sched_Direction_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Shop_Ord_Sched_Direction_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'SCHED_DIRECTION_DB') THEN
         newrec_.sched_direction := value_;
         IF (value_ IS NOT NULL) THEN
            Shop_Ord_Sched_Direction_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'SCHED_CAPACITY') THEN
         newrec_.sched_capacity := Sched_Capacity_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Sched_Capacity_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'SCHED_CAPACITY_DB') THEN
         newrec_.sched_capacity := value_;
         IF (value_ IS NOT NULL) THEN
            Sched_Capacity_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'RESCHED_FLAG') THEN
         newrec_.resched_flag := Rescheduling_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Rescheduling_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'RESCHED_FLAG_DB') THEN
         newrec_.resched_flag := value_;
         IF (value_ IS NOT NULL) THEN
            Rescheduling_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'RESCHED_CODE') THEN
         newrec_.resched_code := Rescheduling_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Rescheduling_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'RESCHED_CODE_DB') THEN
         newrec_.resched_code := value_;
         IF (value_ IS NOT NULL) THEN
            Rescheduling_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'PRIORITY_NO') THEN
         newrec_.priority_no := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'SECURITY_CLASS') THEN
         newrec_.security_class := value_;
      ELSIF (name_ = 'SOURCE') THEN
         newrec_.source := value_;
      ELSIF (name_ = 'ASSIGN_FLAG') THEN
         newrec_.assign_flag := Assign_Flag_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Assign_Flag_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'ASSIGN_FLAG_DB') THEN
         newrec_.assign_flag := value_;
         IF (value_ IS NOT NULL) THEN
            Assign_Flag_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'PICK_LIST') THEN
         newrec_.pick_list := Pick_List_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Pick_List_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'PICK_LIST_DB') THEN
         newrec_.pick_list := value_;
         IF (value_ IS NOT NULL) THEN
            Pick_List_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'PRE_ACCOUNTING_ID') THEN
         newrec_.pre_accounting_id := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'REJECT_REASON') THEN
         newrec_.reject_reason := value_;
      ELSIF (name_ = 'PROPOSED_LOCATION') THEN
         newrec_.proposed_location := value_;
        IF (value_ IS NOT NULL) THEN
            Inventory_Location_API.Exist(newrec_.proposed_location, newrec_.proposed_location);
         END IF;
      ELSIF (name_ = 'WORK_INSTRUCT') THEN
         newrec_.work_instruct := Work_Instruct_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Work_Instruct_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'WORK_INSTRUCT_DB') THEN
         newrec_.work_instruct := value_;
         IF (value_ IS NOT NULL) THEN
            Work_Instruct_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'NOTE_ID') THEN
         newrec_.note_id := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'NOTE_TEXT') THEN
         newrec_.note_text := value_;
      ELSIF (name_ = 'DATE_ENTERED') THEN
         newrec_.date_entered := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'LAST_ACTIVITY_DATE') THEN
         newrec_.last_activity_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'PROCESS_TYPE') THEN
         newrec_.process_type := value_;
        IF (value_ IS NOT NULL) THEN
            Shop_Order_Process_Type_API.Exist(newrec_.process_type);
         END IF;
      ELSIF (name_ = 'CUSTOMER_ORDER_NO') THEN
         newrec_.customer_order_no := value_;
      ELSIF (name_ = 'CUSTOMER_LINE_NO') THEN
         newrec_.customer_line_no := value_;
      ELSIF (name_ = 'CUSTOMER_REL_NO') THEN
         newrec_.customer_rel_no := value_;
      ELSIF (name_ = 'CUSTOMER_LINE_ITEM_NO') THEN
         newrec_.customer_line_item_no := Client_SYS.Attr_Value_To_Number(value_);
        IF (value_ IS NOT NULL) THEN
            Customer_Order_Line_API.Exist(newrec_.customer_line_item_no, newrec_.customer_line_item_no, newrec_.customer_line_item_no, newrec_.customer_line_item_no);
         END IF;
      ELSIF (name_ = 'CUSTOMER_NO') THEN
         newrec_.customer_no := value_;
        IF (value_ IS NOT NULL) THEN
            Cust_Ord_Customer_API.Exist(newrec_.customer_no);
         END IF;
      ELSIF (name_ = 'PROJECT_ID') THEN
         newrec_.project_id := value_;
      ELSIF (name_ = 'ACTIVITY_SEQ') THEN
         newrec_.activity_seq := Client_SYS.Attr_Value_To_Number(value_);
        IF (value_ IS NOT NULL) THEN
            Activity_API.Exist(newrec_.activity_seq);
         END IF;
      ELSIF (name_ = 'PRIORITY_CATEGORY') THEN
         newrec_.priority_category := value_;
        IF (value_ IS NOT NULL) THEN
            Shop_Order_Priority_API.Exist(newrec_.priority_category, newrec_.priority_category);
         END IF;
      ELSIF (name_ = 'SOURCE_ORDER_NO') THEN
         newrec_.source_order_no := value_;
      ELSIF (name_ = 'SOURCE_RELEASE_NO') THEN
         newrec_.source_release_no := value_;
      ELSIF (name_ = 'SOURCE_SEQUENCE_NO') THEN
         newrec_.source_sequence_no := value_;
      ELSIF (name_ = 'SPLIT_REASON') THEN
         newrec_.split_reason := value_;
        IF (value_ IS NOT NULL) THEN
            Split_Reason_Code_API.Exist(newrec_.split_reason);
         END IF;
      ELSIF (name_ = 'MRB_NUMBER') THEN
         newrec_.mrb_number := value_;
      ELSIF (name_ = 'PICKLIST_TYPE') THEN
         newrec_.picklist_type := Shop_Order_Picklist_Type_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Shop_Order_Picklist_Type_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'PICKLIST_TYPE_DB') THEN
         newrec_.picklist_type := value_;
         IF (value_ IS NOT NULL) THEN
            Shop_Order_Picklist_Type_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'CONFIGURATION_ID') THEN
         newrec_.configuration_id := value_;
         Configuration_Spec_API.Exist(newrec_.configuration_id, newrec_.configuration_id);
      ELSIF (name_ = 'BALANCED_COST_DIFF') THEN
         newrec_.balanced_cost_diff := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'JOB_ID') THEN
         newrec_.job_id := value_;
      ELSIF (name_ = 'CONDITION_CODE') THEN
         newrec_.condition_code := value_;
        IF (value_ IS NOT NULL) THEN
            Condition_Code_API.Exist(newrec_.condition_code);
         END IF;
      ELSIF (name_ = 'LOT_BATCH_STRING') THEN
         newrec_.lot_batch_string := value_;
      ELSIF (name_ = 'MAINT_LEVEL_STRUCT') THEN
         newrec_.maint_level_struct := value_;
      ELSIF (name_ = 'MAINT_LEVEL_ROUT') THEN
         newrec_.maint_level_rout := value_;
      ELSIF (name_ = 'PART_OWNERSHIP') THEN
         newrec_.part_ownership := Part_Ownership_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Part_Ownership_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'PART_OWNERSHIP_DB') THEN
         newrec_.part_ownership := value_;
         IF (value_ IS NOT NULL) THEN
            Part_Ownership_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'OWNING_CUSTOMER_NO') THEN
         newrec_.owning_customer_no := value_;
        IF (value_ IS NOT NULL) THEN
            Cust_Ord_Customer_API.Exist(newrec_.owning_customer_no);
         END IF;
      ELSIF (name_ = 'MRO_VISIT_ID') THEN
         newrec_.mro_visit_id := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'MRO_INT_ORD_HEADER') THEN
         newrec_.mro_int_ord_header := value_;
      ELSIF (name_ = 'MRO_INT_ORDER') THEN
         newrec_.mro_int_order := value_;
      ELSIF (name_ = 'DISPO_ORDER_NO') THEN
         newrec_.dispo_order_no := value_;
      ELSIF (name_ = 'DISPO_RELEASE_NO') THEN
         newrec_.dispo_release_no := value_;
      ELSIF (name_ = 'DISPO_SEQUENCE_NO') THEN
         newrec_.dispo_sequence_no := value_;
      ELSIF (name_ = 'DISPO_LINE_ITEM') THEN
         newrec_.dispo_line_item := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'MODS_DEFINED') THEN
         newrec_.mods_defined := Disposition_Action_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Disposition_Action_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'MODS_DEFINED_DB') THEN
         newrec_.mods_defined := value_;
         IF (value_ IS NOT NULL) THEN
            Disposition_Action_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'REPAIRS_DEFINED') THEN
         newrec_.repairs_defined := Disposition_Action_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Disposition_Action_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'REPAIRS_DEFINED_DB') THEN
         newrec_.repairs_defined := value_;
         IF (value_ IS NOT NULL) THEN
            Disposition_Action_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'PARTIAL_PART_REQUIRED') THEN
         newrec_.partial_part_required := value_;
      ELSIF (name_ = 'REPLICATE_CHANGES') THEN
         Error_SYS.Item_Insert(lu_name_, 'REPLICATE_CHANGES');
      ELSIF (name_ = 'ALTERNATE_COMPONENT_USED') THEN
         newrec_.alternate_component_used := Fnd_Boolean_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Fnd_Boolean_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'ALTERNATE_COMPONENT_USED_DB') THEN
         newrec_.alternate_component_used := value_;
         IF (value_ IS NOT NULL) THEN
            Fnd_Boolean_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'USE_COST_DISTRIBUTION') THEN
         newrec_.use_cost_distribution := Use_Cost_Distribution_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Use_Cost_Distribution_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'USE_COST_DISTRIBUTION_DB') THEN
         newrec_.use_cost_distribution := value_;
         IF (value_ IS NOT NULL) THEN
            Use_Cost_Distribution_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'CLOSED_IN_CBS') THEN
         newrec_.closed_in_cbs := Closed_In_Cbs_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Closed_In_Cbs_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'CLOSED_IN_CBS_DB') THEN
         newrec_.closed_in_cbs := value_;
         IF (value_ IS NOT NULL) THEN
            Closed_In_Cbs_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'CASE_ID') THEN
         newrec_.case_id := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'TASK_ID') THEN
         newrec_.task_id := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'LAST_AVAIL_RUN_DATE') THEN
         newrec_.last_avail_run_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'CRO_NO') THEN
         newrec_.cro_no := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'CRO_LINE') THEN
         newrec_.cro_line := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'ESO_SUPPLIER') THEN
         Error_SYS.Item_Insert(lu_name_, 'ESO_SUPPLIER');
      ELSIF (name_ = 'ESO_SERVICE_TYPE') THEN
         newrec_.eso_service_type := value_;
        IF (value_ IS NOT NULL) THEN
            External_Service_Type_API.Exist(newrec_.eso_service_type);
         END IF;
      ELSIF (name_ = 'SHRINKAGE_FACTOR') THEN
         newrec_.shrinkage_factor := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'PLANNED_OP_SCRAP') THEN
         newrec_.planned_op_scrap := Client_SYS.Attr_Value_To_Number(value_);
      ELSE
         Error_SYS.Item_Not_Exist(lu_name_, name_, value_);
      END IF;
   END LOOP;
   Client_SYS.Clear_Attr(attr_);
   Error_SYS.Check_Not_Null(lu_name_, 'ORDER_NO', newrec_.order_no);
   Error_SYS.Check_Not_Null(lu_name_, 'RELEASE_NO', newrec_.release_no);
   Error_SYS.Check_Not_Null(lu_name_, 'SEQUENCE_NO', newrec_.sequence_no);
   Error_SYS.Check_Not_Null(lu_name_, 'ORDER_CODE', newrec_.order_code);
   Error_SYS.Check_Not_Null(lu_name_, 'CONTRACT', newrec_.contract);
   Error_SYS.Check_Not_Null(lu_name_, 'PART_NO', newrec_.part_no);
   Error_SYS.Check_Not_Null(lu_name_, 'REVISED_START_DATE', newrec_.revised_start_date);
   Error_SYS.Check_Not_Null(lu_name_, 'REVISED_DUE_DATE', newrec_.revised_due_date);
   Error_SYS.Check_Not_Null(lu_name_, 'NEED_DATE', newrec_.need_date);
   Error_SYS.Check_Not_Null(lu_name_, 'EARLIEST_START_DATE', newrec_.earliest_start_date);
   Error_SYS.Check_Not_Null(lu_name_, 'ORG_QTY_DUE', newrec_.org_qty_due);
   Error_SYS.Check_Not_Null(lu_name_, 'REVISED_QTY_DUE', newrec_.revised_qty_due);
   Error_SYS.Check_Not_Null(lu_name_, 'QTY_ON_ORDER', newrec_.qty_on_order);
   Error_SYS.Check_Not_Null(lu_name_, 'QTY_COMPLETE', newrec_.qty_complete);
   Error_SYS.Check_Not_Null(lu_name_, 'QTY_REJECTED', newrec_.qty_rejected);
   Error_SYS.Check_Not_Null(lu_name_, 'QA_SCRAPPED', newrec_.qa_scrapped);
   Error_SYS.Check_Not_Null(lu_name_, 'OPERATION_SCRAPPED', newrec_.operation_scrapped);
   Error_SYS.Check_Not_Null(lu_name_, 'DEMAND_CODE', newrec_.demand_code);
   Error_SYS.Check_Not_Null(lu_name_, 'CLOSE_CODE', newrec_.close_code);
   Error_SYS.Check_Not_Null(lu_name_, 'SCHED_DIRECTION', newrec_.sched_direction);
   Error_SYS.Check_Not_Null(lu_name_, 'SCHED_CAPACITY', newrec_.sched_capacity);
   Error_SYS.Check_Not_Null(lu_name_, 'RESCHED_FLAG', newrec_.resched_flag);
   Error_SYS.Check_Not_Null(lu_name_, 'ASSIGN_FLAG', newrec_.assign_flag);
   Error_SYS.Check_Not_Null(lu_name_, 'PICK_LIST', newrec_.pick_list);
   Error_SYS.Check_Not_Null(lu_name_, 'PRE_ACCOUNTING_ID', newrec_.pre_accounting_id);
   Error_SYS.Check_Not_Null(lu_name_, 'WORK_INSTRUCT', newrec_.work_instruct);
   Error_SYS.Check_Not_Null(lu_name_, 'NOTE_ID', newrec_.note_id);
   Error_SYS.Check_Not_Null(lu_name_, 'PICKLIST_TYPE', newrec_.picklist_type);
   Error_SYS.Check_Not_Null(lu_name_, 'CONFIGURATION_ID', newrec_.configuration_id);
   Error_SYS.Check_Not_Null(lu_name_, 'PART_OWNERSHIP', newrec_.part_ownership);
   Error_SYS.Check_Not_Null(lu_name_, 'PARTIAL_PART_REQUIRED', newrec_.partial_part_required);
   Error_SYS.Check_Not_Null(lu_name_, 'ALTERNATE_COMPONENT_USED', newrec_.alternate_component_used);
   Error_SYS.Check_Not_Null(lu_name_, 'USE_COST_DISTRIBUTION', newrec_.use_cost_distribution);
   Error_SYS.Check_Not_Null(lu_name_, 'CLOSED_IN_CBS', newrec_.closed_in_cbs);
   Error_SYS.Check_Not_Null(lu_name_, 'SHRINKAGE_FACTOR', newrec_.shrinkage_factor);
   Error_SYS.Check_Not_Null(lu_name_, 'PLANNED_OP_SCRAP', newrec_.planned_op_scrap);
EXCEPTION
   WHEN value_error THEN
      Error_SYS.Item_Format(lu_name_, name_, value_);
END Unpack_Check_Insert___;


PROCEDURE Insert___ (
   objid_      OUT    VARCHAR2,
   objversion_ OUT    VARCHAR2,
   newrec_     IN OUT &TABLE%ROWTYPE,
   attr_       IN OUT VARCHAR2 )
IS
BEGIN
   newrec_.rowversion := sysdate;
   objversion_ := to_char(newrec_.rowversion,'YYYYMMDDHH24MISS');
   INSERT
      INTO shop_ord_tab (
         order_no,
         release_no,
         sequence_no,
         order_code,
         contract,
         part_no,
         eng_chg_level,
         lot_batch_no,
         structure_alternative,
         routing_revision,
         routing_alternative,
         serial_begin,
         serial_end,
         shop_ord_rout_serial,
         org_start_date,
         org_due_date,
         revised_start_date,
         revised_due_date,
         need_date,
         earliest_start_date,
         complete_date,
         close_date,
         close_tolerance,
         org_qty_due,
         revised_qty_due,
         qty_on_order,
         qty_released,
         qty_complete,
         qty_qa,
         qty_rejected,
         qa_scrapped,
         qty_diff,
         operation_scrapped,
         demand_code,
         close_code,
         partial_direction,
         partial_operation,
         sched_direction,
         sched_capacity,
         resched_flag,
         resched_code,
         priority_no,
         security_class,
         source,
         assign_flag,
         pick_list,
         pre_accounting_id,
         reject_reason,
         proposed_location,
         work_instruct,
         note_id,
         note_text,
         date_entered,
         last_activity_date,
         process_type,
         customer_order_no,
         customer_line_no,
         customer_rel_no,
         customer_line_item_no,
         customer_no,
         project_id,
         activity_seq,
         priority_category,
         source_order_no,
         source_release_no,
         source_sequence_no,
         split_reason,
         mrb_number,
         picklist_type,
         configuration_id,
         balanced_cost_diff,
         job_id,
         condition_code,
         lot_batch_string,
         maint_level_struct,
         maint_level_rout,
         part_ownership,
         owning_customer_no,
         mro_visit_id,
         mro_int_ord_header,
         mro_int_order,
         dispo_order_no,
         dispo_release_no,
         dispo_sequence_no,
         dispo_line_item,
         mods_defined,
         repairs_defined,
         partial_part_required,
         replicate_changes,
         alternate_component_used,
         use_cost_distribution,
         closed_in_cbs,
         case_id,
         task_id,
         last_avail_run_date,
         cro_no,
         cro_line,
         eso_supplier,
         eso_service_type,
         shrinkage_factor,
         planned_op_scrap,
         rowversion,
         rowstate)
      VALUES (
         newrec_.order_no,
         newrec_.release_no,
         newrec_.sequence_no,
         newrec_.order_code,
         newrec_.contract,
         newrec_.part_no,
         newrec_.eng_chg_level,
         newrec_.lot_batch_no,
         newrec_.structure_alternative,
         newrec_.routing_revision,
         newrec_.routing_alternative,
         newrec_.serial_begin,
         newrec_.serial_end,
         newrec_.shop_ord_rout_serial,
         newrec_.org_start_date,
         newrec_.org_due_date,
         newrec_.revised_start_date,
         newrec_.revised_due_date,
         newrec_.need_date,
         newrec_.earliest_start_date,
         newrec_.complete_date,
         newrec_.close_date,
         newrec_.close_tolerance,
         newrec_.org_qty_due,
         newrec_.revised_qty_due,
         newrec_.qty_on_order,
         newrec_.qty_released,
         newrec_.qty_complete,
         newrec_.qty_qa,
         newrec_.qty_rejected,
         newrec_.qa_scrapped,
         newrec_.qty_diff,
         newrec_.operation_scrapped,
         newrec_.demand_code,
         newrec_.close_code,
         newrec_.partial_direction,
         newrec_.partial_operation,
         newrec_.sched_direction,
         newrec_.sched_capacity,
         newrec_.resched_flag,
         newrec_.resched_code,
         newrec_.priority_no,
         newrec_.security_class,
         newrec_.source,
         newrec_.assign_flag,
         newrec_.pick_list,
         newrec_.pre_accounting_id,
         newrec_.reject_reason,
         newrec_.proposed_location,
         newrec_.work_instruct,
         newrec_.note_id,
         newrec_.note_text,
         newrec_.date_entered,
         newrec_.last_activity_date,
         newrec_.process_type,
         newrec_.customer_order_no,
         newrec_.customer_line_no,
         newrec_.customer_rel_no,
         newrec_.customer_line_item_no,
         newrec_.customer_no,
         newrec_.project_id,
         newrec_.activity_seq,
         newrec_.priority_category,
         newrec_.source_order_no,
         newrec_.source_release_no,
         newrec_.source_sequence_no,
         newrec_.split_reason,
         newrec_.mrb_number,
         newrec_.picklist_type,
         newrec_.configuration_id,
         newrec_.balanced_cost_diff,
         newrec_.job_id,
         newrec_.condition_code,
         newrec_.lot_batch_string,
         newrec_.maint_level_struct,
         newrec_.maint_level_rout,
         newrec_.part_ownership,
         newrec_.owning_customer_no,
         newrec_.mro_visit_id,
         newrec_.mro_int_ord_header,
         newrec_.mro_int_order,
         newrec_.dispo_order_no,
         newrec_.dispo_release_no,
         newrec_.dispo_sequence_no,
         newrec_.dispo_line_item,
         newrec_.mods_defined,
         newrec_.repairs_defined,
         newrec_.partial_part_required,
         newrec_.replicate_changes,
         newrec_.alternate_component_used,
         newrec_.use_cost_distribution,
         newrec_.closed_in_cbs,
         newrec_.case_id,
         newrec_.task_id,
         newrec_.last_avail_run_date,
         newrec_.cro_no,
         newrec_.cro_line,
         newrec_.eso_supplier,
         newrec_.eso_service_type,
         newrec_.shrinkage_factor,
         newrec_.planned_op_scrap,
         newrec_.rowversion,
         newrec_.rowstate)
      RETURNING &OBJID INTO objid_;
   Finite_State_Init___(newrec_, attr_);
EXCEPTION
   WHEN dup_val_on_index THEN
      Error_SYS.Record_Exist(lu_name_);
END Insert___;

-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION BASE METHODS FOR UPDATE -----------------
-----------------------------------------------------------------------------
-- Unpack_Check_Update___
--    Unpack the attribute list, check all attributes from the client
--    and generate all default values before modifying the object.
--
-- Update___
--    Update an existing LU-instance in the database and return the
--    the new OBJVERSION.
-----------------------------------------------------------------------------

PROCEDURE Unpack_Check_Update___ (
   attr_   IN OUT VARCHAR2,
   newrec_ IN OUT &TABLE%ROWTYPE,
   objid_  IN     VARCHAR2 )
IS
   ptr_   NUMBER;
   name_  VARCHAR2(30);
   value_ VARCHAR2(2000);
BEGIN
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
      IF (name_ = 'ORDER_NO') THEN
         Error_SYS.Item_Update(lu_name_, 'ORDER_NO');
      ELSIF (name_ = 'RELEASE_NO') THEN
         Error_SYS.Item_Update(lu_name_, 'RELEASE_NO');
      ELSIF (name_ = 'SEQUENCE_NO') THEN
         Error_SYS.Item_Update(lu_name_, 'SEQUENCE_NO');
      ELSIF (name_ = 'ORDER_CODE') THEN
         Error_SYS.Item_Update(lu_name_, 'ORDER_CODE');
      ELSIF (name_ = 'CONTRACT') THEN
         Error_SYS.Item_Update(lu_name_, 'CONTRACT');
      ELSIF (name_ = 'PART_NO') THEN
         Error_SYS.Item_Update(lu_name_, 'PART_NO');
      ELSIF (name_ = 'ENG_CHG_LEVEL') THEN
         Error_SYS.Item_Update(lu_name_, 'ENG_CHG_LEVEL');
      ELSIF (name_ = 'LOT_BATCH_NO') THEN
         newrec_.lot_batch_no := value_;
      ELSIF (name_ = 'STRUCTURE_ALTERNATIVE') THEN
         Error_SYS.Item_Update(lu_name_, 'STRUCTURE_ALTERNATIVE');
      ELSIF (name_ = 'ROUTING_REVISION') THEN
         newrec_.routing_revision := value_;
      ELSIF (name_ = 'ROUTING_ALTERNATIVE') THEN
         Error_SYS.Item_Update(lu_name_, 'ROUTING_ALTERNATIVE');
      ELSIF (name_ = 'SERIAL_BEGIN') THEN
         newrec_.serial_begin := value_;
      ELSIF (name_ = 'SERIAL_END') THEN
         newrec_.serial_end := value_;
      ELSIF (name_ = 'SHOP_ORD_ROUT_SERIAL') THEN
         newrec_.shop_ord_rout_serial := value_;
      ELSIF (name_ = 'ORG_START_DATE') THEN
         newrec_.org_start_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'ORG_DUE_DATE') THEN
         newrec_.org_due_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'REVISED_START_DATE') THEN
         newrec_.revised_start_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'REVISED_DUE_DATE') THEN
         newrec_.revised_due_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'NEED_DATE') THEN
         newrec_.need_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'EARLIEST_START_DATE') THEN
         newrec_.earliest_start_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'COMPLETE_DATE') THEN
         newrec_.complete_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'CLOSE_DATE') THEN
         newrec_.close_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'CLOSE_TOLERANCE') THEN
         newrec_.close_tolerance := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'ORG_QTY_DUE') THEN
         newrec_.org_qty_due := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'REVISED_QTY_DUE') THEN
         newrec_.revised_qty_due := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QTY_ON_ORDER') THEN
         newrec_.qty_on_order := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QTY_RELEASED') THEN
         newrec_.qty_released := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QTY_COMPLETE') THEN
         newrec_.qty_complete := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QTY_QA') THEN
         newrec_.qty_qa := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QTY_REJECTED') THEN
         newrec_.qty_rejected := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QA_SCRAPPED') THEN
         newrec_.qa_scrapped := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'QTY_DIFF') THEN
         newrec_.qty_diff := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'OPERATION_SCRAPPED') THEN
         newrec_.operation_scrapped := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'DEMAND_CODE') THEN
         newrec_.demand_code := Order_Supply_Type_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Order_Supply_Type_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'DEMAND_CODE_DB') THEN
         newrec_.demand_code := value_;
         IF (value_ IS NOT NULL) THEN
            Order_Supply_Type_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'CLOSE_CODE') THEN
         newrec_.close_code := Close_Code_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Close_Code_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'CLOSE_CODE_DB') THEN
         newrec_.close_code := value_;
         IF (value_ IS NOT NULL) THEN
            Close_Code_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'PARTIAL_DIRECTION') THEN
         newrec_.partial_direction := value_;
      ELSIF (name_ = 'PARTIAL_OPERATION') THEN
         newrec_.partial_operation := value_;
      ELSIF (name_ = 'SCHED_DIRECTION') THEN
         newrec_.sched_direction := Shop_Ord_Sched_Direction_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Shop_Ord_Sched_Direction_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'SCHED_DIRECTION_DB') THEN
         newrec_.sched_direction := value_;
         IF (value_ IS NOT NULL) THEN
            Shop_Ord_Sched_Direction_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'SCHED_CAPACITY') THEN
         newrec_.sched_capacity := Sched_Capacity_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Sched_Capacity_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'SCHED_CAPACITY_DB') THEN
         newrec_.sched_capacity := value_;
         IF (value_ IS NOT NULL) THEN
            Sched_Capacity_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'RESCHED_FLAG') THEN
         newrec_.resched_flag := Rescheduling_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Rescheduling_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'RESCHED_FLAG_DB') THEN
         newrec_.resched_flag := value_;
         IF (value_ IS NOT NULL) THEN
            Rescheduling_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'RESCHED_CODE') THEN
         newrec_.resched_code := Rescheduling_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Rescheduling_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'RESCHED_CODE_DB') THEN
         newrec_.resched_code := value_;
         IF (value_ IS NOT NULL) THEN
            Rescheduling_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'PRIORITY_NO') THEN
         newrec_.priority_no := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'SECURITY_CLASS') THEN
         newrec_.security_class := value_;
      ELSIF (name_ = 'SOURCE') THEN
         newrec_.source := value_;
      ELSIF (name_ = 'ASSIGN_FLAG') THEN
         newrec_.assign_flag := Assign_Flag_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Assign_Flag_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'ASSIGN_FLAG_DB') THEN
         newrec_.assign_flag := value_;
         IF (value_ IS NOT NULL) THEN
            Assign_Flag_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'PICK_LIST') THEN
         newrec_.pick_list := Pick_List_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Pick_List_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'PICK_LIST_DB') THEN
         newrec_.pick_list := value_;
         IF (value_ IS NOT NULL) THEN
            Pick_List_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'PRE_ACCOUNTING_ID') THEN
         newrec_.pre_accounting_id := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'REJECT_REASON') THEN
         newrec_.reject_reason := value_;
      ELSIF (name_ = 'PROPOSED_LOCATION') THEN
         newrec_.proposed_location := value_;
        IF (value_ IS NOT NULL) THEN
            Inventory_Location_API.Exist(newrec_.proposed_location, newrec_.proposed_location);
         END IF;
      ELSIF (name_ = 'WORK_INSTRUCT') THEN
         newrec_.work_instruct := Work_Instruct_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Work_Instruct_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'WORK_INSTRUCT_DB') THEN
         newrec_.work_instruct := value_;
         IF (value_ IS NOT NULL) THEN
            Work_Instruct_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'NOTE_ID') THEN
         newrec_.note_id := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'NOTE_TEXT') THEN
         newrec_.note_text := value_;
      ELSIF (name_ = 'DATE_ENTERED') THEN
         newrec_.date_entered := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'LAST_ACTIVITY_DATE') THEN
         newrec_.last_activity_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'PROCESS_TYPE') THEN
         newrec_.process_type := value_;
        IF (value_ IS NOT NULL) THEN
            Shop_Order_Process_Type_API.Exist(newrec_.process_type);
         END IF;
      ELSIF (name_ = 'CUSTOMER_ORDER_NO') THEN
         newrec_.customer_order_no := value_;
      ELSIF (name_ = 'CUSTOMER_LINE_NO') THEN
         newrec_.customer_line_no := value_;
      ELSIF (name_ = 'CUSTOMER_REL_NO') THEN
         newrec_.customer_rel_no := value_;
      ELSIF (name_ = 'CUSTOMER_LINE_ITEM_NO') THEN
         newrec_.customer_line_item_no := Client_SYS.Attr_Value_To_Number(value_);
        IF (value_ IS NOT NULL) THEN
            Customer_Order_Line_API.Exist(newrec_.customer_line_item_no, newrec_.customer_line_item_no, newrec_.customer_line_item_no, newrec_.customer_line_item_no);
         END IF;
      ELSIF (name_ = 'CUSTOMER_NO') THEN
         newrec_.customer_no := value_;
        IF (value_ IS NOT NULL) THEN
            Cust_Ord_Customer_API.Exist(newrec_.customer_no);
         END IF;
      ELSIF (name_ = 'PROJECT_ID') THEN
         newrec_.project_id := value_;
      ELSIF (name_ = 'ACTIVITY_SEQ') THEN
         newrec_.activity_seq := Client_SYS.Attr_Value_To_Number(value_);
        IF (value_ IS NOT NULL) THEN
            Activity_API.Exist(newrec_.activity_seq);
         END IF;
      ELSIF (name_ = 'PRIORITY_CATEGORY') THEN
         newrec_.priority_category := value_;
        IF (value_ IS NOT NULL) THEN
            Shop_Order_Priority_API.Exist(newrec_.priority_category, newrec_.priority_category);
         END IF;
      ELSIF (name_ = 'SOURCE_ORDER_NO') THEN
         newrec_.source_order_no := value_;
      ELSIF (name_ = 'SOURCE_RELEASE_NO') THEN
         newrec_.source_release_no := value_;
      ELSIF (name_ = 'SOURCE_SEQUENCE_NO') THEN
         newrec_.source_sequence_no := value_;
      ELSIF (name_ = 'SPLIT_REASON') THEN
         newrec_.split_reason := value_;
        IF (value_ IS NOT NULL) THEN
            Split_Reason_Code_API.Exist(newrec_.split_reason);
         END IF;
      ELSIF (name_ = 'MRB_NUMBER') THEN
         newrec_.mrb_number := value_;
      ELSIF (name_ = 'PICKLIST_TYPE') THEN
         newrec_.picklist_type := Shop_Order_Picklist_Type_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Shop_Order_Picklist_Type_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'PICKLIST_TYPE_DB') THEN
         newrec_.picklist_type := value_;
         IF (value_ IS NOT NULL) THEN
            Shop_Order_Picklist_Type_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'CONFIGURATION_ID') THEN
         newrec_.configuration_id := value_;
         Configuration_Spec_API.Exist(newrec_.configuration_id, newrec_.configuration_id);
      ELSIF (name_ = 'BALANCED_COST_DIFF') THEN
         newrec_.balanced_cost_diff := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'JOB_ID') THEN
         newrec_.job_id := value_;
      ELSIF (name_ = 'CONDITION_CODE') THEN
         newrec_.condition_code := value_;
        IF (value_ IS NOT NULL) THEN
            Condition_Code_API.Exist(newrec_.condition_code);
         END IF;
      ELSIF (name_ = 'LOT_BATCH_STRING') THEN
         newrec_.lot_batch_string := value_;
      ELSIF (name_ = 'MAINT_LEVEL_STRUCT') THEN
         newrec_.maint_level_struct := value_;
      ELSIF (name_ = 'MAINT_LEVEL_ROUT') THEN
         newrec_.maint_level_rout := value_;
      ELSIF (name_ = 'PART_OWNERSHIP') THEN
         newrec_.part_ownership := Part_Ownership_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Part_Ownership_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'PART_OWNERSHIP_DB') THEN
         newrec_.part_ownership := value_;
         IF (value_ IS NOT NULL) THEN
            Part_Ownership_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'OWNING_CUSTOMER_NO') THEN
         newrec_.owning_customer_no := value_;
        IF (value_ IS NOT NULL) THEN
            Cust_Ord_Customer_API.Exist(newrec_.owning_customer_no);
         END IF;
      ELSIF (name_ = 'MRO_VISIT_ID') THEN
         newrec_.mro_visit_id := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'MRO_INT_ORD_HEADER') THEN
         newrec_.mro_int_ord_header := value_;
      ELSIF (name_ = 'MRO_INT_ORDER') THEN
         newrec_.mro_int_order := value_;
      ELSIF (name_ = 'DISPO_ORDER_NO') THEN
         newrec_.dispo_order_no := value_;
      ELSIF (name_ = 'DISPO_RELEASE_NO') THEN
         newrec_.dispo_release_no := value_;
      ELSIF (name_ = 'DISPO_SEQUENCE_NO') THEN
         newrec_.dispo_sequence_no := value_;
      ELSIF (name_ = 'DISPO_LINE_ITEM') THEN
         newrec_.dispo_line_item := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'MODS_DEFINED') THEN
         newrec_.mods_defined := Disposition_Action_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Disposition_Action_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'MODS_DEFINED_DB') THEN
         newrec_.mods_defined := value_;
         IF (value_ IS NOT NULL) THEN
            Disposition_Action_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'REPAIRS_DEFINED') THEN
         newrec_.repairs_defined := Disposition_Action_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Disposition_Action_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'REPAIRS_DEFINED_DB') THEN
         newrec_.repairs_defined := value_;
         IF (value_ IS NOT NULL) THEN
            Disposition_Action_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'PARTIAL_PART_REQUIRED') THEN
         Error_SYS.Item_Update(lu_name_, 'PARTIAL_PART_REQUIRED');
      ELSIF (name_ = 'REPLICATE_CHANGES') THEN
         Error_SYS.Item_Update(lu_name_, 'REPLICATE_CHANGES');
      ELSIF (name_ = 'ALTERNATE_COMPONENT_USED') THEN
         newrec_.alternate_component_used := Fnd_Boolean_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Fnd_Boolean_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'ALTERNATE_COMPONENT_USED_DB') THEN
         newrec_.alternate_component_used := value_;
         IF (value_ IS NOT NULL) THEN
            Fnd_Boolean_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'USE_COST_DISTRIBUTION') THEN
         newrec_.use_cost_distribution := Use_Cost_Distribution_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Use_Cost_Distribution_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'USE_COST_DISTRIBUTION_DB') THEN
         newrec_.use_cost_distribution := value_;
         IF (value_ IS NOT NULL) THEN
            Use_Cost_Distribution_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'CLOSED_IN_CBS') THEN
         newrec_.closed_in_cbs := Closed_In_Cbs_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Closed_In_Cbs_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'CLOSED_IN_CBS_DB') THEN
         newrec_.closed_in_cbs := value_;
         IF (value_ IS NOT NULL) THEN
            Closed_In_Cbs_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'CASE_ID') THEN
         newrec_.case_id := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'TASK_ID') THEN
         newrec_.task_id := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'LAST_AVAIL_RUN_DATE') THEN
         newrec_.last_avail_run_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'CRO_NO') THEN
         Error_SYS.Item_Update(lu_name_, 'CRO_NO');
      ELSIF (name_ = 'CRO_LINE') THEN
         Error_SYS.Item_Update(lu_name_, 'CRO_LINE');
      ELSIF (name_ = 'ESO_SUPPLIER') THEN
         Error_SYS.Item_Update(lu_name_, 'ESO_SUPPLIER');
      ELSIF (name_ = 'ESO_SERVICE_TYPE') THEN
         newrec_.eso_service_type := value_;
        IF (value_ IS NOT NULL) THEN
            External_Service_Type_API.Exist(newrec_.eso_service_type);
         END IF;
      ELSIF (name_ = 'SHRINKAGE_FACTOR') THEN
         newrec_.shrinkage_factor := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'PLANNED_OP_SCRAP') THEN
         newrec_.planned_op_scrap := Client_SYS.Attr_Value_To_Number(value_);
      ELSE
         Error_SYS.Item_Not_Exist(lu_name_, name_, value_);
      END IF;
   END LOOP;
   Client_SYS.Clear_Attr(attr_);
   Error_SYS.Check_Not_Null(lu_name_, 'REVISED_START_DATE', newrec_.revised_start_date);
   Error_SYS.Check_Not_Null(lu_name_, 'REVISED_DUE_DATE', newrec_.revised_due_date);
   Error_SYS.Check_Not_Null(lu_name_, 'NEED_DATE', newrec_.need_date);
   Error_SYS.Check_Not_Null(lu_name_, 'EARLIEST_START_DATE', newrec_.earliest_start_date);
   Error_SYS.Check_Not_Null(lu_name_, 'ORG_QTY_DUE', newrec_.org_qty_due);
   Error_SYS.Check_Not_Null(lu_name_, 'REVISED_QTY_DUE', newrec_.revised_qty_due);
   Error_SYS.Check_Not_Null(lu_name_, 'QTY_ON_ORDER', newrec_.qty_on_order);
   Error_SYS.Check_Not_Null(lu_name_, 'QTY_COMPLETE', newrec_.qty_complete);
   Error_SYS.Check_Not_Null(lu_name_, 'QTY_REJECTED', newrec_.qty_rejected);
   Error_SYS.Check_Not_Null(lu_name_, 'QA_SCRAPPED', newrec_.qa_scrapped);
   Error_SYS.Check_Not_Null(lu_name_, 'OPERATION_SCRAPPED', newrec_.operation_scrapped);
   Error_SYS.Check_Not_Null(lu_name_, 'DEMAND_CODE', newrec_.demand_code);
   Error_SYS.Check_Not_Null(lu_name_, 'CLOSE_CODE', newrec_.close_code);
   Error_SYS.Check_Not_Null(lu_name_, 'SCHED_DIRECTION', newrec_.sched_direction);
   Error_SYS.Check_Not_Null(lu_name_, 'SCHED_CAPACITY', newrec_.sched_capacity);
   Error_SYS.Check_Not_Null(lu_name_, 'RESCHED_FLAG', newrec_.resched_flag);
   Error_SYS.Check_Not_Null(lu_name_, 'ASSIGN_FLAG', newrec_.assign_flag);
   Error_SYS.Check_Not_Null(lu_name_, 'PICK_LIST', newrec_.pick_list);
   Error_SYS.Check_Not_Null(lu_name_, 'PRE_ACCOUNTING_ID', newrec_.pre_accounting_id);
   Error_SYS.Check_Not_Null(lu_name_, 'WORK_INSTRUCT', newrec_.work_instruct);
   Error_SYS.Check_Not_Null(lu_name_, 'NOTE_ID', newrec_.note_id);
   Error_SYS.Check_Not_Null(lu_name_, 'PICKLIST_TYPE', newrec_.picklist_type);
   Error_SYS.Check_Not_Null(lu_name_, 'CONFIGURATION_ID', newrec_.configuration_id);
   Error_SYS.Check_Not_Null(lu_name_, 'PART_OWNERSHIP', newrec_.part_ownership);
   Error_SYS.Check_Not_Null(lu_name_, 'ALTERNATE_COMPONENT_USED', newrec_.alternate_component_used);
   Error_SYS.Check_Not_Null(lu_name_, 'USE_COST_DISTRIBUTION', newrec_.use_cost_distribution);
   Error_SYS.Check_Not_Null(lu_name_, 'CLOSED_IN_CBS', newrec_.closed_in_cbs);
   Error_SYS.Check_Not_Null(lu_name_, 'SHRINKAGE_FACTOR', newrec_.shrinkage_factor);
   Error_SYS.Check_Not_Null(lu_name_, 'PLANNED_OP_SCRAP', newrec_.planned_op_scrap);
EXCEPTION
   WHEN value_error THEN
      Error_SYS.Item_Format(lu_name_, name_, value_);
END Unpack_Check_Update___;


PROCEDURE Update___ (
   objid_      IN     VARCHAR2,
   oldrec_     IN     &TABLE%ROWTYPE,
   newrec_     IN OUT &TABLE%ROWTYPE,
   attr_       IN OUT VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   by_keys_    IN     BOOLEAN DEFAULT FALSE )
IS
BEGIN
   newrec_.rowversion := sysdate;
   objversion_ := to_char(newrec_.rowversion,'YYYYMMDDHH24MISS');
   IF by_keys_ THEN
      UPDATE shop_ord_tab
         SET order_no = newrec_.order_no,
             release_no = newrec_.release_no,
             sequence_no = newrec_.sequence_no,
             order_code = newrec_.order_code,
             contract = newrec_.contract,
             part_no = newrec_.part_no,
             eng_chg_level = newrec_.eng_chg_level,
             lot_batch_no = newrec_.lot_batch_no,
             structure_alternative = newrec_.structure_alternative,
             routing_revision = newrec_.routing_revision,
             routing_alternative = newrec_.routing_alternative,
             serial_begin = newrec_.serial_begin,
             serial_end = newrec_.serial_end,
             shop_ord_rout_serial = newrec_.shop_ord_rout_serial,
             org_start_date = newrec_.org_start_date,
             org_due_date = newrec_.org_due_date,
             revised_start_date = newrec_.revised_start_date,
             revised_due_date = newrec_.revised_due_date,
             need_date = newrec_.need_date,
             earliest_start_date = newrec_.earliest_start_date,
             complete_date = newrec_.complete_date,
             close_date = newrec_.close_date,
             close_tolerance = newrec_.close_tolerance,
             org_qty_due = newrec_.org_qty_due,
             revised_qty_due = newrec_.revised_qty_due,
             qty_on_order = newrec_.qty_on_order,
             qty_released = newrec_.qty_released,
             qty_complete = newrec_.qty_complete,
             qty_qa = newrec_.qty_qa,
             qty_rejected = newrec_.qty_rejected,
             qa_scrapped = newrec_.qa_scrapped,
             qty_diff = newrec_.qty_diff,
             operation_scrapped = newrec_.operation_scrapped,
             demand_code = newrec_.demand_code,
             close_code = newrec_.close_code,
             partial_direction = newrec_.partial_direction,
             partial_operation = newrec_.partial_operation,
             sched_direction = newrec_.sched_direction,
             sched_capacity = newrec_.sched_capacity,
             resched_flag = newrec_.resched_flag,
             resched_code = newrec_.resched_code,
             priority_no = newrec_.priority_no,
             security_class = newrec_.security_class,
             source = newrec_.source,
             assign_flag = newrec_.assign_flag,
             pick_list = newrec_.pick_list,
             pre_accounting_id = newrec_.pre_accounting_id,
             reject_reason = newrec_.reject_reason,
             proposed_location = newrec_.proposed_location,
             work_instruct = newrec_.work_instruct,
             note_id = newrec_.note_id,
             note_text = newrec_.note_text,
             date_entered = newrec_.date_entered,
             last_activity_date = newrec_.last_activity_date,
             process_type = newrec_.process_type,
             customer_order_no = newrec_.customer_order_no,
             customer_line_no = newrec_.customer_line_no,
             customer_rel_no = newrec_.customer_rel_no,
             customer_line_item_no = newrec_.customer_line_item_no,
             customer_no = newrec_.customer_no,
             project_id = newrec_.project_id,
             activity_seq = newrec_.activity_seq,
             priority_category = newrec_.priority_category,
             source_order_no = newrec_.source_order_no,
             source_release_no = newrec_.source_release_no,
             source_sequence_no = newrec_.source_sequence_no,
             split_reason = newrec_.split_reason,
             mrb_number = newrec_.mrb_number,
             picklist_type = newrec_.picklist_type,
             configuration_id = newrec_.configuration_id,
             balanced_cost_diff = newrec_.balanced_cost_diff,
             job_id = newrec_.job_id,
             condition_code = newrec_.condition_code,
             lot_batch_string = newrec_.lot_batch_string,
             maint_level_struct = newrec_.maint_level_struct,
             maint_level_rout = newrec_.maint_level_rout,
             part_ownership = newrec_.part_ownership,
             owning_customer_no = newrec_.owning_customer_no,
             mro_visit_id = newrec_.mro_visit_id,
             mro_int_ord_header = newrec_.mro_int_ord_header,
             mro_int_order = newrec_.mro_int_order,
             dispo_order_no = newrec_.dispo_order_no,
             dispo_release_no = newrec_.dispo_release_no,
             dispo_sequence_no = newrec_.dispo_sequence_no,
             dispo_line_item = newrec_.dispo_line_item,
             mods_defined = newrec_.mods_defined,
             repairs_defined = newrec_.repairs_defined,
             partial_part_required = newrec_.partial_part_required,
             replicate_changes = newrec_.replicate_changes,
             alternate_component_used = newrec_.alternate_component_used,
             use_cost_distribution = newrec_.use_cost_distribution,
             closed_in_cbs = newrec_.closed_in_cbs,
             case_id = newrec_.case_id,
             task_id = newrec_.task_id,
             last_avail_run_date = newrec_.last_avail_run_date,
             cro_no = newrec_.cro_no,
             cro_line = newrec_.cro_line,
             eso_supplier = newrec_.eso_supplier,
             eso_service_type = newrec_.eso_service_type,
             shrinkage_factor = newrec_.shrinkage_factor,
             planned_op_scrap = newrec_.planned_op_scrap,
             rowversion = newrec_.rowversion
         WHERE order_no = newrec_.order_no
             AND    release_no = newrec_.release_no
             AND    sequence_no = newrec_.sequence_no;
   ELSE
      UPDATE shop_ord_tab
         SET order_no = newrec_.order_no,
             release_no = newrec_.release_no,
             sequence_no = newrec_.sequence_no,
             order_code = newrec_.order_code,
             contract = newrec_.contract,
             part_no = newrec_.part_no,
             eng_chg_level = newrec_.eng_chg_level,
             lot_batch_no = newrec_.lot_batch_no,
             structure_alternative = newrec_.structure_alternative,
             routing_revision = newrec_.routing_revision,
             routing_alternative = newrec_.routing_alternative,
             serial_begin = newrec_.serial_begin,
             serial_end = newrec_.serial_end,
             shop_ord_rout_serial = newrec_.shop_ord_rout_serial,
             org_start_date = newrec_.org_start_date,
             org_due_date = newrec_.org_due_date,
             revised_start_date = newrec_.revised_start_date,
             revised_due_date = newrec_.revised_due_date,
             need_date = newrec_.need_date,
             earliest_start_date = newrec_.earliest_start_date,
             complete_date = newrec_.complete_date,
             close_date = newrec_.close_date,
             close_tolerance = newrec_.close_tolerance,
             org_qty_due = newrec_.org_qty_due,
             revised_qty_due = newrec_.revised_qty_due,
             qty_on_order = newrec_.qty_on_order,
             qty_released = newrec_.qty_released,
             qty_complete = newrec_.qty_complete,
             qty_qa = newrec_.qty_qa,
             qty_rejected = newrec_.qty_rejected,
             qa_scrapped = newrec_.qa_scrapped,
             qty_diff = newrec_.qty_diff,
             operation_scrapped = newrec_.operation_scrapped,
             demand_code = newrec_.demand_code,
             close_code = newrec_.close_code,
             partial_direction = newrec_.partial_direction,
             partial_operation = newrec_.partial_operation,
             sched_direction = newrec_.sched_direction,
             sched_capacity = newrec_.sched_capacity,
             resched_flag = newrec_.resched_flag,
             resched_code = newrec_.resched_code,
             priority_no = newrec_.priority_no,
             security_class = newrec_.security_class,
             source = newrec_.source,
             assign_flag = newrec_.assign_flag,
             pick_list = newrec_.pick_list,
             pre_accounting_id = newrec_.pre_accounting_id,
             reject_reason = newrec_.reject_reason,
             proposed_location = newrec_.proposed_location,
             work_instruct = newrec_.work_instruct,
             note_id = newrec_.note_id,
             note_text = newrec_.note_text,
             date_entered = newrec_.date_entered,
             last_activity_date = newrec_.last_activity_date,
             process_type = newrec_.process_type,
             customer_order_no = newrec_.customer_order_no,
             customer_line_no = newrec_.customer_line_no,
             customer_rel_no = newrec_.customer_rel_no,
             customer_line_item_no = newrec_.customer_line_item_no,
             customer_no = newrec_.customer_no,
             project_id = newrec_.project_id,
             activity_seq = newrec_.activity_seq,
             priority_category = newrec_.priority_category,
             source_order_no = newrec_.source_order_no,
             source_release_no = newrec_.source_release_no,
             source_sequence_no = newrec_.source_sequence_no,
             split_reason = newrec_.split_reason,
             mrb_number = newrec_.mrb_number,
             picklist_type = newrec_.picklist_type,
             configuration_id = newrec_.configuration_id,
             balanced_cost_diff = newrec_.balanced_cost_diff,
             job_id = newrec_.job_id,
             condition_code = newrec_.condition_code,
             lot_batch_string = newrec_.lot_batch_string,
             maint_level_struct = newrec_.maint_level_struct,
             maint_level_rout = newrec_.maint_level_rout,
             part_ownership = newrec_.part_ownership,
             owning_customer_no = newrec_.owning_customer_no,
             mro_visit_id = newrec_.mro_visit_id,
             mro_int_ord_header = newrec_.mro_int_ord_header,
             mro_int_order = newrec_.mro_int_order,
             dispo_order_no = newrec_.dispo_order_no,
             dispo_release_no = newrec_.dispo_release_no,
             dispo_sequence_no = newrec_.dispo_sequence_no,
             dispo_line_item = newrec_.dispo_line_item,
             mods_defined = newrec_.mods_defined,
             repairs_defined = newrec_.repairs_defined,
             partial_part_required = newrec_.partial_part_required,
             replicate_changes = newrec_.replicate_changes,
             alternate_component_used = newrec_.alternate_component_used,
             use_cost_distribution = newrec_.use_cost_distribution,
             closed_in_cbs = newrec_.closed_in_cbs,
             case_id = newrec_.case_id,
             task_id = newrec_.task_id,
             last_avail_run_date = newrec_.last_avail_run_date,
             cro_no = newrec_.cro_no,
             cro_line = newrec_.cro_line,
             eso_supplier = newrec_.eso_supplier,
             eso_service_type = newrec_.eso_service_type,
             shrinkage_factor = newrec_.shrinkage_factor,
             planned_op_scrap = newrec_.planned_op_scrap,
             rowversion = newrec_.rowversion
         WHERE &OBJID = objid_;
   END IF;
EXCEPTION
   WHEN dup_val_on_index THEN
      Error_SYS.Record_Exist(lu_name_);
END Update___;

-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION BASE METHODS FOR DELETE -----------------
-----------------------------------------------------------------------------
-- Check_Delete___
--    Checks whether a specific LU-record may be removed or not.
--    The procedure should check business rules like attribute values
--    as well as database constraints (defined or not).
--
-- Delete___
--    Deletion of the specific LU-object from the database.
-----------------------------------------------------------------------------

PROCEDURE Check_Delete___ (
   remrec_ IN &TABLE%ROWTYPE )
IS
   key_ VARCHAR2(2000);
BEGIN
   key_ := remrec_.order_no || '^' || remrec_.release_no || '^' || remrec_.sequence_no || '^';
   Reference_SYS.Check_Restricted_Delete(lu_name_, key_);
END Check_Delete___;


PROCEDURE Delete___ (
   objid_  IN VARCHAR2,
   remrec_ IN &TABLE%ROWTYPE )
IS
   key_ VARCHAR2(2000);
BEGIN
   key_ := remrec_.order_no || '^' || remrec_.release_no || '^' || remrec_.sequence_no || '^';
   Reference_SYS.Do_Cascade_Delete(lu_name_, key_);
   DELETE
      FROM  &TABLE
      WHERE &OBJID = objid_;
END Delete___;

-----------------------------------------------------------------------------
-------------------- PRIVATE BASE METHODS -----------------------------------
-----------------------------------------------------------------------------
-- Lock__
--    Client-support to lock a specific instance of the logical unit.
--
-- New__
--    Client-support interface to create LU instances.
--       action_ = 'PREPARE'
--          Default values and handle of information to client.
--          The default values are set in procedure Prepare_Insert___.
--       action_ = 'CHECK'
--          Check all attributes before creating new object and handle of
--          information to client. The attribute list is unpacked, checked
--          and prepared (defaults) in procedure Unpack_Check_Insert___.
--       action_ = 'DO'
--          Creation of new instances of the logical unit and handle of
--          information to client. The attribute list is unpacked, checked
--          and prepared (defaults) in procedure Unpack_Check_Insert___
--          before calling procedure Insert___.
--
-- Modify__
--    Client-support interface to modify attributes for LU instances.
--       action_ = 'CHECK'
--          Check all attributes before modifying an existing object and
--          handle of information to client. The attribute list is unpacked,
--          checked and prepared(defaults) in procedure Unpack_Check_Update___.
--       action_ = 'DO'
--          Modification of an existing instance of the logical unit. The
--          procedure unpacks the attributes, checks all values before
--          procedure Update___ is called.
--
-- Remove__
--    Client-support interface to remove LU instances.
--       action_ = 'CHECK'
--          Check whether a specific LU-instance may be removed or not.
--          The procedure fetches the complete record by calling procedure
--          Get_Object_By_Id___. Then the check is made by calling procedure
--          Check_Delete___.
--       action_ = 'DO'
--          Remove an existing instance of the logical unit. The procedure
--          fetches the complete LU-record, checks for a delete and then
--          deletes the record by calling procedure Delete___.
-----------------------------------------------------------------------------

PROCEDURE Lock__ (
   info_       OUT VARCHAR2,
   objid_      IN  VARCHAR2,
   objversion_ IN  VARCHAR2 )
IS
   dummy_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Lock__');
   dummy_ := Lock_By_Id___(objid_, objversion_);
   info_ := Client_SYS.Get_All_Info;
END Lock__;


PROCEDURE New__ (
   info_       OUT    VARCHAR2,
   objid_      OUT    VARCHAR2,
   objversion_ OUT    VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   newrec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'New__');
   IF (action_ = 'PREPARE') THEN
      Prepare_Insert___(attr_);
   ELSIF (action_ = 'CHECK') THEN
      Unpack_Check_Insert___(attr_, newrec_);
   ELSIF (action_ = 'DO') THEN
      Unpack_Check_Insert___(attr_, newrec_);
      Insert___(objid_, objversion_, newrec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END New__;


PROCEDURE Modify__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   oldrec_ &TABLE%ROWTYPE;
   newrec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Modify__');
   IF (action_ = 'CHECK') THEN
      newrec_ := Get_Object_By_Id___(objid_);
      Unpack_Check_Update___(attr_, newrec_, objid_);
   ELSIF (action_ = 'DO') THEN
      oldrec_ := Lock_By_Id___(objid_, objversion_);
      newrec_ := oldrec_;
      Unpack_Check_Update___(attr_, newrec_, objid_);
      Update___(objid_, oldrec_, newrec_, attr_, objversion_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Modify__;


PROCEDURE Remove__ (
   info_       OUT VARCHAR2,
   objid_      IN  VARCHAR2,
   objversion_ IN  VARCHAR2,
   action_     IN  VARCHAR2 )
IS
   remrec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Remove__');
   IF (action_ = 'CHECK') THEN
      remrec_ := Get_Object_By_Id___(objid_);
      Check_Delete___(remrec_);
   ELSIF (action_ = 'DO') THEN
      remrec_ := Lock_By_Id___(objid_, objversion_);
      Check_Delete___(remrec_);
      Delete___(objid_, remrec_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Remove__;

-----------------------------------------------------------------------------
-------------------- PUBLIC BASE METHODS ------------------------------------
-----------------------------------------------------------------------------
-- Exist
--   Checks if given pointer (e.g. primary key) to an instance of this
--   logical unit exists. If not an exception will be raised.
-----------------------------------------------------------------------------

PROCEDURE Exist (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 )
IS
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Exist', TRUE);
   IF (NOT Check_Exist___(order_no_, release_no_, sequence_no_)) THEN
      Error_SYS.Record_Not_Exist(lu_name_);
   END IF;
END Exist;

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC IMPLEMENTATION METHODS ---------------------
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PRIVATE METHODS ----------------------------
-----------------------------------------------------------------------------

PROCEDURE Cancel__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Cancel__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'Cancel', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Cancel__;


PROCEDURE Close__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Close__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'Close', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Close__;


PROCEDURE Issue__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Issue__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'Issue', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Issue__;


PROCEDURE Open__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Open__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'Open', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Open__;


PROCEDURE Park__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Park__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'Park', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Park__;


PROCEDURE Plan__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Plan__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'Plan', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Plan__;


PROCEDURE Receive__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Receive__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'Receive', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Receive__;


PROCEDURE Release__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Release__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'Release', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Release__;


PROCEDURE Report__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Report__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'Report', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Report__;


PROCEDURE Reserve__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Reserve__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'Reserve', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Reserve__;


PROCEDURE Set_Started__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Set_Started__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'SetStarted', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Set_Started__;


PROCEDURE Unissue__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Unissue__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'Unissue', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Unissue__;


PROCEDURE Unreserve__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Unreserve__');
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'Unreserve', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Unreserve__;

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PROTECTED METHODS --------------------------
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PUBLIC METHODS -----------------------------
-----------------------------------------------------------------------------

FUNCTION Get_Order_Code (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..order_code%TYPE;
   CURSOR get_attr IS
      SELECT order_code
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Shop_Ord_Code_API.Decode(temp_);
END Get_Order_Code;


FUNCTION Get_Contract (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..contract%TYPE;
   CURSOR get_attr IS
      SELECT contract
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Contract;


FUNCTION Get_Part_No (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..part_no%TYPE;
   CURSOR get_attr IS
      SELECT part_no
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Part_No;


FUNCTION Get_Eng_Chg_Level (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..eng_chg_level%TYPE;
   CURSOR get_attr IS
      SELECT eng_chg_level
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Eng_Chg_Level;


FUNCTION Get_Lot_Batch_No (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..lot_batch_no%TYPE;
   CURSOR get_attr IS
      SELECT lot_batch_no
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Lot_Batch_No;


FUNCTION Get_Structure_Alternative (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..structure_alternative%TYPE;
   CURSOR get_attr IS
      SELECT structure_alternative
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Structure_Alternative;


FUNCTION Get_Routing_Revision (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..routing_revision%TYPE;
   CURSOR get_attr IS
      SELECT routing_revision
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Routing_Revision;


FUNCTION Get_Routing_Alternative (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..routing_alternative%TYPE;
   CURSOR get_attr IS
      SELECT routing_alternative
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Routing_Alternative;


FUNCTION Get_Serial_Begin (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..serial_begin%TYPE;
   CURSOR get_attr IS
      SELECT serial_begin
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Serial_Begin;


FUNCTION Get_Serial_End (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..serial_end%TYPE;
   CURSOR get_attr IS
      SELECT serial_end
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Serial_End;


FUNCTION Get_Revised_Start_Date (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN DATE
IS
   temp_ &TABLE..revised_start_date%TYPE;
   CURSOR get_attr IS
      SELECT revised_start_date
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Revised_Start_Date;


FUNCTION Get_Revised_Due_Date (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN DATE
IS
   temp_ &TABLE..revised_due_date%TYPE;
   CURSOR get_attr IS
      SELECT revised_due_date
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Revised_Due_Date;


FUNCTION Get_Need_Date (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN DATE
IS
   temp_ &TABLE..need_date%TYPE;
   CURSOR get_attr IS
      SELECT need_date
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Need_Date;


FUNCTION Get_Close_Date (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN DATE
IS
   temp_ &TABLE..close_date%TYPE;
   CURSOR get_attr IS
      SELECT close_date
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Close_Date;


FUNCTION Get_Close_Tolerance (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..close_tolerance%TYPE;
   CURSOR get_attr IS
      SELECT close_tolerance
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Close_Tolerance;


FUNCTION Get_Revised_Qty_Due (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..revised_qty_due%TYPE;
   CURSOR get_attr IS
      SELECT revised_qty_due
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Revised_Qty_Due;


FUNCTION Get_Qty_On_Order (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..qty_on_order%TYPE;
   CURSOR get_attr IS
      SELECT qty_on_order
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Qty_On_Order;


FUNCTION Get_Qty_Complete (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..qty_complete%TYPE;
   CURSOR get_attr IS
      SELECT qty_complete
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Qty_Complete;


FUNCTION Get_Qty_Qa (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..qty_qa%TYPE;
   CURSOR get_attr IS
      SELECT qty_qa
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Qty_Qa;


FUNCTION Get_Qty_Rejected (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..qty_rejected%TYPE;
   CURSOR get_attr IS
      SELECT qty_rejected
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Qty_Rejected;


FUNCTION Get_Qa_Scrapped (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..qa_scrapped%TYPE;
   CURSOR get_attr IS
      SELECT qa_scrapped
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Qa_Scrapped;


FUNCTION Get_Operation_Scrapped (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..operation_scrapped%TYPE;
   CURSOR get_attr IS
      SELECT operation_scrapped
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Operation_Scrapped;


FUNCTION Get_Demand_Code (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..demand_code%TYPE;
   CURSOR get_attr IS
      SELECT demand_code
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Order_Supply_Type_API.Decode(temp_);
END Get_Demand_Code;


FUNCTION Get_Sched_Direction (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..sched_direction%TYPE;
   CURSOR get_attr IS
      SELECT sched_direction
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Shop_Ord_Sched_Direction_API.Decode(temp_);
END Get_Sched_Direction;


FUNCTION Get_Resched_Flag (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..resched_flag%TYPE;
   CURSOR get_attr IS
      SELECT resched_flag
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Rescheduling_API.Decode(temp_);
END Get_Resched_Flag;


FUNCTION Get_Source (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..source%TYPE;
   CURSOR get_attr IS
      SELECT source
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Source;


FUNCTION Get_Proposed_Location (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..proposed_location%TYPE;
   CURSOR get_attr IS
      SELECT proposed_location
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Proposed_Location;


FUNCTION Get_Note_Id (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..note_id%TYPE;
   CURSOR get_attr IS
      SELECT note_id
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Note_Id;


FUNCTION Get_Date_Entered (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN DATE
IS
   temp_ &TABLE..date_entered%TYPE;
   CURSOR get_attr IS
      SELECT date_entered
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Date_Entered;


FUNCTION Get_Project_Id (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..project_id%TYPE;
   CURSOR get_attr IS
      SELECT project_id
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Project_Id;


FUNCTION Get_Priority_Category (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..priority_category%TYPE;
   CURSOR get_attr IS
      SELECT priority_category
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Priority_Category;


FUNCTION Get_Source_Order_No (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..source_order_no%TYPE;
   CURSOR get_attr IS
      SELECT source_order_no
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Source_Order_No;


FUNCTION Get_Source_Release_No (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..source_release_no%TYPE;
   CURSOR get_attr IS
      SELECT source_release_no
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Source_Release_No;


FUNCTION Get_Source_Sequence_No (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..source_sequence_no%TYPE;
   CURSOR get_attr IS
      SELECT source_sequence_no
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Source_Sequence_No;


FUNCTION Get_Split_Reason (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..split_reason%TYPE;
   CURSOR get_attr IS
      SELECT split_reason
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Split_Reason;


FUNCTION Get_Mrb_Number (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..mrb_number%TYPE;
   CURSOR get_attr IS
      SELECT mrb_number
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Mrb_Number;


FUNCTION Get_Picklist_Type (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..picklist_type%TYPE;
   CURSOR get_attr IS
      SELECT picklist_type
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Shop_Order_Picklist_Type_API.Decode(temp_);
END Get_Picklist_Type;


FUNCTION Get_Configuration_Id (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..configuration_id%TYPE;
   CURSOR get_attr IS
      SELECT configuration_id
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Configuration_Id;


FUNCTION Get_Balanced_Cost_Diff (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..balanced_cost_diff%TYPE;
   CURSOR get_attr IS
      SELECT balanced_cost_diff
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Balanced_Cost_Diff;


FUNCTION Get_Job_Id (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..job_id%TYPE;
   CURSOR get_attr IS
      SELECT job_id
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Job_Id;


FUNCTION Get_Condition_Code (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..condition_code%TYPE;
   CURSOR get_attr IS
      SELECT condition_code
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Condition_Code;


FUNCTION Get_Lot_Batch_String (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..lot_batch_string%TYPE;
   CURSOR get_attr IS
      SELECT lot_batch_string
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Lot_Batch_String;


FUNCTION Get_Maint_Level_Struct (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..maint_level_struct%TYPE;
   CURSOR get_attr IS
      SELECT maint_level_struct
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Maint_Level_Struct;


FUNCTION Get_Maint_Level_Rout (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..maint_level_rout%TYPE;
   CURSOR get_attr IS
      SELECT maint_level_rout
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Maint_Level_Rout;


FUNCTION Get_Part_Ownership (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..part_ownership%TYPE;
   CURSOR get_attr IS
      SELECT part_ownership
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Part_Ownership_API.Decode(temp_);
END Get_Part_Ownership;


FUNCTION Get_Owning_Customer_No (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..owning_customer_no%TYPE;
   CURSOR get_attr IS
      SELECT owning_customer_no
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Owning_Customer_No;


FUNCTION Get_Mro_Visit_Id (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..mro_visit_id%TYPE;
   CURSOR get_attr IS
      SELECT mro_visit_id
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Mro_Visit_Id;


FUNCTION Get_Mro_Int_Ord_Header (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..mro_int_ord_header%TYPE;
   CURSOR get_attr IS
      SELECT mro_int_ord_header
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Mro_Int_Ord_Header;


FUNCTION Get_Mro_Int_Order (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..mro_int_order%TYPE;
   CURSOR get_attr IS
      SELECT mro_int_order
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Mro_Int_Order;


FUNCTION Get_Dispo_Line_Item (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..dispo_line_item%TYPE;
   CURSOR get_attr IS
      SELECT dispo_line_item
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Dispo_Line_Item;


FUNCTION Get_Mods_Defined (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..mods_defined%TYPE;
   CURSOR get_attr IS
      SELECT mods_defined
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Disposition_Action_API.Decode(temp_);
END Get_Mods_Defined;


FUNCTION Get_Repairs_Defined (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..repairs_defined%TYPE;
   CURSOR get_attr IS
      SELECT repairs_defined
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Disposition_Action_API.Decode(temp_);
END Get_Repairs_Defined;


FUNCTION Get_Partial_Part_Required (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..partial_part_required%TYPE;
   CURSOR get_attr IS
      SELECT partial_part_required
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Partial_Part_Required;


FUNCTION Get_Alternate_Component_Used (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..alternate_component_used%TYPE;
   CURSOR get_attr IS
      SELECT alternate_component_used
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Fnd_Boolean_API.Decode(temp_);
END Get_Alternate_Component_Used;


FUNCTION Get_Use_Cost_Distribution (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..use_cost_distribution%TYPE;
   CURSOR get_attr IS
      SELECT use_cost_distribution
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Use_Cost_Distribution_API.Decode(temp_);
END Get_Use_Cost_Distribution;


FUNCTION Get_Closed_In_Cbs (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..closed_in_cbs%TYPE;
   CURSOR get_attr IS
      SELECT closed_in_cbs
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Closed_In_Cbs_API.Decode(temp_);
END Get_Closed_In_Cbs;


FUNCTION Get_Case_Id (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..case_id%TYPE;
   CURSOR get_attr IS
      SELECT case_id
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Case_Id;


FUNCTION Get_Task_Id (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..task_id%TYPE;
   CURSOR get_attr IS
      SELECT task_id
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Task_Id;


FUNCTION Get_Cro_No (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..cro_no%TYPE;
   CURSOR get_attr IS
      SELECT cro_no
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Cro_No;


FUNCTION Get_Cro_Line (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..cro_line%TYPE;
   CURSOR get_attr IS
      SELECT cro_line
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Cro_Line;


FUNCTION Get_Eso_Supplier (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..eso_supplier%TYPE;
   CURSOR get_attr IS
      SELECT eso_supplier
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Eso_Supplier;


FUNCTION Get_Eso_Service_Type (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..eso_service_type%TYPE;
   CURSOR get_attr IS
      SELECT eso_service_type
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Eso_Service_Type;


FUNCTION Get_Shrinkage_Factor (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..shrinkage_factor%TYPE;
   CURSOR get_attr IS
      SELECT shrinkage_factor
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Shrinkage_Factor;


FUNCTION Get_Planned_Op_Scrap (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..planned_op_scrap%TYPE;
   CURSOR get_attr IS
      SELECT planned_op_scrap
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Planned_Op_Scrap;


FUNCTION Get (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN Public_Rec
IS
   temp_ Public_Rec;
   CURSOR get_attr IS
      SELECT order_code, contract, part_no, eng_chg_level, lot_batch_no, structure_alternative, routing_revision, routing_alternative, serial_begin, serial_end, revised_start_date, revised_due_date, need_date, close_date, close_tolerance, revised_qty_due, qty_on_order, qty_complete, qty_qa, qty_rejected, qa_scrapped, operation_scrapped, demand_code, sched_direction, resched_flag, source, proposed_location, note_id, date_entered, project_id, priority_category, source_order_no, source_release_no, source_sequence_no, split_reason, mrb_number, picklist_type, configuration_id, balanced_cost_diff, job_id, condition_code, lot_batch_string, maint_level_struct, maint_level_rout, part_ownership, owning_customer_no, mro_visit_id, mro_int_ord_header, mro_int_order, dispo_line_item, mods_defined, repairs_defined, partial_part_required, alternate_component_used, use_cost_distribution, closed_in_cbs, case_id, task_id, cro_no, cro_line, eso_supplier, eso_service_type, shrinkage_factor, planned_op_scrap
      FROM &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get;

-----------------------------------------------------------------------------
-------------------- FOUNDATION1 METHODS ------------------------------------
-----------------------------------------------------------------------------
-- Init
--   Dummy procedure that can be called at database startup to ensure that
--   this package is loaded into memory for performance reasons only.
-----------------------------------------------------------------------------

PROCEDURE Init
IS
BEGIN
   NULL;
END Init;


END &PKG;
/
SHOW ERROR

-----------------------------------------------------------------------------
------------------------------- STATEPACKAGE --------------------------------
-----------------------------------------------------------------------------
-- Separate Finite State Machine Package.
-----------------------------------------------------------------------------

PROMPT Creating &STATEPKG implementation

CREATE OR REPLACE PACKAGE BODY &STATEPKG IS

-----------------------------------------------------------------------------
----------------------- STATEPACKAGE DECLARATIONS ---------------------------
-----------------------------------------------------------------------------

state_separator_   CONSTANT VARCHAR2(1)     := Client_SYS.field_separator_;


FUNCTION Get_Db_Values___ RETURN VARCHAR2 DETERMINISTIC
IS
BEGIN
   RETURN('Released^Released^Released^Planned^Released^Parked^Reserved^Started^Closed^Cancelled^');
END Get_Db_Values___;


FUNCTION Get_Client_Values___ RETURN VARCHAR2 DETERMINISTIC
IS
BEGIN
   RETURN('Released^Released^Released^Planned^Released^Parked^Reserved^Started^Closed^Cancelled^');
END Get_Client_Values___;

-----------------------------------------------------------------------------
--------------- LU SPECIFIC STATEPACKAGE ACTION DECLARATIONS ----------------
-----------------------------------------------------------------------------

PROCEDURE Assign_Oh_Cost___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Do_Cancel___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Do_Close___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Do_Issue___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Do_Open___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Do_Park___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Do_Plan___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Do_Receive___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Do_Release___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Do_Report___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Do_Reserve___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Do_Unissue___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Do_Unreserve___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

PROCEDURE Trigger_Create_Analysis___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 );

-----------------------------------------------------------------------------
------------- LU SPECIFIC STATEPACKAGE CONDITION DECLARATIONS ---------------
-----------------------------------------------------------------------------

FUNCTION Create_Released___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN;

FUNCTION Is_Issued___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN;

FUNCTION Is_Released___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN;

FUNCTION Is_Reported___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN;

FUNCTION Is_Reserved___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN;

FUNCTION Order_Has_Auto_Close___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN;

FUNCTION Order_Has_General_Oh___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN;

FUNCTION Receive_Complete___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN;

FUNCTION gohcostisassigned___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN;

-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION STATEPACKAGE METHODS --------------------
-----------------------------------------------------------------------------
-- Finite_State_Set___
--    Updates the finite state indicator for an existing LU-instance.
--
-- Finite_State_Machine___
--    Processes an event by:
--    1. Fetching the current state
--    2. Evaluating any conditions for given event at current state
--    3. executing any exit code for the old state
--    4. Performing any action associated with given event
--    5. update the database to the new state
--    6. execute any entry code for the new state
--    7. Executing a state change to the new state
-----------------------------------------------------------------------------

FUNCTION Get_Object_By_Keys___ (
   order_no_ IN VARCHAR2,
   release_no_ IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN &TABLE%ROWTYPE
IS
   lu_rec_ &TABLE%ROWTYPE;
   CURSOR getrec IS
      SELECT *
      FROM  &TABLE
      WHERE order_no = order_no_
          AND   release_no = release_no_
          AND   sequence_no = sequence_no_;
BEGIN
   OPEN getrec;
   FETCH getrec INTO lu_rec_;
   CLOSE getrec;
   RETURN(lu_rec_);
END Get_Object_By_Keys___;


PROCEDURE Finite_State_Set___ (
   rec_   IN OUT &TABLE%ROWTYPE,
   state_ IN     VARCHAR2 )
IS
BEGIN
   UPDATE shop_ord_tab
      SET &OBJSTATE = state_,
          rowversion = rec_.rowversion
      WHERE order_no = rec_.order_no
          AND    release_no = rec_.release_no
          AND    sequence_no = rec_.sequence_no;
END Finite_State_Set___;


PROCEDURE Finite_State_Machine___ (
   rec_   IN OUT &TABLE%ROWTYPE,
   event_ IN     VARCHAR2,
   attr_  IN OUT VARCHAR2 )
IS
   state_ VARCHAR2(30);
BEGIN
   state_ := rec_.rowstate;
   IF (state_ IS NULL) THEN
      IF (event_ IS NULL) THEN
         IF (NOT Create_Released___(rec_)) THEN
            Do_Plan___(rec_, attr_);
            Finite_State_Set___(rec_, 'Planned');
         ELSIF (Create_Released___(rec_)) THEN
            Do_Release___(rec_, attr_);
            Finite_State_Set___(rec_, 'Released');
         END IF;
      ELSE
         Error_SYS.State_Event_Not_Handled(lu_name_, event_, Finite_State_Decode__(state_));
      END IF;
   ELSIF (state_ = 'Cancelled') THEN
      Error_SYS.State_Event_Not_Handled(lu_name_, event_, Finite_State_Decode__(state_));
   ELSIF (state_ = 'Closed') THEN
      IF (event_ = 'Open') THEN
         Do_Open___(rec_, attr_);
         Trigger_Create_Analysis___(rec_, attr_);
         Finite_State_Set___(rec_, 'Started');
      ELSE
         Error_SYS.State_Event_Not_Handled(lu_name_, event_, Finite_State_Decode__(state_));
      END IF;
   ELSIF (state_ = 'Parked') THEN
      IF (event_ = 'Plan') THEN
         Do_Plan___(rec_, attr_);
         Finite_State_Set___(rec_, 'Planned');
      ELSIF (event_ = 'Release') THEN
         Do_Release___(rec_, attr_);
         Finite_State_Set___(rec_, 'Released');
      ELSE
         Error_SYS.State_Event_Not_Handled(lu_name_, event_, Finite_State_Decode__(state_));
      END IF;
   ELSIF (state_ = 'Planned') THEN
      IF (event_ = 'Cancel') THEN
         Do_Cancel___(rec_, attr_);
         Finite_State_Set___(rec_, 'Cancelled');
      ELSIF (event_ = 'Close') THEN
         Do_Close___(rec_, attr_);
         Finite_State_Set___(rec_, 'Closed');
      ELSIF (event_ = 'Park') THEN
         Do_Park___(rec_, attr_);
         Finite_State_Set___(rec_, 'Parked');
      ELSIF (event_ = 'Release') THEN
         Do_Release___(rec_, attr_);
         Finite_State_Set___(rec_, 'Released');
      ELSE
         Error_SYS.State_Event_Not_Handled(lu_name_, event_, Finite_State_Decode__(state_));
      END IF;
   ELSIF (state_ = 'Released') THEN
      IF (event_ = 'Park') THEN
         Assign_Oh_Cost___(rec_, attr_);
         Trigger_Create_Analysis___(rec_, attr_);
         Do_Park___(rec_, attr_);
         Finite_State_Set___(rec_, 'Parked');
      ELSIF (event_ = 'Plan') THEN
         Do_Plan___(rec_, attr_);
         Finite_State_Set___(rec_, 'Planned');
      ELSIF (event_ = 'Receive') THEN
         Do_Receive___(rec_, attr_);
      ELSE
         Error_SYS.State_Event_Not_Handled(lu_name_, event_, Finite_State_Decode__(state_));
      END IF;
   ELSIF (state_ = 'Released') THEN
      IF (event_ = 'Report') THEN
         IF (Receive_Complete___(rec_) AND Order_Has_Auto_Close___(rec_)) THEN
            Assign_Oh_Cost___(rec_, attr_);
            Trigger_Create_Analysis___(rec_, attr_);
            Do_Close___(rec_, attr_);
            Do_Report___(rec_, attr_);
            Finite_State_Set___(rec_, 'Closed');
         END IF;
      ELSE
         Error_SYS.State_Event_Not_Handled(lu_name_, event_, Finite_State_Decode__(state_));
      END IF;
   ELSIF (state_ = 'Released') THEN
      IF (event_ = 'Close') THEN
         Do_Close___(rec_, attr_);
         Finite_State_Set___(rec_, 'Closed');
      ELSIF (event_ = 'Reserve') THEN
         Assign_Oh_Cost___(rec_, attr_);
         Trigger_Create_Analysis___(rec_, attr_);
         Do_Reserve___(rec_, attr_);
         Finite_State_Set___(rec_, 'Reserved');
      ELSIF (event_ = 'SetStarted') THEN
         Trigger_Create_Analysis___(rec_, attr_);
         Finite_State_Set___(rec_, 'Started');
      ELSE
         Error_SYS.State_Event_Not_Handled(lu_name_, event_, Finite_State_Decode__(state_));
      END IF;
   ELSIF (state_ = 'Released') THEN
      IF (event_ = 'Cancel') THEN
         Do_Cancel___(rec_, attr_);
         Finite_State_Set___(rec_, 'Cancelled');
      ELSIF (event_ = 'Issue') THEN
         Do_Issue___(rec_, attr_);
      ELSE
         Error_SYS.State_Event_Not_Handled(lu_name_, event_, Finite_State_Decode__(state_));
      END IF;
   ELSIF (state_ = 'Reserved') THEN
      IF (event_ = 'Cancel') THEN
         Do_Cancel___(rec_, attr_);
         Finite_State_Set___(rec_, 'Cancelled');
      ELSIF (event_ = 'Close') THEN
         IF (Order_Has_General_Oh___(rec_)) THEN
            Do_Close___(rec_, attr_);
            Finite_State_Set___(rec_, 'Closed');
         END IF;
      ELSIF (event_ = 'Issue') THEN
         Do_Issue___(rec_, attr_);
         Assign_Oh_Cost___(rec_, attr_);
         Trigger_Create_Analysis___(rec_, attr_);
         Finite_State_Set___(rec_, 'Started');
      ELSIF (event_ = 'Receive') THEN
         IF (Receive_Complete___(rec_) AND Order_Has_Auto_Close___(rec_)) THEN
            Do_Receive___(rec_, attr_);
            Assign_Oh_Cost___(rec_, attr_);
            Trigger_Create_Analysis___(rec_, attr_);
            Do_Close___(rec_, attr_);
            Finite_State_Set___(rec_, 'Closed');
         END IF;
      ELSIF (event_ = 'Report') THEN
         Do_Report___(rec_, attr_);
         Assign_Oh_Cost___(rec_, attr_);
         Trigger_Create_Analysis___(rec_, attr_);
         Finite_State_Set___(rec_, 'Started');
      ELSIF (event_ = 'Reserve') THEN
         Do_Reserve___(rec_, attr_);
      ELSIF (event_ = 'SetStarted') THEN
         Trigger_Create_Analysis___(rec_, attr_);
         Finite_State_Set___(rec_, 'Started');
      ELSIF (event_ = 'Unreserve') THEN
         IF (NOT Is_Reserved___(rec_)) THEN
            Finite_State_Set___(rec_, 'Released');
         ELSIF (Is_Reserved___(rec_)) THEN
            Do_Unreserve___(rec_, attr_);
         ELSIF (Is_Released___(rec_) AND gohcostisassigned___(rec_)) THEN
            NULL;
         END IF;
      ELSE
         Error_SYS.State_Event_Not_Handled(lu_name_, event_, Finite_State_Decode__(state_));
      END IF;
   ELSIF (state_ = 'Started') THEN
      IF (event_ = 'Close') THEN
         Do_Close___(rec_, attr_);
         Finite_State_Set___(rec_, 'Closed');
      ELSIF (event_ = 'Issue') THEN
         Do_Issue___(rec_, attr_);
      ELSIF (event_ = 'Receive') THEN
         IF (Receive_Complete___(rec_) AND Order_Has_Auto_Close___(rec_)) THEN
            Do_Receive___(rec_, attr_);
            Do_Close___(rec_, attr_);
            Finite_State_Set___(rec_, 'Closed');
         END IF;
      ELSIF (event_ = 'Report') THEN
         IF (Receive_Complete___(rec_) AND Order_Has_Auto_Close___(rec_)) THEN
            Do_Report___(rec_, attr_);
            Do_Close___(rec_, attr_);
            Do_Close___(rec_, attr_);
            Finite_State_Set___(rec_, 'Closed');
         END IF;
      ELSIF (event_ = 'Reserve') THEN
         Do_Reserve___(rec_, attr_);
      ELSIF (event_ = 'Unissue') THEN
         IF (NOT Is_Issued___(rec_) AND  NOT Is_Reported___(rec_)) THEN
            Finite_State_Set___(rec_, 'Reserved');
         ELSIF (Is_Issued___(rec_)) THEN
            Do_Unissue___(rec_, attr_);
         END IF;
      ELSIF (event_ = 'Unreserve') THEN
         Do_Unreserve___(rec_, attr_);
      ELSE
         Error_SYS.State_Event_Not_Handled(lu_name_, event_, Finite_State_Decode__(state_));
      END IF;
   ELSE
      Error_SYS.State_Not_Exist(lu_name_, Finite_State_Decode__(state_));
   END IF;
END Finite_State_Machine___;

-----------------------------------------------------------------------------
-------------------- PRIVATE STATEPACKAGE METHODS ---------------------------
-----------------------------------------------------------------------------
-- Finite_State_Decode__
--   Returns the client equivalent for any database representation of
--   a state name = objstate.
--
-- Finite_State_Encode__
--   Returns the database equivalent for any client representation of
--   a state name = state.
--
-- Enumerate_States__
--   Returns a list of all possible finite states in client terminology.
--
-- Enumerate_States_Db__
--   Returns a list of all possible finite states in database terminology.
--
-- Finite_State_Events__
--   Returns a list of allowed events for a given state
--   NOTE! Regardless of conditions if not otherwize encoded
--
-- Enumerate_Events__
--   Returns a list of all possible events.
-----------------------------------------------------------------------------

FUNCTION Finite_State_Decode__ (
   db_state_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN(Domain_SYS.Decode_(Domain_SYS.Get_Translated_Values(lu_name_), Get_Db_Values___, db_state_));
END Finite_State_Decode__;


FUNCTION Finite_State_Encode__ (
   client_state_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN(Domain_SYS.Encode_(Domain_SYS.Get_Translated_Values(lu_name_), Get_Db_Values___, client_state_));
END Finite_State_Encode__;


PROCEDURE Enumerate_States__ (
   client_values_ OUT VARCHAR2 )
IS
BEGIN
   client_values_ := Domain_SYS.Enumerate_(Domain_SYS.Get_Translated_Values(lu_name_));
END Enumerate_States__;


PROCEDURE Enumerate_States_Db__ (
   db_values_ OUT VARCHAR2 )
IS
BEGIN
   db_values_ := Domain_SYS.Enumerate_(Get_Db_Values___);
END Enumerate_States_Db__;


FUNCTION Finite_State_Events__ (
   db_state_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (db_state_ IS NULL) THEN
      RETURN NULL;
   ELSIF (db_state_ = 'Cancelled') THEN
      RETURN NULL;
   ELSIF (db_state_ = 'Closed') THEN
      RETURN 'Open^';
   ELSIF (db_state_ = 'Parked') THEN
      RETURN 'Plan^Release^';
   ELSIF (db_state_ = 'Planned') THEN
      RETURN 'Cancel^Close^Park^Release^';
   ELSIF (db_state_ = 'Released') THEN
      RETURN 'Park^Plan^Receive^';
   ELSIF (db_state_ = 'Released') THEN
      RETURN 'Report^';
   ELSIF (db_state_ = 'Released') THEN
      RETURN 'Reserve^SetStarted^Close^';
   ELSIF (db_state_ = 'Released') THEN
      RETURN 'Cancel^Issue^';
   ELSIF (db_state_ = 'Reserved') THEN
      RETURN 'Cancel^Issue^Receive^Report^Reserve^SetStarted^Unreserve^Close^';
   ELSIF (db_state_ = 'Started') THEN
      RETURN 'Close^Issue^Receive^Report^Reserve^Unissue^Unreserve^';
   ELSE
      RETURN NULL;
   END IF;
END Finite_State_Events__;


PROCEDURE Enumerate_Events__ (
   db_events_ OUT VARCHAR2 )
IS
BEGIN
   db_events_ := 'Reserve^Open^Park^Report^Receive^Release^Issue^Close^Unissue^Unreserve^Cancel^SetStarted^Plan^';
END Enumerate_Events__;

-----------------------------------------------------------------------------
----------------- STATEPACKAGE PUBLIC TRANSLATION METHODS -------------------
-----------------------------------------------------------------------------

PROCEDURE Language_Refreshed
IS
BEGIN
   Domain_SYS.Language_Refreshed(lu_name_, Get_Client_Values___, Get_Db_Values___, 'STATE');
END Language_Refreshed;

-----------------------------------------------------------------------------
------------------- LU SPECIFIC STATEPACKAGE ACTIONS ------------------------
-----------------------------------------------------------------------------

PROCEDURE Assign_Oh_Cost___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Assign_Oh_Cost___;


PROCEDURE Do_Cancel___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Cancel___;


PROCEDURE Do_Close___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Close___;


PROCEDURE Do_Issue___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Issue___;


PROCEDURE Do_Open___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Open___;


PROCEDURE Do_Park___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Park___;


PROCEDURE Do_Plan___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Plan___;


PROCEDURE Do_Receive___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Receive___;


PROCEDURE Do_Release___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Release___;


PROCEDURE Do_Report___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Report___;


PROCEDURE Do_Reserve___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Reserve___;


PROCEDURE Do_Unissue___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Unissue___;


PROCEDURE Do_Unreserve___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Unreserve___;


PROCEDURE Trigger_Create_Analysis___ (
   rec_  IN OUT &TABLE%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   NULL;
END Trigger_Create_Analysis___;

-----------------------------------------------------------------------------
------------------ LU SPECIFIC STATEPACKAGE CONDITIONS ----------------------
-----------------------------------------------------------------------------

FUNCTION Create_Released___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN
IS
BEGIN
   RETURN FALSE;
END Create_Released___;


FUNCTION Is_Issued___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN
IS
BEGIN
   RETURN FALSE;
END Is_Issued___;


FUNCTION Is_Released___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN
IS
BEGIN
   RETURN FALSE;
END Is_Released___;


FUNCTION Is_Reported___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN
IS
BEGIN
   RETURN FALSE;
END Is_Reported___;


FUNCTION Is_Reserved___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN
IS
BEGIN
   RETURN FALSE;
END Is_Reserved___;


FUNCTION Order_Has_Auto_Close___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN
IS
BEGIN
   RETURN FALSE;
END Order_Has_Auto_Close___;


FUNCTION Order_Has_General_Oh___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN
IS
BEGIN
   RETURN FALSE;
END Order_Has_General_Oh___;


FUNCTION Receive_Complete___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN
IS
BEGIN
   RETURN FALSE;
END Receive_Complete___;


FUNCTION gohcostisassigned___ (
   rec_  IN     &TABLE%ROWTYPE ) RETURN BOOLEAN
IS
BEGIN
   RETURN FALSE;
END gohcostisassigned___;

-----------------------------------------------------------------------------
-------------------- STATEPACKAGE FOUNDATION1 METHODS -----------------------
-----------------------------------------------------------------------------
-- Init
--   Dummy procedure that can be called at database startup to ensure that
--   this package is loaded into memory for performance reasons only.
-----------------------------------------------------------------------------

PROCEDURE Init
IS
BEGIN
   Domain_SYS.Load_State(lu_name_, Get_Client_Values___, Get_Db_Values___);
END Init;


BEGIN
   --
   -- Load the context with values
   --
   Init;
END &STATEPKG;
/
SHOW ERROR

BEGIN
   SHOP_ORD0_API.Language_Refreshed;
END;
/


UNDEFINE MODULE
UNDEFINE LU
UNDEFINE TABLE
UNDEFINE VIEW
UNDEFINE PKG
UNDEFINE STATEPKG
UNDEFINE OBJID
UNDEFINE OBJVERSION
UNDEFINE OBJSTATE
UNDEFINE OBJEVENTS
UNDEFINE STATE
-----------------------------------------------------------------------------