-----------------------------------------------------------------------------
--
--  Logical unit: IdentityPayInfo
--
--  Purpose: Handles Party Type Id Payment Information
--
--  IFS/Design Template Version 2.2
--
--  Date    Sign     History
--  ------  ----     -----------------------------------------------------------
--  960730  DAKA     Created
--  960731  DAKA     View definition corrected.
--  960802  MABE     Added procedure Remove_Set. Modified Check_Delete.
--  960821  MABE     Removed procedure Remove_Set. Added procedure Instance_Exists.
--  960927  MABE     Removed call to reference by Bank Account in Check_Delete.
--  961011  MABE     Changes to fit Enterprise module.
--  961129  DAKA     Columns Priority,Blocked_For_Parked_Payment,Other_Payee.
--  961205  MABE     Changed error message for Exist changed.
--                   Added procedure Create_Party_Type_Id.
--  961205  Yohe     Added view PARTY_TYPE_ID_PAY_INFO_SU_QRY and
--                   PARTY_TYPE_ID_PAY_INFO_CU_QRY.
--  961209  MABE     Corrected type return by function Get_Blocked_For_Payment
--                   to VARCHAR2.
--  961213  MABE     VIEW2 and VIEW3 changed to VIEW4 and VIEW5.
--  970102  MABE     Changes to fit Domain concept.
--  970106  MABE     Added function Get_Netting_Allowed.
--                   Column DUMMY deleted.
--  970114  MABE     Developing of query forms.
--  970121  MABE     Added columns is_note and note to Query views. (not finished)
--  970219  DAKA     Columns INTEREST_TEMPLATE , REMINDER_TEMPLATE added.
--  970220  MABE     Added default templates when creating customer
--                   by Create_Party_Type_Id.
--  970303  MABE     Added functions Get_Reminder_Template and Get_Interest_Template.
--  970306  MABE     Handling of notes added to views for query.
--  970306  DAKA     Call to party_type_id_invoice_info_api.exist added
--  970318  MABE     Checking if PartyTypeIdInvoiceInfo exists excluded
--                   for party type 'COMPANY'.
--  970512  SLKO     Some performance improvement.
--  970908  MABE     Added function Get_Payment_Delay.
--  970916  MABE     Corrected Get_Payment_Delay.
--  971029  MABE     Joins with company_tab and party_type_identity_tab instead
--                   of function calls.
--  980415  DAKA     Function Get_Name created
--  980512  MABE     Updated to fit IFS/Design 2.1.1A
--  980515  MABE     Added missing columns PARTY_TYPE_DB.
--  980519  MARK     Modified to use party_type_db values
--  980522  MABE     Corrected usage of party_type_db.
--  980602  DAKA     Identity added to LU
--  980602  PICZ     'SELECT *' replaced with 'SELECT '1'' in Instance_Exists
--  980629  WOBL     Added comments to _db columns
--  981103  KATH     Bug # 4399 Fixed - add new function called Validate_Identity() to validate
--                   supplies & customers
--  981118  MABE     Added missing comments to _db columns.
--  981130  MABE     Changed to fit Enterp 1.3.0.
--  981208  MABE     Removed VIEW PARTY_TYPE_ID_PAY_INFO_REF
--  981214  PICZ     Changes to Prepare_Insert___
--  981222  DAKA     US Localization code added
--  990201  DAKA     Connection with ENTERP improved
--  990208  MarK     Changes with regards to the Get_Currency_Rate.
--  990209  DAKA     Synchronized witch model
--  990406  MABE     Corrected problem with customer in not default company.
--  990419  MABE     Template modification to increase performance.
--  990625  MABE     Copied from PartyPayInfo and PartyTypeIdPayInfo due
--                   to replace of party with identity.
--  990811  MABE     substr -> substr_b.
--  990920  FRPO     Added IID PaymentAdvice
--  990928  FRPO     Added default value for Payment Advice (No Advice) in Prepare_Insert___
--                   for use in Create_Identity_Pay_Info for party_type = company
--  991012  FRPO     Other Payer made available for customers FIN123
--  990914  REANPL   Fetch_Tolerance modified to support payment tolerance for Supplier
--  991214  PICZ     Copy_Customer and Copy_Supplier added
--  000224  WITOPL   Removing DBMS_Output
--  000304  PICZ     Call #32631 corrected
--  000410  PICZ     Function Get_Group_For_Identity added
--  000412  PICZ     Function Get_Payment_Advice_Db added
--  000825  REANPL   Added new columns to VIEW:
--                   deduction_group,corporation_id,member_id,send_reminder_to_payer,send_interest_inv_to_payer
--  000829  REANPL   Added new columns to Prepare_Insert___, Copy_Customer
--  000929  PICZ     Call #49661 (procedure Save_Identity_Notes___ added)
--  001006  PICZ     Call #49721 (function Get_Other_Payee_Ded_Group_Desc added)
--  010220  LiSv     For new Create Company concept added new view identity_pay__etc and _pct.
--                   Added procedures Make_Company, Copy___, Import___ and Export___.
--  010305  MAMIPL   Bug #20283. Amount and Percent tolerance only positive value allowed.
--  010503  visuus   Bug Fix 20212: D&B number not copied when copying a customer.
--  010611  MACHSE   Bug# 15677 Fixed. Call to General_SYS.Init_Method.
--  010816  OVJOSE   Added Create Company translation method Create_Company_Translations___
--  011009  RAFA     Bug #23834 Added function Cust_Open_Items_Exist
--  020304  RAFA     IID 10998/10999 Call 77665 corrected Copy_Payment_Address___
--  020308  LISV     Call 78225 Corrected.
--  020319  PPer     Bug # 28324. Changed "PAYMENTSONACCOUNTEXIST" To "PAYMENTONACCNTEXIST".
--  021008  Nimalk   Removed usage of the view Company_Finance_Auth in viewes
--                   and replaced by view Company_Finance_Auth1 using EXISTS caluse instead of joins
--  021224  MACHLK   SP3 Merge Bug ID 34081, 34083.
--  030418  JAKALK   DEFI165N Added column disc_days_tolerance.
--  030506  NiKaLK   Added new views Multi_Customer_Info and Multi_Supplier_Info
--  030609  Kupelk   FRFI154. Added column next_payment_matching_id.
--                   Added Get_Next_Pay_Matching_Id, Get_Payment_Matching_Id .
--  030729  Gepelk   SP4 Merge. Bug # 35316. Modified  'Check_Cascade___'.
--  030827  KuPelk   Added next_payment_matching_id column to the method Copy___.
--  040325  Thsrlk   SP1 Merge
--  040629  anpelk   FIPR338A2: Unicode Changes
--  040924  nalslk   FITH354 - Modified calls to Payment_Library_API.Get_Currency_Rate
--                   and removed retrieving default_currency_type from Currency_Type_API directly.
--  041001  TsYolk   FIPR360, Added column Group_ID to IDENTITY_PAY_INFO_SU_QRY and IDENTITY_PAY_INFO_CU_QRY.
--  041104  GRRO     FIJP345 Payment Method Plan added rule_id to IDENTITY_PAY_INFO
--  041104  TsYolk   Call B119368, Modified the WHERE clause of IDENTITY_PAY_INFO_CU_QRY.
--  041124  AnGiSe   FITH352, Added column tax_withholding to view IDENTITY_PAY_INFO_CU_QRY.
--  041203  AnGiSe   FITH352, Added column balance_excl_withheld to view IDENTITY_PAY_INFO_SU_QRY.
--  050105  reanpl   FITH351 Added payment_receipt_type
--  050309  Samclk   FIPR360 - New Notes dialog functionality - Changed IDENTITY_PAY_INFO_CU_QRY.
--  050310  Samclk   FIPR360 - New Notes dialog functionality - Changed IDENTITY_PAY_INFO_SU_QRY.
--  050323  Jeguse   Moved MULTI_CUS_DETAILS_QRY, MULTI_SUP_DETAILS_QRY and MULTI_SUP_ADDRESS_QRY from Ledgitem.apy
--  051011  NiFelk   FIPR360, Notes code clean up.
--  060215  NiFelk   LCS Merge 48619. Added new method Create_Cus_Other_Payee_Attr__.
--  060728  Vohelk   FIPL617A - Added Template_id to the IDENTITY_PAY_INFO view
--  060829  Chhulk   FIBR620A - Modified Prepare_Insert___
--  060831  Shsalk   LCS Merge 56765. Increased the variable lenghth.
--  060919  RUFELK   B139515 - Added the parameter 'company' to the Get_Template_Id() Function.
--  061106  Lisvse   FIBR621A - Added check_recipient.
--  061121  RUFELK   FIPL612A - Renamed the status_id column into ledger_status_type.
--  061222  Kagalk   LCS Merge 61779, Modified Check_Cascade___
--  070109  Shsalk   LCS Merge 62571, Modified cursor to fetch member id in the method Get_Member_Id.  
--  070327  RAFA     LCS Merge Bug 51783
--  070508  Surmlk   Removed the use of SUBSTRB from the view PAYER_INFO_QRY
--  070627  Shsalk   LCS Merge 65361, Insert cursor selected value to payment_delay column in Copy_Customer method.
--  070816  Shsalk   B146601 Corrected accoding to a request from SDMAN module.
--  070827  Naadlk   LCS Merge 61494, Added advanced invoice column to views IDENTITY_PAY_INFO_SU_QRY,IDENTITY_PAY_INFO_CU_QRY,PAYER_INFO_QRY. 
--  070906  Paralk   B148391  Modified Copy_Customer()
--  071114  Paralk   Bug 69035, Added reminder_template_id,interest_template_id and their descriptions to VIEW_CU_QRY  
--  071127  Shsalk   Bug 68653, Added new columns to IDENTITY LOV views.
--  080108  Paralk   Bug 69035, Added reminder_template_id,interest_template_id and their descriptions to VIEW_PAYER_QRY   
--  080322  Shsalk   Bug 72177 Corrected. Added bic_code to the copy identity functionality.
--  080417  Paralk   Bug 73125, Added template_id to Copy_Customer() and Copy_Supplier().
--  080429  Nudilk   Bug 72612, Modified procedure Exist() 
--  080528  DiUdlk   Bug 74138, Modified cursor exist_company in Import__ function.
--  081003  Hawalk   Bug 77136, Table join with customer_info_tab and supplier_info_tab for VIEW_CU_QRY and VIEW_SU_QRY respectively,
--  081003           to get name and association no directly.
---------------------------------------------------------------------------------

DEFINE MODULE           = PAYLED
DEFINE LU               = IdentityPayInfo
DEFINE TABLE            = IDENTITY_PAY_INFO_TAB
DEFINE VIEW             = IDENTITY_PAY_INFO
DEFINE VIEWPCT          = IDENTITY_PAY_INFO_PCT
DEFINE VIEW_SU_QRY      = IDENTITY_PAY_INFO_SU_QRY
DEFINE VIEW_CU_QRY      = IDENTITY_PAY_INFO_CU_QRY
DEFINE VIEW_SUPP        = IDENTITY_PAY_INFO_SUPP
DEFINE VIEW_CUST        = IDENTITY_PAY_INFO_CUST
DEFINE VIEW_LOV         = IDENTITY_PAY_INFO_LOV
DEFINE VIEW_ALL         = IDENTITY_PAY_INFO_ALL
DEFINE VIEW_PAYER_QRY   = PAYER_INFO_QRY

DEFINE VIEW_MULTI_CUS   = MULTI_CUS_DETAILS_QRY
DEFINE VIEW_MULTI_SUP   = MULTI_SUP_DETAILS_QRY
DEFINE VIEW_MULTI_ADD   = MULTI_SUP_ADDRESS_QRY

DEFINE PKG              = IDENTITY_PAY_INFO_API

DEFINE OBJID            = rowid
DEFINE OBJVERSION       = ltrim(lpad(to_char(rowversion),2000))

DEFINE OBJID_ptipi      = ptipi.rowid
DEFINE OBJVERSION_ptipi = ltrim(lpad(to_char(ptipi.rowversion),2000))

DEFINE OBJID_p          = p.rowid
DEFINE OBJVERSION_p     = ltrim(lpad(to_char(p.rowversion),2000))


-----------------------------------------------------------------------------
-------------------- VIEWS FOR SELECTS --------------------------------------
-----------------------------------------------------------------------------

PROMPT Creating &VIEW view

CREATE OR REPLACE FORCE VIEW &VIEW AS
SELECT p.company                      company,
       identity                       identity,
       Party_Type_API.Decode(party_type) party_type,
       party_type                     party_type_db,
       priority                       priority,
       blocked_for_payment            blocked_for_payment,
       other_payee_identity           other_payee_identity,
       interest_template              interest_template,
       reminder_template              reminder_template,
       payment_delay                  payment_delay,
       amount_tolerance               amount_tolerance,
       percent_tolerance              percent_tolerance,
       disc_days_tolerance            disc_days_tolerance,
       netting_allowed                netting_allowed,
       format_no                      format_no,
       Payment_Advice_API.Decode(payment_advice) payment_advice,
       payment_advice                 payment_advice_db,
       deduction_group                deduction_group,
       corporation_id                 corporation_id,
       member_id                      member_id,
       send_reminder_to_payer         send_reminder_to_payer,
       send_interest_inv_to_payer     send_interest_inv_to_payer,
       rule_id                        rule_id,
       Payment_Receipt_Type_API.Decode(payment_receipt_type) payment_receipt_type,
       payment_receipt_type           payment_receipt_type_db,
       template_id                    template_id,
       Check_Recipient_API.Decode(check_recipient) check_recipient,
       check_recipient                check_recipient_db,
       send_statement_of_acc_to_payer send_statement_of_acc_to_payer,
       p.&OBJID                       objid,
       &OBJVERSION                    objversion
FROM   identity_pay_info_tab p
WHERE  EXISTS (SELECT * FROM company_finance_auth1 c WHERE p.company = c.company)
WITH   read only;

COMMENT ON TABLE &VIEW
   IS 'LU=&LU^PROMPT=Identity Pay Info^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW..company
   IS 'FLAGS=PMI--^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Company^REF=CompanyPayInfo^';
COMMENT ON COLUMN &VIEW..identity
   IS 'FLAGS=KMI--^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Identity^';
COMMENT ON COLUMN &VIEW..party_type
   IS 'FLAGS=KMI-L^DATATYPE=STRING(200)^PROMPT=Party Type^REF=PartyType^';
COMMENT ON COLUMN &VIEW..party_type_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Party Type^';
COMMENT ON COLUMN &VIEW..priority
   IS 'FLAGS=A-IUL^DATATYPE=NUMBER^PROMPT=Priority^';
COMMENT ON COLUMN &VIEW..blocked_for_payment
   IS 'FLAGS=A-IUL^DATATYPE=BOOLEAN^PROMPT=Blocked For Payment^';
COMMENT ON COLUMN &VIEW..other_payee_identity
   IS 'FLAGS=A-IUL^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Other Payee Identity^REF=IdentityPayInfo(company)^';
COMMENT ON COLUMN &VIEW..interest_template
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Interest Template^REF=InterestTemplate(company)^';
COMMENT ON COLUMN &VIEW..reminder_template
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Reminder Template^REF=ReminderTemplate(company)^';
COMMENT ON COLUMN &VIEW..payment_delay
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Number of Days Usual Payment Delay^';
COMMENT ON COLUMN &VIEW..amount_tolerance
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Amount Tolerance^';
COMMENT ON COLUMN &VIEW..percent_tolerance
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Percent Tolerance^';
COMMENT ON COLUMN &VIEW..disc_days_tolerance
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Tolerance Days for Discount^';
COMMENT ON COLUMN &VIEW..netting_allowed
   IS 'FLAGS=AMIUL^DATATYPE=BOOLEAN^PROMPT=Netting Allowed^';
COMMENT ON COLUMN &VIEW..format_no
   IS 'FLAGS=AMI--^DATATYPE=NUMBER^PROMPT=Format No^';
COMMENT ON COLUMN &VIEW..payment_advice
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Payment Advice^REF=PaymentAdvice^';
COMMENT ON COLUMN &VIEW..payment_advice_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Payment Advice^';
COMMENT ON COLUMN &VIEW..deduction_group
   IS 'FLAGS=A-IUL^DATATYPE=STRING(20)^PROMPT=Deduction Group^REF=DeductionGroup^';
COMMENT ON COLUMN &VIEW..corporation_id
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)^PROMPT=Corporation Id^';
COMMENT ON COLUMN &VIEW..member_id
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)^PROMPT=Member Id^';
COMMENT ON COLUMN &VIEW..send_reminder_to_payer
   IS 'FLAGS=A-IU-^DATATYPE=STRING(5)^PROMPT=Send Reminder To Payer^';
COMMENT ON COLUMN &VIEW..send_interest_inv_to_payer
   IS 'FLAGS=A-IU-^DATATYPE=STRING(5)^PROMPT=Send Interest Inv To Payer^';
COMMENT ON COLUMN &VIEW..rule_id
   IS 'FLAGS=A-IUL^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Rule Id^REF=PayMethodRule(company)^';
COMMENT ON COLUMN &VIEW..payment_receipt_type
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Payment Receipt^REF=PaymentReceiptType^';
COMMENT ON COLUMN &VIEW..payment_receipt_type_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Payment Receipt^';
COMMENT ON COLUMN &VIEW..template_id
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Template Id^REF=ConfirmationStmntTempl(company)^';
COMMENT ON COLUMN &VIEW..check_recipient
   IS 'FLAGS=AMIUL^DATATYPE=STRING(200)^PROMPT=Check Recipient^REF=CheckRecipient^';
COMMENT ON COLUMN &VIEW..check_recipient_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Check Recipient^';
COMMENT ON COLUMN &VIEW..send_statement_of_acc_to_payer                        
   IS 'FLAGS=A-IU-^DATATYPE=STRING(5)^PROMPT=Send Statement Of Account To Payer^';

-- Bug 77136, begin, Table join with supplier_info_tab, in order to get name and association no directly.
PROMPT Creating &VIEW_SU_QRY VIEW
CREATE OR REPLACE FORCE VIEW &VIEW_SU_QRY AS
SELECT p.company                                                           company,
       p.identity                                                          identity,
       Party_Type_API.Decode(p.party_type)                                 party_type,
       p.party_type                                                        party_type_db,
       si.name                                                             name,
       si.association_no                                                   association_no,                               
       NVL(Ledger_Item_Util_API.Get_Dom_Balance(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type),
                                Company_Pay_Info_API.Get_Query_Voucher_Date), 0)
                                                                           balance,
       NVL(Ledger_Item_Util_API.Get_Dom_Balance(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type)), 0)   pay_doc_balance,
       NVL(Ledger_Item_Util_API.Get_Adv_Inv_Dom_Balance(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type)), 0)   adv_inv_balance,
       NVL(Ledger_Item_Util_API.Get_Dom_Amount_Due(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type),
                                Company_Pay_Info_API.Get_Query_Voucher_Date), 0)
                                                                           amount_due,
       NVL(Ledger_Item_Util_API.Get_Dom_Amount_Due(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type),
                                Company_Pay_Info_API.Get_Query_Voucher_Date,
                                'TRUE'), 0)
                                                                           pay_doc_amount_due,
       NVL(Ledger_Item_Util_API.Get_Dom_Pre_Payment_Balance(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type),
                                Company_Pay_Info_API.Get_Query_Voucher_Date), 0)
                                                                           pre_payment_balance,
       NVL(Ledger_Item_Util_API.Get_Dom_Bal_Excl_Withh(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type),
                                Company_Pay_Info_API.Get_Query_Voucher_Date), 0)
                                                                           balance_excl_withheld,
       decode(p.other_payee_identity,NULL,'FALSE','TRUE')                  other_party_type_exists,
       Identity_Note_API.Check_Note_Exist(p.company,
                                          p.identity,
                                          p.party_type)                    is_note,
       i.group_id                                                          group_id,
       &OBJID_p                                                            objid,
       &OBJVERSION_p                                                       objversion
FROM   identity_pay_info_tab     p,
       identity_invoice_info_tab i,
       supplier_info_tab         si
WHERE  EXISTS (SELECT * FROM company_finance_auth1 c WHERE p.company = c.company)
AND    p.party_type = 'SUPPLIER'
AND    p.company    = i.company
AND    p.identity   = i.identity
AND    p.party_type = i.party_type
AND    p.identity   = si.supplier_id
WITH   read only;

COMMENT ON TABLE &VIEW_SU_QRY
   IS 'LU=&LU^PROMPT=Identity Pay Info^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW_SU_QRY..company
   IS 'FLAGS=PM---^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Company^REF=Company/NOCHECK^';
COMMENT ON COLUMN &VIEW_SU_QRY..identity
   IS 'FLAGS=PM---^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Identity^';
COMMENT ON COLUMN &VIEW_SU_QRY..party_type
   IS 'FLAGS=KM--L^DATATYPE=STRING(200)^PROMPT=Party Type^REF=PartyType^';
COMMENT ON COLUMN &VIEW_SU_QRY..party_type_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Party Type^';
COMMENT ON COLUMN &VIEW_SU_QRY..name
   IS 'FLAGS=AM--L^DATATYPE=STRING(100)^PROMPT=Supplier Name^';
COMMENT ON COLUMN &VIEW_SU_QRY..balance
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Balance^';
COMMENT ON COLUMN &VIEW_SU_QRY..adv_inv_balance
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Adv Inv Balance^';
COMMENT ON COLUMN &VIEW_SU_QRY..amount_due
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Amount Due^';
COMMENT ON COLUMN &VIEW_SU_QRY..pre_payment_balance
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Open Pre-Payments^';
COMMENT ON COLUMN &VIEW_SU_QRY..balance_excl_withheld
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Balance Excl Withheld^';
COMMENT ON COLUMN &VIEW_SU_QRY..other_party_type_exists
   IS 'FLAGS=AM--L^DATATYPE=BOOLEAN^PROMPT=Other Party Type Exist^';
COMMENT ON COLUMN &VIEW_SU_QRY..is_note
   IS 'FLAGS=AM--L^DATATYPE=BOOLEAN^PROMPT=Notes^';
COMMENT ON COLUMN &VIEW_SU_QRY..group_id
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Group ID^';
-- Bug 77136, end

-- Bug 77136, begin, Table join with customer_info_tab, in order to get name and association no directly.
-- Bug 69035, Begin, Added reminder_template_id,interest_template_id and their descriptions to VIEW_CU_QRY  
PROMPT Creating &VIEW_CU_QRY view
CREATE OR REPLACE FORCE VIEW &VIEW_CU_QRY AS
SELECT p.company                                                           company,
       p.identity                                                          identity,
       Party_Type_API.Decode(p.party_type)                                 party_type,
       p.party_type                                                        party_type_db,
       ci.name                                                             name,
       ci.association_no                                                   association_no,
       NVL(Ledger_Item_Util_API.Get_Dom_Balance(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type),
                                Company_Pay_Info_API.Get_Query_Voucher_Date), 0)
                                                                           balance,
       NVL(Ledger_Item_Util_API.Get_Dom_Balance(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type),
                                Company_Pay_Info_API.Get_Query_Voucher_Date,
                                'TRUE'), 0)                                pay_doc_balance,
       NVL(Ledger_Item_Util_API.Get_Adv_Inv_Dom_Balance(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type)), 0)   adv_inv_balance,
       NVL(Ledger_Item_Util_API.Get_Dom_Amount_Due(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type),
                                Company_Pay_Info_API.Get_Query_Voucher_Date), 0)
                                                                           amount_due,
       NVL(Ledger_Item_Util_API.Get_Dom_Amount_Due(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type),
                                Company_Pay_Info_API.Get_Query_Voucher_Date,
                                'TRUE'), 0)                                pay_doc_amount_due,
       NVL(Ledger_Item_Util_API.Get_Dom_Pre_Payment_Balance(
                                p.company,
                                p.identity,
                                Party_Type_API.Decode(p.party_type),
                                Company_Pay_Info_API.Get_Query_Voucher_Date), 0)
                                                                           pre_payment_balance,
       'FALSE'                                                             other_party_type_exists,
       Identity_Note_API.Check_Note_Exist(p.company,
                                          p.identity,
                                          p.party_type)                    is_note,
       i.group_id                                                          group_id,
       cci.credit_analyst_code                                             ca_code,
       Credit_Analyst_API.Get_Description(p.company,
                                          cci.credit_analyst_code )        ca_desc,
       Credit_Analyst_API.Get_Manager(p.company,
                                      cci.credit_analyst_code)             ca_manager,
       Credit_Analyst_API.Get_Manager_Description(p.company,
                                                  cci.credit_analyst_code) manager_desc,
       cci.corp_credit_relation_exist                                      credit_relation_exist,
       cci.credit_relationship_type                                        credit_relation_type,
       cci.parent_company                                                  parent_company,
       cci.parent_identity                                                 parent_party,
       Customer_Info_API.Get_Name(cci.parent_identity)                     parent_name,
       Customer_Info_Vat_API.Get_Tax_Withholding(p.identity,
               Customer_Info_Address_API.Get_Default_Address(p.identity,
                 Address_Type_Code_API.Decode('DELIVERY')), p.company)     tax_withholding,
       p.reminder_template                                                 reminder_template_id,
       Reminder_Template_Api.Get_Template_Description(p.company ,
                                                      p.reminder_template) reminder_template_des,
       p.interest_template                                                 interest_template_id,
       Interest_Template_API.Get_Template_Description(p.company,
                                                      p.interest_template) interest_template_des,
       &OBJID_p                                                            objid,
       &OBJVERSION_p                                                       objversion
FROM   identity_pay_info_tab     p,
       identity_invoice_info_tab i,
       customer_credit_info_tab  cci,
       customer_info_tab         ci
WHERE  EXISTS (SELECT * FROM company_finance_auth1 c WHERE p.company = c.company)
AND    p.party_type = 'CUSTOMER'
AND    p.company    = cci.company(+)
AND    p.identity   = cci.identity(+)
AND    p.company    = i.company
AND    p.identity   = i.identity
AND    p.party_type = i.party_type
AND    p.identity   = ci.customer_id
WITH   read only;

COMMENT ON TABLE &VIEW_CU_QRY
   IS 'LU=&LU^PROMPT=Identity Pay Info^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW_CU_QRY..company
   IS 'FLAGS=PM---^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Company^REF=Company/NOCHECK^';
COMMENT ON COLUMN &VIEW_CU_QRY..identity
   IS 'FLAGS=PM---^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Identity^';
COMMENT ON COLUMN &VIEW_CU_QRY..party_type
   IS 'FLAGS=KM--L^DATATYPE=STRING(200)^PROMPT=Party Type^REF=PartyType^';
COMMENT ON COLUMN &VIEW_CU_QRY..party_type_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Party Type^';
COMMENT ON COLUMN &VIEW_CU_QRY..name
   IS 'FLAGS=AM--L^DATATYPE=STRING(100)^PROMPT=Customer Name^';
COMMENT ON COLUMN &VIEW_CU_QRY..balance
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Balance^';
COMMENT ON COLUMN &VIEW_CU_QRY..adv_inv_balance
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Adv Inv Balance^';
COMMENT ON COLUMN &VIEW_CU_QRY..amount_due
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Amount Due^';
COMMENT ON COLUMN &VIEW_CU_QRY..pre_payment_balance
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Open Pre-Payments^';
COMMENT ON COLUMN &VIEW_CU_QRY..other_party_type_exists
   IS 'FLAGS=AM--L^DATATYPE=BOOLEAN^PROMPT=Other Party Type Exist^';
COMMENT ON COLUMN &VIEW_CU_QRY..is_note
   IS 'FLAGS=AM--L^DATATYPE=BOOLEAN^PROMPT=Notes^';
COMMENT ON COLUMN &VIEW_CU_QRY..group_id
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Group ID^';
COMMENT ON COLUMN &VIEW_CU_QRY..ca_code
   IS 'FLAGS=A---L^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Credit Analyst Code^';
COMMENT ON COLUMN &VIEW_CU_QRY..ca_desc
   IS 'FLAGS=A---L^DATATYPE=STRING(100)^PROMPT=Credit Analyst Description^';
COMMENT ON COLUMN &VIEW_CU_QRY..ca_manager
   IS 'FLAGS=A---L^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Credit Analyst Manager^';
COMMENT ON COLUMN &VIEW_CU_QRY..manager_desc
   IS 'FLAGS=A---L^DATATYPE=STRING(100)^PROMPT=Manager Description^';
COMMENT ON COLUMN &VIEW_CU_QRY..credit_relation_exist
   IS 'FLAGS=A---L^DATATYPE=BOOLEAN^PROMPT=Credit Relation Exist^';
COMMENT ON COLUMN &VIEW_CU_QRY..credit_relation_type
   IS 'FLAGS=A---L^DATATYPE=STRING(100)^PROMPT=Credit Relation Type^';
COMMENT ON COLUMN &VIEW_CU_QRY..parent_company
   IS 'FLAGS=A---L^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Parent Company^';
COMMENT ON COLUMN &VIEW_CU_QRY..parent_party
   IS 'FLAGS=A---L^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Parent Party^';
COMMENT ON COLUMN &VIEW_CU_QRY..parent_name
   IS 'FLAGS=A---L^DATATYPE=STRING(100)^PROMPT=Parent Name^';
COMMENT ON COLUMN &VIEW_CU_QRY..tax_withholding
   IS 'FLAGS=A---L^DATATYPE=STRING(20)^PROMPT=Tax Withholding^';
COMMENT ON COLUMN &VIEW_CU_QRY..reminder_template_id
   IS 'FLAGS=A---L^DATATYPE=STRING(20)^PROMPT=Reminder Template Id^';
COMMENT ON COLUMN &VIEW_CU_QRY..reminder_template_des
   IS 'FLAGS=A---L^DATATYPE=STRING(200)^PROMPT=Reminder Template Description^';
COMMENT ON COLUMN &VIEW_CU_QRY..interest_template_id
   IS 'FLAGS=A---L^DATATYPE=STRING(20)^PROMPT=Interest Template Id^';
COMMENT ON COLUMN &VIEW_CU_QRY..interest_template_des
   IS 'FLAGS=A---L^DATATYPE=STRING(200)^PROMPT=Interest Template Description^';
-- Bug 69035, End;
-- Bug 77136, end

PROMPT Creating &VIEW_SUPP view

-- Bug 68653, Begin, Added new columns address and city
CREATE OR REPLACE FORCE VIEW &VIEW_SUPP AS
SELECT ipi.company                      company,
       identity                       identity,
       Supplier_Info_API.Get_Name(identity)   party_name,
       Supplier_Info_Address_API.Get_City(identity,
                                                Supplier_Info_Address_API.Get_Default_Address(identity,
                                                               Address_Type_Code_API.Decode('PAY')))      city,
       RTRIM(Supplier_Info_Address_API.Get_Address1(identity,
                                                Supplier_Info_Address_API.Get_Default_Address(identity,
                                                               Address_Type_Code_API.Decode('PAY')))||','||
                                                Supplier_Info_Address_API.Get_Address2(identity,
                                                Supplier_Info_Address_API.Get_Default_Address(identity,
                                                               Address_Type_Code_API.Decode('PAY'))),',') address,
       priority                       priority,
       blocked_for_payment            blocked_for_payment,
       other_payee_identity           other_payee_identity,
       Payment_Advice_API.Decode(payment_advice) payment_advice,
       ipi.&OBJID                     objid,
       &OBJVERSION                    objversion
FROM   identity_pay_info_tab ipi
WHERE  EXISTS (SELECT * FROM company_finance_auth1 c WHERE ipi.company = c.company)
AND    party_type = 'SUPPLIER'
WITH   read only;

COMMENT ON TABLE &VIEW_SUPP
   IS 'LU=&LU^PROMPT=Supplier Pay Info^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW_SUPP..company
   IS 'FLAGS=PMI--^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Company^REF=Company/NOCHECK^';
COMMENT ON COLUMN &VIEW_SUPP..identity
   IS 'FLAGS=KMI-L^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Supplier Id^REF=SupplierInfo/CUSTOM=(Check_Cascade_Supplier__,Cascade_Delete_Supplier__)^';
COMMENT ON COLUMN &VIEW_SUPP..party_name
   IS 'FLAGS=AMI-L^DATATYPE=STRING(100)^PROMPT=Supplier Name^';
COMMENT ON COLUMN &VIEW_SUPP..city
   IS 'FLAGS=A---L^DATATYPE=STRING(35)^PROMPT=City^';
COMMENT ON COLUMN &VIEW_SUPP..address
   IS 'FLAGS=A---L^DATATYPE=STRING(2000)^PROMPT=Address^';
COMMENT ON COLUMN &VIEW_SUPP..priority
   IS 'FLAGS=A-IUL^DATATYPE=NUMBER^PROMPT=Priority^';
COMMENT ON COLUMN &VIEW_SUPP..blocked_for_payment
   IS 'FLAGS=A-IUL^DATATYPE=BOOLEAN^PROMPT=Blocked For Payment^';
COMMENT ON COLUMN &VIEW_SUPP..other_payee_identity
   IS 'FLAGS=A-IUL^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Other Payee^';
COMMENT ON COLUMN &VIEW_SUPP..payment_advice
   IS 'FLAGS=A-IU-^DATATYPE=STRING(200)^PROMPT=Payment Advice^REF=PaymentAdvice^';
-- Bug 68653, End


PROMPT Creating &VIEW_CUST view

-- Bug 68653, Begin, Added new columns address and city
CREATE OR REPLACE FORCE VIEW &VIEW_CUST AS
SELECT ipi.company                   company,
       identity                    identity,
       Customer_Info_API.Get_Name(identity)   party_name,
       Customer_Info_Address_API.Get_City(identity,
                                               Customer_Info_Address_API.Get_Default_Address(identity,
                                                                  Address_Type_Code_API.Decode('PAY')))     city,
       RTRIM(Customer_Info_Address_API.Get_Address1(identity,
                                               Customer_Info_Address_API.Get_Default_Address(identity,
                                                                  Address_Type_Code_API.Decode('PAY')))||','||
                                               Customer_Info_Address_API.Get_Address2(identity,
                                               Customer_Info_Address_API.Get_Default_Address(identity,
                                                                 Address_Type_Code_API.Decode('PAY'))),',') address,
       interest_template           interest_template,
       reminder_template           reminder_template,
       Payment_Advice_API.Decode(payment_advice) payment_advice,
       ipi.&OBJID                  objid,
       &OBJVERSION                 objversion
FROM   identity_pay_info_tab ipi
WHERE  EXISTS (SELECT * FROM company_finance_auth1 c WHERE ipi.company = c.company)
AND    party_type = 'CUSTOMER'
WITH   read only;

COMMENT ON TABLE &VIEW_CUST
   IS 'LU=&LU^PROMPT=Customer Pay Info^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW_CUST..company
   IS 'FLAGS=PMI--^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Company^REF=Company/NOCHECK^';
COMMENT ON COLUMN &VIEW_CUST..identity
   IS 'FLAGS=KMI-L^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Customer Id^REF=CustomerInfo/CUSTOM=(Check_Cascade_Customer__,Cascade_Delete_Customer__)^';
COMMENT ON COLUMN &VIEW_CUST..party_name
   IS 'FLAGS=AMI-L^DATATYPE=STRING(100)^PROMPT=Customer Name^';
COMMENT ON COLUMN &VIEW_CUST..city
   IS 'FLAGS=A---L^DATATYPE=STRING(35)^PROMPT=City^';
COMMENT ON COLUMN &VIEW_CUST..address
   IS 'FLAGS=A---L^DATATYPE=STRING(2000)^PROMPT=Address^';
COMMENT ON COLUMN &VIEW_CUST..interest_template
   IS 'FLAGS=A-IUL^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Interest Template^REF=InterestTemplate(company)/NOCHECK^';
COMMENT ON COLUMN &VIEW_CUST..reminder_template
   IS 'FLAGS=A-IUL^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Reminder Template^REF=ReminderTemplate(company)/NOCHECK^';
COMMENT ON COLUMN &VIEW_CUST..payment_advice
   IS 'FLAGS=A-IU-^DATATYPE=STRING(200)^PROMPT=Payment Advice^REF=PaymentAdvice^';
-- Bug 68653, End

PROMPT Creating &VIEW_LOV view

-- Bug 68653, Begin, Added new columns address and city
CREATE OR REPLACE FORCE VIEW &VIEW_LOV AS
SELECT ipi.company                   company,
       party_type                  party_type_db,
       identity                    identity,
       Payment_Library_API.Get_Identity_Name(ipi.company,
                                             identity,
                                             Party_Type_API.Decode(party_type)) party_name,
       Payment_Library_API.Get_City(ipi.company,
                                    identity,
                                    party_type)    city,
       Payment_Library_API.Get_Address(ipi.company,
                                       identity,
                                       party_type) address,
       ipi.&OBJID                  objid,
       &OBJVERSION                 objversion
FROM   identity_pay_info_tab ipi
WHERE  EXISTS (SELECT * FROM company_finance_auth1 c WHERE ipi.company = c.company)
WITH   read only;

COMMENT ON TABLE &VIEW_LOV
   IS 'LU=&LU^PROMPT=Customer/Supplier Pay Info^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW_LOV..company
   IS 'FLAGS=PMI--^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Company^REF=Company/NOCHECK^';
COMMENT ON COLUMN &VIEW_LOV..party_type_db
   IS 'FLAGS=PMI--^DATATYPE=STRING(20)^PROMPT=Party Type^';
COMMENT ON COLUMN &VIEW_LOV..identity
   IS 'FLAGS=KMI-L^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Identity^';
COMMENT ON COLUMN &VIEW_LOV..party_name
   IS 'FLAGS=AMI-L^DATATYPE=STRING(100)^PROMPT=Name^';
COMMENT ON COLUMN &VIEW_LOV..city
   IS 'FLAGS=A---L^DATATYPE=STRING(35)^PROMPT=City^';
COMMENT ON COLUMN &VIEW_LOV..address
   IS 'FLAGS=A---L^DATATYPE=STRING(2000)^PROMPT=Address^';
-- Bug 68653, End


PROMPT Creating &VIEW_ALL view

CREATE OR REPLACE FORCE VIEW &VIEW_ALL AS
SELECT ipi.company                 company,
       identity                    identity,
       Party_Type_API.Decode(party_type) party_type,
       Payment_Library_API.Get_Identity_Name(ipi.company,
                                             identity,
                                             Party_Type_API.Decode(party_type)) party_name,
       ipi.&OBJID                  objid,
       &OBJVERSION                 objversion
FROM   identity_pay_info_tab ipi
WHERE  EXISTS (SELECT * FROM company_finance_auth1 c WHERE ipi.company = c.company)
WITH   read only;

COMMENT ON TABLE &VIEW_ALL
   IS 'LU=&LU^PROMPT=Identity Pay Info^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW_ALL..company
   IS 'FLAGS=PMI--^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Company^REF=Company/NOCHECK^';
COMMENT ON COLUMN &VIEW_ALL..identity
   IS 'FLAGS=KMI-L^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Identity^';
COMMENT ON COLUMN &VIEW_ALL..party_type
   IS 'FLAGS=AMI-L^DATATYPE=STRING(200)^PROMPT=Party Type^REF=PartyType';
COMMENT ON COLUMN &VIEW_ALL..party_name
   IS 'FLAGS=AMI-L^DATATYPE=STRING(100)^PROMPT=Name^';

PROMPT Creating &VIEWPCT view

CREATE OR REPLACE FORCE VIEW &VIEWPCT AS
SELECT company                        company,
       identity                       identity,
       party_type                     party_type_db,
       priority                       priority,
       blocked_for_payment            blocked_for_payment,
       other_payee_identity           other_payee_identity,
       interest_template              interest_template,
       reminder_template              reminder_template,
       payment_delay                  payment_delay,
       amount_tolerance               amount_tolerance,
       percent_tolerance              percent_tolerance,
       disc_days_tolerance            disc_days_tolerance,
       netting_allowed                netting_allowed,
       format_no                      format_no,
       payment_advice                 payment_advice_db,
       deduction_group                deduction_group,
       corporation_id                 corporation_id,
       member_id                      member_id,
       send_reminder_to_payer         send_reminder_to_payer,
       send_interest_inv_to_payer     send_interest_inv_to_payer,
       payment_receipt_type           payment_receipt_type_db,
       send_statement_of_acc_to_payer send_statement_of_acc_to_payer
FROM   identity_pay_info_tab
WITH   read only;

COMMENT ON TABLE &VIEWPCT
   IS 'LU=&LU^PROMPT=Identity Pay Info^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEWPCT..company
   IS 'FLAGS=PMI--^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Company^REF=CompanyPayInfo/NOCHECK^';
COMMENT ON COLUMN &VIEWPCT..identity
   IS 'FLAGS=KMI--^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Identity^';
COMMENT ON COLUMN &VIEWPCT..party_type_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Party Type^';
COMMENT ON COLUMN &VIEWPCT..priority
   IS 'FLAGS=A-IUL^DATATYPE=NUMBER^PROMPT=Priority^';
COMMENT ON COLUMN &VIEWPCT..blocked_for_payment
   IS 'FLAGS=A-IUL^DATATYPE=BOOLEAN^PROMPT=Blocked For Payment^';
COMMENT ON COLUMN &VIEWPCT..other_payee_identity
   IS 'FLAGS=A-IUL^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Other Payee Identity^REF=IdentityPayInfo(company)/NOCHECK^';
COMMENT ON COLUMN &VIEWPCT..interest_template
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Interest Template^REF=InterestTemplate(company)/NOCHECK^';
COMMENT ON COLUMN &VIEWPCT..reminder_template
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Reminder Template^REF=ReminderTemplate(company)/NOCHECK^';
COMMENT ON COLUMN &VIEWPCT..payment_delay
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Number of Days Usual Payment Delay^';
COMMENT ON COLUMN &VIEWPCT..amount_tolerance
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Amount Tolerance^';
COMMENT ON COLUMN &VIEWPCT..percent_tolerance
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Percent Tolerance^';
COMMENT ON COLUMN &VIEWPCT..disc_days_tolerance
   IS 'FLAGS=A-IU-^DATATYPE=NUMBER^PROMPT=Tolerance Days for Discount^';
COMMENT ON COLUMN &VIEWPCT..netting_allowed
   IS 'FLAGS=AMIUL^DATATYPE=BOOLEAN^PROMPT=Netting Allowed^';
COMMENT ON COLUMN &VIEWPCT..format_no
   IS 'FLAGS=AMI--^DATATYPE=NUMBER^PROMPT=Format No^';
COMMENT ON COLUMN &VIEWPCT..payment_advice_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Payment Advice^';
COMMENT ON COLUMN &VIEWPCT..deduction_group
   IS 'FLAGS=A-IUL^DATATYPE=STRING(20)^PROMPT=Deduction Group^REF=DeductionGroup/NOCHECK^';
COMMENT ON COLUMN &VIEWPCT..corporation_id
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)^PROMPT=Corporation Id^';
COMMENT ON COLUMN &VIEWPCT..member_id
   IS 'FLAGS=A-IU-^DATATYPE=STRING(20)^PROMPT=Member Id^';
COMMENT ON COLUMN &VIEWPCT..send_reminder_to_payer
   IS 'FLAGS=A-IU-^DATATYPE=STRING(5)^PROMPT=Send Reminder To Payer^';
COMMENT ON COLUMN &VIEWPCT..send_interest_inv_to_payer
   IS 'FLAGS=A-IU-^DATATYPE=STRING(5)^PROMPT=Send Interest Inv To Payer^';
COMMENT ON COLUMN &VIEWPCT..payment_receipt_type_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Payment Receipt^';
COMMENT ON COLUMN &VIEWPCT..send_statement_of_acc_to_payer                        
   IS 'FLAGS=A-IU-^DATATYPE=STRING(5)^PROMPT=Send Statement Of Account To Payer^';


PROMPT Creating &VIEW_PAYER_QRY view
-- Bug 69035, Begin, Added reminder_template_id,interest_template_id and their descriptions   
CREATE OR REPLACE FORCE VIEW &VIEW_PAYER_QRY AS
SELECT p.company                      company,
       identity                       identity,
       Party_Type_API.Decode(party_type)  party_type,                              
       party_type                     party_type_db,
       Customer_Info_API.Get_Name(identity)  name,                              
       NVL(Ledger_Item_Util_API.Get_Payer_Dom_Balance(
                                p.company,
                                identity,
                                Party_Type_API.Decode(party_type)), 0)
                                      balance,
       NVL(Ledger_Item_Util_API.Get_Payer_Adv_Inv_Dom_Balance(
                                p.company,
                                identity,
                                Party_Type_API.Decode(party_type)), 0)
                                      payer_adv_inv_balance,
       NVL(Ledger_Item_Util_API.Get_Payer_Dom_Bal_of_other_cus(
                                p.company,
                                identity,
                                Party_Type_API.Decode(party_type)), 0)
                                      other_cust_bal,
       NVL(Ledger_Item_Util_API.Get_Payer_Dom_Amount_Due(
                                p.company,
                                identity,
                                Party_Type_API.Decode(party_type)), 0)
                                      amount_due,
       NVL(Ledger_Item_Util_API.Get_Payer_Dom_Pre_Pay_Bal(
                                p.company,
                                identity,
                                Party_Type_API.Decode(party_type)), 0)
                                      pre_payment_balance,
       Identity_Note_API.Check_Note_Exist(p.company,
                                          p.identity,
                                          p.party_type)
                                      is_note,
       p.reminder_template            reminder_template_id,
       Reminder_Template_Api.Get_Template_Description(p.company ,
                                                      p.reminder_template) 
                                      reminder_template_des,
       p.interest_template            interest_template_id,
       Interest_Template_API.Get_Template_Description(p.company,
                                                      p.interest_template) 
                                      interest_template_des,
       p.&OBJID                       objid,
       &OBJVERSION                    objversion
FROM   identity_pay_info_tab p
WHERE  EXISTS (SELECT * FROM company_finance_auth1 c WHERE p.company = c.company)
AND    party_type = 'CUSTOMER'
WITH   read only;

COMMENT ON TABLE &VIEW_PAYER_QRY
   IS 'LU=&LU^PROMPT=Identity Pay Info^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW_PAYER_QRY..company
   IS 'FLAGS=PM---^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Company^REF=Company/NOCHECK^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..identity
   IS 'FLAGS=PM---^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Payer^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..party_type
   IS 'FLAGS=KM--L^DATATYPE=STRING(200)^PROMPT=Party Type^REF=PartyType^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..party_type_db
   IS 'FLAGS=A----^DATATYPE=STRING(20)^PROMPT=Party Type^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..name
   IS 'FLAGS=AM--L^DATATYPE=STRING(100)^PROMPT=Name^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..balance
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Payer Balance^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..payer_adv_inv_balance
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Payer Adv Inv Balance^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..other_cust_bal
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Other Customres Balance^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..amount_due
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Amount Due^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..pre_payment_balance
   IS 'FLAGS=AM--L^DATATYPE=NUMBER^PROMPT=Open Pre-Payments^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..is_note
   IS 'FLAGS=AM--L^DATATYPE=BOOLEAN^PROMPT=Notes^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..reminder_template_id
   IS 'FLAGS=AM--L^DATATYPE=STRING(20)^PROMPT=Reminder Template Id^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..reminder_template_des
   IS 'FLAGS=AM--L^DATATYPE=STRING(200)^PROMPT=Reminder Template Description^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..interest_template_id
   IS 'FLAGS=AM--L^DATATYPE=STRING(20)^PROMPT=Interest Template Id^';
COMMENT ON COLUMN &VIEW_PAYER_QRY..interest_template_des
   IS 'FLAGS=AM--L^DATATYPE=STRING(200)^PROMPT=Interest Template Description^';
-- Bug 69035, End

PROMPT Creating &VIEW_MULTI_CUS view

CREATE OR REPLACE FORCE VIEW &VIEW_MULTI_CUS AS
SELECT c.customer_id                                 customer_id,
       c.name                                        name,
       c.association_no                              association_no,
       c.customer_id                                 identity,
       c.party_type                                  party_type_db, 
       c.rowid                                       objid,
       LTRIM(LPAD(TO_CHAR(c.rowversion),2000))       objversion
FROM   customer_info_tab  c
WHERE  EXISTS
   (SELECT 1
    FROM   identity_pay_info_tab     p,
           identity_invoice_info_tab i
    WHERE  p.identity   = c.customer_id
    AND    p.party_type = 'CUSTOMER'
    AND EXISTS
        (SELECT * FROM company_finance_auth1 a WHERE p.company = a.company)
    AND    i.company    = p.company
    AND    i.identity   = p.identity
    AND    i.party_type = p.party_type)
WITH read only;

COMMENT ON TABLE &VIEW_MULTI_CUS
   IS 'LU=&LU^PROMPT=Invoice Ledger Item^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW_MULTI_CUS..customer_id
   IS 'FLAGS=KMI-L^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Customer Id^';
COMMENT ON COLUMN &VIEW_MULTI_CUS..name
   IS 'FLAGS=AMIUL^DATATYPE=STRING(100)^PROMPT=Name^';
COMMENT ON COLUMN &VIEW_MULTI_CUS..association_no
   IS 'FLAGS=A-IUL^DATATYPE=STRING(50)^PROMPT=Association No^';
COMMENT ON COLUMN &VIEW_MULTI_CUS..identity
   IS 'FLAGS=A-IUL^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Identity^';   
COMMENT ON COLUMN &VIEW_MULTI_CUS..party_type_db
   IS 'FLAGS=A-IUL^DATATYPE=STRING(20)^PROMPT=Party Type^';
   

PROMPT Creating &VIEW_MULTI_SUP VIEW

CREATE OR REPLACE FORCE VIEW &VIEW_MULTI_SUP AS
SELECT s.supplier_id                                   supplier_id,
       s.name                                          name,
       s.association_no                                association_no,
       s.suppliers_own_id                              suppliers_own_id,
       s.rowid                                         objid,
       LTRIM(LPAD(TO_CHAR(s.rowversion),2000))         objversion
FROM   supplier_info_tab s
WHERE  EXISTS
   (SELECT 1
    FROM   identity_pay_info_tab     p,
           identity_invoice_info_tab i
    WHERE  p.identity   = s.supplier_id
    AND    p.party_type = 'SUPPLIER'
    AND EXISTS
       (SELECT * FROM company_finance_auth1 a WHERE p.company = a.company)
    AND    i.company    = p.company
    AND    i.identity   = p.identity
    AND    i.party_type = p.party_type)
WITH read only;

COMMENT ON TABLE &VIEW_MULTI_SUP
   IS 'LU=&LU^PROMPT=Invoice Ledger Item^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW_MULTI_SUP..supplier_id
   IS 'FLAGS=KMI-L^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Supplier Id^';
COMMENT ON COLUMN &VIEW_MULTI_SUP..name
   IS 'FLAGS=AMIUL^DATATYPE=STRING(100)^PROMPT=Name^';
COMMENT ON COLUMN &VIEW_MULTI_SUP..association_no
   IS 'FLAGS=A-IUL^DATATYPE=STRING(50)^PROMPT=Association No^';
COMMENT ON COLUMN &VIEW_MULTI_SUP..suppliers_own_id
   IS 'FLAGS=A-IUL^DATATYPE=STRING(20)^PROMPT=Suppliers Own Id^';


PROMPT Creating &VIEW_MULTI_ADD VIEW
CREATE OR REPLACE FORCE VIEW &VIEW_MULTI_ADD AS
SELECT s.supplier_id                    supplier_id,
       s.address_id                     address_id,
       s.valid_from                     valid_from,
       s.valid_to                       valid_to
FROM  supplier_info_address_tab s
WHERE  EXISTS
   (SELECT 1
    FROM   identity_pay_info_tab     p,
           identity_invoice_info_tab i
    WHERE  p.identity   = s.supplier_id
    AND    p.party_type = 'SUPPLIER'
    AND EXISTS
       (SELECT * FROM company_finance_auth1 a WHERE p.company = a.company)
    AND    i.company    = p.company
    AND    i.identity   = p.identity
    AND    i.party_type = p.party_type)
WITH read only;

COMMENT ON TABLE &VIEW_MULTI_ADD
   IS 'LU=&LU^PROMPT=Invoice Ledger Item^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW_MULTI_ADD..supplier_id
   IS 'FLAGS=PMI-L^DATATYPE=STRING(20)/UPPERCASE^PROMPT=Supplier Id^';
COMMENT ON COLUMN &VIEW_MULTI_ADD..address_id
   IS 'FLAGS=KMI-L^DATATYPE=STRING(50)/UPPERCASE^PROMPT=Address Id^';
COMMENT ON COLUMN &VIEW_MULTI_ADD..valid_from
   IS 'FLAGS=A-IUL^DATATYPE=DATE/DATE^PROMPT=Valid From^';
COMMENT ON COLUMN &VIEW_MULTI_ADD..valid_to
   IS 'FLAGS=A-IUL^DATATYPE=DATE/DATE^PROMPT=Valid To^';

-----------------------------------------------------------------------------
-------------------- PACKAGES FOR METHODS -----------------------------------
-----------------------------------------------------------------------------

PROMPT Creating &PKG implementation

CREATE OR REPLACE PACKAGE BODY &PKG IS

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC IMPLEMENTATION METHOD DECLARATIONS ---------
-----------------------------------------------------------------------------
PROCEDURE Save_Identity_Notes___ (
   attr_       IN VARCHAR2,
   newrec_     IN &TABLE%ROWTYPE );

FUNCTION Get_Next_Format_No___ (
   company_       IN VARCHAR2 ) RETURN NUMBER;

PROCEDURE Check_Cascade___ (
   company_       IN VARCHAR2,
   identity_      IN VARCHAR2,
   party_type_db_ IN VARCHAR2 );

PROCEDURE Import___ (
   crecomp_rec_ IN ENTERP_COMP_CONNECT_V160_API.Crecomp_Lu_Public_Rec );

PROCEDURE Copy___ (
   crecomp_rec_   IN ENTERP_COMP_CONNECT_V160_API.Crecomp_Lu_Public_Rec );

PROCEDURE Export___ (
   crecomp_rec_   IN ENTERP_COMP_CONNECT_V160_API.Crecomp_Lu_Public_Rec );

PROCEDURE User_Allowed___(
   company_   IN VARCHAR2);





-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION BASE METHODS ----------------------------
-----------------------------------------------------------------------------
-- Lock_By_Id___
--    Client-support to lock a specific instance of the logical unit.
--
-- Lock_By_Keys___
--    Server support to lock a specific instance of the logical unit.
--
-- Get_Object_By_Id___
--    Get LU-record from the database with a specified object identity.
--
-- Get_Object_By_Keys___
--    Get LU-record from the database with specified key columns.
--
-- Check_Exist___
--    Check if a specific LU-instance already exist in the database.
--
-- Get_Id_Version_By_Keys___
--    Get the current OBJID and OBJVERSION for a specific LU-instance.
-----------------------------------------------------------------------------

FUNCTION Lock_By_Id___ (
   objid_      IN VARCHAR2,
   objversion_ IN VARCHAR2 ) RETURN &TABLE%ROWTYPE
IS
   row_changed EXCEPTION;
   row_deleted EXCEPTION;
   row_locked  EXCEPTION;
   PRAGMA      exception_init(row_locked, -0054);
   rec_        &TABLE%ROWTYPE;
   dummy_      NUMBER;
   CURSOR lock_control IS
      SELECT *
      FROM   &TABLE
      WHERE  &OBJID = objid_
      AND    &OBJVERSION = objversion_
      FOR UPDATE NOWAIT;
   CURSOR exist_control IS
      SELECT 1
      FROM   &TABLE
      WHERE  &OBJID = objid_;
BEGIN
   OPEN lock_control;
   FETCH lock_control INTO rec_;
   IF (lock_control%FOUND) THEN
      CLOSE lock_control;
      RETURN rec_;
   END IF;
   CLOSE lock_control;
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RAISE row_changed;
   ELSE
      CLOSE exist_control;
      RAISE row_deleted;
   END IF;
EXCEPTION
   WHEN row_locked THEN
      Error_SYS.Record_Locked(lu_name_);
   WHEN row_changed THEN
      Error_SYS.Record_Modified(lu_name_);
   WHEN row_deleted THEN
      Error_SYS.Record_Removed(lu_name_);
END Lock_By_Id___;

FUNCTION Lock_By_Keys___ (
   company_       IN VARCHAR2,
   identity_      IN VARCHAR2,
   party_type_db_ IN VARCHAR2 ) RETURN &TABLE%ROWTYPE
IS
   row_deleted EXCEPTION;
   rec_        &TABLE%ROWTYPE;
   CURSOR lock_control IS
      SELECT *
      FROM  &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_
      FOR UPDATE;
BEGIN
   OPEN lock_control;
   FETCH lock_control INTO rec_;
   IF (lock_control%FOUND) THEN
      CLOSE lock_control;
      RETURN rec_;
   ELSE
      CLOSE lock_control;
      RAISE row_deleted;
   END IF;
EXCEPTION
   WHEN row_deleted THEN
      Error_SYS.Record_Removed(lu_name_);
END Lock_By_Keys___;

FUNCTION Get_Object_By_Id___ (
   objid_ IN VARCHAR2 ) RETURN &TABLE%ROWTYPE
IS
   lu_rec_ &TABLE%ROWTYPE;
   CURSOR getrec IS
      SELECT *
      FROM   &TABLE
      WHERE  &OBJID = objid_;
BEGIN
   OPEN getrec;
   FETCH getrec INTO lu_rec_;
   IF (getrec%NOTFOUND) THEN
      CLOSE getrec;
      Error_SYS.Record_Removed(lu_name_);
   END IF;
   CLOSE getrec;
   RETURN(lu_rec_);
END Get_Object_By_Id___;

FUNCTION Get_Object_By_Keys___ (
   company_       IN VARCHAR2,
   identity_      IN VARCHAR2,
   party_type_db_ IN VARCHAR2 ) RETURN &TABLE%ROWTYPE
IS
   lu_rec_ &TABLE%ROWTYPE;
   CURSOR getrec IS
      SELECT *
      FROM  &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   OPEN getrec;
   FETCH getrec INTO lu_rec_;
   CLOSE getrec;
   RETURN(lu_rec_);
END Get_Object_By_Keys___;

FUNCTION Check_Exist___ (
   company_       IN VARCHAR2,
   identity_      IN VARCHAR2,
   party_type_db_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   CURSOR exist_control IS
      SELECT 1
      FROM   &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN(TRUE);
   END IF;
   CLOSE exist_control;
   RETURN(FALSE);
END Check_Exist___;

PROCEDURE Get_Id_Version_By_Keys___ (
   objid_         IN OUT VARCHAR2,
   objversion_    IN OUT VARCHAR2,
   company_       IN     VARCHAR2,
   identity_      IN     VARCHAR2,
   party_type_db_ IN     VARCHAR2)
IS
   CURSOR get_version IS
      SELECT &OBJID, &OBJVERSION
      FROM  &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   OPEN get_version;
   FETCH get_version INTO objid_, objversion_;
   CLOSE get_version;
END Get_Id_Version_By_Keys___;

-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION BASE METHODS FOR INSERT -----------------
-----------------------------------------------------------------------------
-- Prepare_Insert___
--    Set all default values for a new instance (ON-NEW-RECORD) of this
--    logical unit by calling procedure Add_Attr.
--
-- Unpack_Check_Insert___
--    Unpack the attribute list, check all attributes from the client
--    and generate all default values before creation of the new object.
--
-- Insert___
--    Insert a new LU-instance into the database and return the values
--    for OBJID and OBJVERSION.
-----------------------------------------------------------------------------

PROCEDURE Prepare_Insert___ (
   attr_ IN OUT VARCHAR2 )
IS
   company_             &TABLE..company%TYPE;
   identity_            &TABLE..identity%TYPE;
   party_type_          &VIEW..party_type%TYPE;
   template_id_         &VIEW..template_id%TYPE;
BEGIN

   company_       := Client_SYS.Get_Item_Value('COMPANY',attr_);
   identity_      := Client_SYS.Get_Item_Value('IDENTITY',attr_);
   party_type_    := Client_SYS.Get_Item_Value('PARTY_TYPE',attr_);
   template_id_   := Confirmation_Stmnt_Templ_API.Get_Default_Template(company_);

   Client_SYS.Clear_Attr(attr_);

--          Default value 'No Advice'
   Client_SYS.Add_To_Attr('PAYMENT_ADVICE', PAYMENT_ADVICE_API.DECODE('1'),attr_);

   IF (party_type_ = Party_Type_API.Decode('CUSTOMER')) THEN
      Client_SYS.Add_To_Attr('REMINDER_TEMPLATE', Reminder_Template_API.Get_Default_Template(company_), attr_);
      Client_SYS.Add_To_Attr('SEND_REMINDER_TO_PAYER', 'FALSE', attr_);
      Client_SYS.Add_To_Attr('SEND_INTEREST_INV_TO_PAYER', 'FALSE', attr_);
      Client_SYS.Add_To_Attr('PAYMENT_RECEIPT_TYPE', Payment_Receipt_Type_API.Decode('NO_RECEIPT'), attr_);
   ELSIF (party_type_ = Party_Type_API.Decode('SUPPLIER') ) THEN
      Client_SYS.Add_To_Attr('BLOCKED_FOR_PAYMENT', 'FALSE', attr_);
      Client_SYS.Add_To_Attr('CHECK_RECIPIENT', Check_Recipient_API.Decode('PAYEE'), attr_);
   END IF;
   Client_SYS.Add_To_Attr('INTEREST_TEMPLATE', Interest_Template_API.Get_Default_Template(company_), attr_);
   Client_SYS.Add_To_Attr('NETTING_ALLOWED', 'FALSE', attr_);
   Client_SYS.Add_To_Attr('TEMPLATE_ID', template_id_, attr_);
   Client_SYS.Add_To_Attr('SEND_STATEMENT_OF_ACC_TO_PAYER', 'FALSE', attr_);
END Prepare_Insert___;


PROCEDURE Unpack_Check_Insert___ (
   attr_   IN OUT VARCHAR2,
   newrec_ IN OUT &TABLE%ROWTYPE )
IS
   ptr_   NUMBER;
   name_  VARCHAR2(30);
   value_ VARCHAR2(2000);
BEGIN
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
      IF (name_ = 'COMPANY') THEN
         newrec_.company := value_;
         Company_API.Exist(newrec_.company);
 	 User_Allowed___(newrec_.company);
      ELSIF (name_ = 'IDENTITY') THEN
         newrec_.identity := value_;
      ELSIF (name_ = 'PARTY_TYPE') THEN
         newrec_.party_type := Party_Type_API.Encode(value_);
         Payment_Library_API.Exist_In_Enterp(newrec_.company, newrec_.identity, value_);
         IF (newrec_.party_type <> 'COMPANY') THEN
            Identity_Invoice_Info_API.Exist(newrec_.company, newrec_.identity, value_);
         END IF;
      ELSIF (name_ = 'PARTY_TYPE_DB') THEN
         newrec_.party_type := value_;
         Payment_Library_API.Exist_In_Enterp(newrec_.company, newrec_.identity, Party_Type_API.Decode(newrec_.party_type));
         IF (newrec_.party_type <> Party_Type_API.Decode('COMPANY')) THEN
            Identity_Invoice_Info_API.Exist_Db(newrec_.company, newrec_.identity, value_);
         END IF;
      ELSIF (name_ = 'PRIORITY') THEN
         newrec_.priority := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'BLOCKED_FOR_PAYMENT') THEN
         newrec_.blocked_for_payment := value_;
         IF (value_ IS NOT NULL AND newrec_.blocked_for_payment NOT IN ('TRUE', 'FALSE')) THEN
            RAISE value_error;
         END IF;
      ELSIF (name_ = 'OTHER_PAYEE_IDENTITY') THEN
         newrec_.other_payee_identity := value_;
         IF (value_ IS NOT NULL) THEN
            Identity_Pay_Info_API.Exist(newrec_.company, newrec_.other_payee_identity, Party_Type_API.Decode(newrec_.party_type));
         END IF;
      ELSIF (name_ = 'INTEREST_TEMPLATE') THEN
         newrec_.interest_template := value_;
         IF (value_ IS NOT NULL) THEN
            Interest_Template_API.Exist(newrec_.company, newrec_.interest_template);
         END IF;
      ELSIF (name_ = 'REMINDER_TEMPLATE') THEN
         newrec_.reminder_template := value_;
         IF (value_ IS NOT NULL) THEN
            Reminder_Template_API.Exist(newrec_.company, newrec_.reminder_template);
         END IF;
      ELSIF (name_ = 'PAYMENT_DELAY') THEN
         newrec_.payment_delay := Client_SYS.Attr_Value_To_Number(value_);
         IF (TRUNC(newrec_.payment_delay) <> newrec_.payment_delay) THEN
            Error_SYS.Record_General(lu_name_, 'NOTWHOLENUM: A whole number must be specified for the payment delay.');
         END IF;
      ELSIF (name_ = 'AMOUNT_TOLERANCE') THEN
         newrec_.amount_tolerance := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'PERCENT_TOLERANCE') THEN
         newrec_.percent_tolerance := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'DISC_DAYS_TOLERANCE') THEN
         newrec_.disc_days_tolerance := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'NETTING_ALLOWED') THEN
         newrec_.netting_allowed := value_;
         IF (newrec_.netting_allowed NOT IN ('TRUE', 'FALSE')) THEN
            RAISE value_error;
         END IF;
      ELSIF (name_ = 'FORMAT_NO') THEN
         newrec_.format_no := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'PAYMENT_ADVICE') THEN
         newrec_.payment_advice := Payment_Advice_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Payment_Advice_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'PAYMENT_ADVICE_DB') THEN
         newrec_.payment_advice := value_;
         IF (value_ IS NOT NULL) THEN
            Payment_Advice_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'DEDUCTION_GROUP') THEN
         newrec_.deduction_group := value_;
         IF (value_ IS NOT NULL) THEN
            Deduction_Group_API.Exist(newrec_.company, newrec_.deduction_group);
         END IF;
      ELSIF (name_ = 'CORPORATION_ID') THEN
         newrec_.corporation_id := value_;
      ELSIF (name_ = 'MEMBER_ID') THEN
         newrec_.member_id := value_;
      ELSIF (name_ = 'SEND_REMINDER_TO_PAYER') THEN
         newrec_.send_reminder_to_payer := value_;
      ELSIF (name_ = 'SEND_INTEREST_INV_TO_PAYER') THEN
         newrec_.send_interest_inv_to_payer := value_;
      ELSIF (name_ = 'RULE_ID') THEN
         newrec_.rule_id := value_;
         IF (value_ IS NOT NULL) THEN
            Pay_Method_Rule_API.Exist(newrec_.company, newrec_.rule_id);
         END IF;
      ELSIF (name_ = 'PAYMENT_RECEIPT_TYPE') THEN
         newrec_.payment_receipt_type := Payment_Receipt_Type_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Payment_Receipt_Type_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'PAYMENT_RECEIPT_TYPE_DB') THEN
         newrec_.payment_receipt_type := value_;
         IF (value_ IS NOT NULL) THEN
            Payment_Receipt_Type_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'TEMPLATE_ID') THEN
         newrec_.template_id := value_;
         IF (value_ IS NOT NULL) THEN
            Confirmation_Stmnt_Templ_API.Exist(newrec_.company, newrec_.template_id);
         END IF;
      ELSIF (name_ = 'CHECK_RECIPIENT') THEN
         newrec_.check_recipient := Check_Recipient_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Check_Recipient_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'CHECK_RECIPIENT_DB') THEN
         newrec_.check_recipient := value_;
         IF (value_ IS NOT NULL) THEN
            Check_Recipient_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'SEND_STATEMENT_OF_ACC_TO_PAYER') THEN
         newrec_.send_statement_of_acc_to_payer := value_;
      ELSE
         Error_SYS.Item_Not_Exist(lu_name_, name_, value_);
      END IF;
   END LOOP;


   IF (newrec_.amount_tolerance < 0) OR (newrec_.percent_tolerance < 0) OR (newrec_.disc_days_tolerance < 0) THEN
      Error_SYS.Appl_General(lu_name_, 'NEGTOLERANCE: Tolerance should be positive value.');
   END IF;


   Client_SYS.Clear_Attr(attr_);

   Error_SYS.Check_Not_Null(lu_name_, 'COMPANY', newrec_.company);
   Error_SYS.Check_Not_Null(lu_name_, 'IDENTITY', newrec_.identity);
   Error_SYS.Check_Not_Null(lu_name_, 'PARTY_TYPE', newrec_.party_type);
   Error_SYS.Check_Not_Null(lu_name_, 'NETTING_ALLOWED', newrec_.netting_allowed);

   IF (newrec_.interest_template IS NULL) THEN
      newrec_.interest_template := Interest_Template_API.Get_Default_Template(newrec_.company);
   END IF;

   IF (newrec_.party_type = 'SUPPLIER') THEN
      Error_SYS.Check_Not_Null(lu_name_, 'PRIORITY', newrec_.priority);
      Error_SYS.Check_Not_Null(lu_name_, 'BLOCKED_FOR_PAYMENT', newrec_.blocked_for_payment);
      Error_SYS.Check_Not_Null(lu_name_, 'CHECK_RECIPIENT', newrec_.check_recipient);
   END IF;
   IF (newrec_.party_type = 'CUSTOMER') THEN
      Error_SYS.Check_Not_Null(lu_name_, 'INTEREST_TEMPLATE', newrec_.interest_template);
      Error_SYS.Check_Not_Null(lu_name_, 'REMINDER_TEMPLATE', newrec_.reminder_template);
      Error_SYS.Check_Not_Null(lu_name_, 'PAYMENT_RECEIPT_TYPE', newrec_.payment_receipt_type);
      IF Company_Invoice_Info_API.Get_Use_Tax_Invoice(newrec_.company)='TRUE' AND newrec_.payment_receipt_type != 'AT_MATCHING' THEN
         Error_SYS.Record_General(lu_name_, 'WRONGPAYRECTYPE: Only Receipt At Matching is allowed when Tax Invoice for company is used.');
      END IF;
   END IF;

   Error_SYS.Check_Not_Null(lu_name_, 'IDENTITY', newrec_.identity);

   IF (newrec_.identity = newrec_.other_payee_identity) THEN
      Error_SYS.Record_General(lu_name_, 'SAMEPARTY: Other Payee cannot refer to itself.');
   END IF;

EXCEPTION
   WHEN value_error THEN
      Error_SYS.Item_Format(lu_name_, name_, value_);
END Unpack_Check_Insert___;


PROCEDURE Insert___ (
   objid_      OUT    VARCHAR2,
   objversion_ OUT    VARCHAR2,
   newrec_     IN OUT &TABLE%ROWTYPE,
   attr_       IN OUT VARCHAR2 )
IS
   CURSOR get_objid IS
      SELECT &OBJID
      FROM  &TABLE
      WHERE company = newrec_.company
      AND   identity = newrec_.identity
      AND   party_type = newrec_.party_type;
BEGIN
   newrec_.format_no := Get_Next_Format_No___ (newrec_.company);
   newrec_.rowversion := 1;
   objversion_ := to_char(newrec_.rowversion);
   INSERT
      INTO identity_pay_info_tab (
         company,
         identity,
         party_type,
         priority,
         blocked_for_payment,
         other_payee_identity,
         interest_template,
         reminder_template,
         payment_delay,
         amount_tolerance,
         percent_tolerance,
         disc_days_tolerance,
         netting_allowed,
         format_no,
         payment_advice,
         deduction_group,
         corporation_id,
         member_id,
         send_reminder_to_payer,
         send_interest_inv_to_payer,
         rule_id,
         next_payment_matching_id,
         payment_receipt_type,
         template_id,
         check_recipient,
         send_statement_of_acc_to_payer,
         rowversion)
      VALUES (
         newrec_.company,
         newrec_.identity,
         newrec_.party_type,
         newrec_.priority,
         newrec_.blocked_for_payment,
         newrec_.other_payee_identity,
         newrec_.interest_template,
         newrec_.reminder_template,
         newrec_.payment_delay,
         newrec_.amount_tolerance,
         newrec_.percent_tolerance,
         newrec_.disc_days_tolerance,
         newrec_.netting_allowed,
         newrec_.format_no,
         newrec_.payment_advice,
         newrec_.deduction_group,
         newrec_.corporation_id,
         newrec_.member_id,
         newrec_.send_reminder_to_payer,
         newrec_.send_interest_inv_to_payer,
         newrec_.rule_id,
         0,
         newrec_.payment_receipt_type,
         newrec_.template_id,
         newrec_.check_recipient,
         newrec_.send_statement_of_acc_to_payer,
         newrec_.rowversion)
      RETURNING &OBJID INTO objid_;
EXCEPTION
   WHEN dup_val_on_index THEN
      Error_SYS.Record_General(lu_name_, 'PARTYTYPEIDNOTEXIST: :P1 already exists in the Payment module.',
      Party_Type_API.Decode(newrec_.party_type));
END Insert___;

-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION BASE METHODS FOR UPDATE -----------------
-----------------------------------------------------------------------------
-- Unpack_Check_Update___
--    Unpack the attribute list, check all attributes from the client
--    and generate all default values before modifying the object.
--
-- Update___
--    Update an existing LU-instance in the database and return the
--    the new OBJVERSION.
-----------------------------------------------------------------------------

PROCEDURE Unpack_Check_Update___ (
   attr_   IN OUT VARCHAR2,
   newrec_ IN OUT &TABLE%ROWTYPE,
   objid_  IN     VARCHAR2 )
IS
   ptr_   NUMBER;
   name_  VARCHAR2(30);
   value_ VARCHAR2(2000);
BEGIN
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
      IF (name_ = 'COMPANY') THEN
         Error_SYS.Item_Update(lu_name_, 'COMPANY');
      ELSIF (name_ = 'IDENTITY') THEN
         Error_SYS.Item_Update(lu_name_, 'IDENTITY');
      ELSIF (name_ = 'PARTY_TYPE') THEN
         Error_SYS.Item_Update(lu_name_, 'PARTY_TYPE');
      ELSIF (name_ = 'PARTY_TYPE_DB') THEN
         Error_SYS.Item_Update(lu_name_, 'PARTY_TYPE');
      ELSIF (name_ = 'PRIORITY') THEN
         newrec_.priority := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'BLOCKED_FOR_PAYMENT') THEN
         newrec_.blocked_for_payment := value_;
         IF (value_ IS NOT NULL AND newrec_.blocked_for_payment NOT IN ('TRUE', 'FALSE')) THEN
            RAISE value_error;
         END IF;
      ELSIF (name_ = 'OTHER_PAYEE_IDENTITY') THEN
         newrec_.other_payee_identity := value_;
         IF (value_ IS NOT NULL) THEN
            Identity_Pay_Info_API.Exist(newrec_.company, newrec_.other_payee_identity ,Party_Type_API.Decode(newrec_.party_type));
         END IF;
      ELSIF (name_ = 'INTEREST_TEMPLATE') THEN
         newrec_.interest_template := value_;
         IF (value_ IS NOT NULL) THEN
            Interest_Template_API.Exist(newrec_.company, newrec_.interest_template);
         END IF;
      ELSIF (name_ = 'REMINDER_TEMPLATE') THEN
         newrec_.reminder_template := value_;
         IF (value_ IS NOT NULL) THEN
            Reminder_Template_API.Exist(newrec_.company, newrec_.reminder_template);
         END IF;
      ELSIF (name_ = 'PAYMENT_DELAY') THEN
         newrec_.payment_delay := Client_SYS.Attr_Value_To_Number(value_);
         IF (TRUNC(newrec_.payment_delay) <> newrec_.payment_delay) THEN
            Error_SYS.Record_General(lu_name_, 'NOTWHOLENUM: A whole number must be specified for the payment delay.');
         END IF;
      ELSIF (name_ = 'AMOUNT_TOLERANCE') THEN
         newrec_.amount_tolerance := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'PERCENT_TOLERANCE') THEN
         newrec_.percent_tolerance := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'DISC_DAYS_TOLERANCE') THEN
         newrec_.disc_days_tolerance := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'NETTING_ALLOWED') THEN
         newrec_.netting_allowed := value_;
         IF (newrec_.netting_allowed NOT IN ('TRUE', 'FALSE')) THEN
            RAISE value_error;
         END IF;
      ELSIF (name_ = 'FORMAT_NO') THEN
         Error_SYS.Item_Update(lu_name_, 'FORMAT_NO');
      ELSIF (name_ = 'PAYMENT_ADVICE') THEN
         newrec_.payment_advice := Payment_Advice_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Payment_Advice_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'PAYMENT_ADVICE_DB') THEN
         newrec_.payment_advice := value_;
         IF (value_ IS NOT NULL) THEN
            Payment_Advice_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'DEDUCTION_GROUP') THEN
         newrec_.deduction_group := value_;
         IF (value_ IS NOT NULL) THEN
            Deduction_Group_API.Exist(newrec_.company, newrec_.deduction_group);
         END IF;
      ELSIF (name_ = 'CORPORATION_ID') THEN
         newrec_.corporation_id := value_;
      ELSIF (name_ = 'MEMBER_ID') THEN
         newrec_.member_id := value_;
      ELSIF (name_ = 'SEND_REMINDER_TO_PAYER') THEN
         newrec_.send_reminder_to_payer := value_;
      ELSIF (name_ = 'SEND_INTEREST_INV_TO_PAYER') THEN
         newrec_.send_interest_inv_to_payer := value_;
      ELSIF (name_ = 'NOTE') THEN
         NULL;
      ELSIF (name_ = 'NOTE_UPDATE') THEN
         NULL;
      ELSIF (name_ = 'RULE_ID') THEN
         newrec_.rule_id := value_;
         IF (value_ IS NOT NULL) THEN
            Pay_Method_Rule_API.Exist(newrec_.company, newrec_.rule_id);
         END IF;
      ELSIF (name_ = 'PAYMENT_RECEIPT_TYPE') THEN
         newrec_.payment_receipt_type := Payment_Receipt_Type_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Payment_Receipt_Type_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'PAYMENT_RECEIPT_TYPE_DB') THEN
         newrec_.payment_receipt_type := value_;
         IF (value_ IS NOT NULL) THEN
            Payment_Receipt_Type_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'TEMPLATE_ID') THEN
         newrec_.template_id := value_;
         IF (value_ IS NOT NULL) THEN
            Confirmation_Stmnt_Templ_API.Exist(newrec_.company, newrec_.template_id);
         END IF;
      ELSIF (name_ = 'CHECK_RECIPIENT') THEN
         newrec_.check_recipient := Check_Recipient_API.Encode(value_);
         IF (value_ IS NOT NULL) THEN
            Check_Recipient_API.Exist(value_);
         END IF;
      ELSIF (name_ = 'CHECK_RECIPIENT_DB') THEN
         newrec_.check_recipient := value_;
         IF (value_ IS NOT NULL) THEN
            Check_Recipient_API.Exist_Db(value_);
         END IF;
      ELSIF (name_ = 'SEND_STATEMENT_OF_ACC_TO_PAYER') THEN
         newrec_.send_statement_of_acc_to_payer := value_;
      ELSE
         Error_SYS.Item_Not_Exist(lu_name_, name_, value_);
      END IF;
   END LOOP;


   IF (newrec_.amount_tolerance < 0) OR (newrec_.percent_tolerance < 0) OR (newrec_.disc_days_tolerance < 0) THEN
      Error_SYS.Appl_General(lu_name_, 'NEGTOLERANCE: Tolerance should be positive value.');
   END IF;

   Client_SYS.Clear_Attr(attr_);

   Error_SYS.Check_Not_Null(lu_name_, 'NETTING_ALLOWED', newrec_.netting_allowed);
   IF (newrec_.interest_template IS NULL) THEN
      newrec_.interest_template := Interest_Template_API.Get_Default_Template(newrec_.company);
   END IF;

   IF (newrec_.party_type = 'SUPPLIER') THEN
      Error_SYS.Check_Not_Null(lu_name_, 'PRIORITY', newrec_.priority);
      Error_SYS.Check_Not_Null(lu_name_, 'BLOCKED_FOR_PAYMENT', newrec_.blocked_for_payment);
      Error_SYS.Check_Not_Null(lu_name_, 'CHECK_RECIPIENT', newrec_.check_recipient);
   END IF;
   IF (newrec_.party_type = 'CUSTOMER') THEN
      Error_SYS.Check_Not_Null(lu_name_, 'INTEREST_TEMPLATE', newrec_.interest_template);
      Error_SYS.Check_Not_Null(lu_name_, 'REMINDER_TEMPLATE', newrec_.reminder_template);
      Error_SYS.Check_Not_Null(lu_name_, 'PAYMENT_RECEIPT_TYPE', newrec_.payment_receipt_type);
      IF Company_Invoice_Info_API.Get_Use_Tax_Invoice(newrec_.company)='TRUE' AND newrec_.payment_receipt_type != 'AT_MATCHING' THEN
         Error_SYS.Record_General(lu_name_, 'WRONGPAYRECTYPE: Only Receipt At Matching is allowed when Tax Invoice for company is used.');
      END IF;
   END IF;
   IF (newrec_.identity = newrec_.other_payee_identity) THEN
      Error_SYS.Record_General(lu_name_, 'SAMEPARTY: Other Payee cannot refer to itself.');
   END IF;
EXCEPTION
   WHEN value_error THEN
      Error_SYS.Item_Format(lu_name_, name_, value_);
END Unpack_Check_Update___;


PROCEDURE Update___ (
   objid_      IN     VARCHAR2,
   oldrec_     IN     &TABLE%ROWTYPE,
   newrec_     IN OUT &TABLE%ROWTYPE,
   attr_       IN OUT VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   by_keys_    IN     BOOLEAN DEFAULT FALSE )
IS
BEGIN
   newrec_.rowversion := newrec_.rowversion + 1;
   objversion_ := to_char(newrec_.rowversion);
   IF by_keys_ THEN
      UPDATE identity_pay_info_tab
         SET company = newrec_.company,
             identity = newrec_.identity,
             party_type = newrec_.party_type,
             priority = newrec_.priority,
             blocked_for_payment = newrec_.blocked_for_payment,
             other_payee_identity = newrec_.other_payee_identity,
             interest_template = newrec_.interest_template,
             reminder_template = newrec_.reminder_template,
             payment_delay = newrec_.payment_delay,
             amount_tolerance = newrec_.amount_tolerance,
             percent_tolerance = newrec_.percent_tolerance,
             disc_days_tolerance = newrec_.disc_days_tolerance,
             netting_allowed = newrec_.netting_allowed,
             format_no = newrec_.format_no,
             payment_advice = newrec_.payment_advice,
             deduction_group = newrec_.deduction_group,
             corporation_id = newrec_.corporation_id,
             member_id = newrec_.member_id,
             send_reminder_to_payer = newrec_.send_reminder_to_payer,
             send_interest_inv_to_payer = newrec_.send_interest_inv_to_payer,
             rule_id = newrec_.rule_id,
             payment_receipt_type = newrec_.payment_receipt_type,
             template_id = newrec_.template_id,
             check_recipient = newrec_.check_recipient,
             send_statement_of_acc_to_payer = newrec_.send_statement_of_acc_to_payer,
             rowversion = newrec_.rowversion
         WHERE company = newrec_.company
         AND   identity = newrec_.identity
         AND   party_type = newrec_.party_type;
   ELSE
      UPDATE identity_pay_info_tab
         SET company = newrec_.company,
             identity = newrec_.identity,
             party_type = newrec_.party_type,
             priority = newrec_.priority,
             blocked_for_payment = newrec_.blocked_for_payment,
             other_payee_identity = newrec_.other_payee_identity,
             interest_template = newrec_.interest_template,
             reminder_template = newrec_.reminder_template,
             payment_delay = newrec_.payment_delay,
             amount_tolerance = newrec_.amount_tolerance,
             percent_tolerance = newrec_.percent_tolerance,
             disc_days_tolerance = newrec_.disc_days_tolerance,
             netting_allowed = newrec_.netting_allowed,
             format_no = newrec_.format_no,
             payment_advice = newrec_.payment_advice,
             deduction_group = newrec_.deduction_group,
             corporation_id = newrec_.corporation_id,
             member_id = newrec_.member_id,
             send_reminder_to_payer = newrec_.send_reminder_to_payer,
             send_interest_inv_to_payer = newrec_.send_interest_inv_to_payer,
             rule_id = newrec_.rule_id,
             payment_receipt_type = newrec_.payment_receipt_type,
             template_id = newrec_.template_id,
             check_recipient = newrec_.check_recipient,
             send_statement_of_acc_to_payer = newrec_.send_statement_of_acc_to_payer,
             rowversion = newrec_.rowversion
         WHERE &OBJID = objid_;
   END IF;
EXCEPTION
   WHEN dup_val_on_index THEN
      Error_SYS.Record_Exist(lu_name_);
END Update___;

-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION BASE METHODS FOR DELETE -----------------
-----------------------------------------------------------------------------
-- Check_Delete___
--    Checks whether a specific LU-record may be removed or not.
--    The procedure should check business rules like attribute values
--    as well as database constraints (defined or not).
--
-- Delete___
--    Deletion of the specific LU-object from the database.
-----------------------------------------------------------------------------

PROCEDURE Check_Delete___ (
   remrec_ IN &TABLE%ROWTYPE )
IS
   key_ VARCHAR2(2000);
BEGIN
   key_ := remrec_.company || '^' || remrec_.identity || '^' || Party_Type_API.Decode(remrec_.party_type) || '^';
   Reference_SYS.Check_Restricted_Delete(lu_name_, key_);
END Check_Delete___;


PROCEDURE Delete___ (
   objid_  IN VARCHAR2,
   remrec_ IN &TABLE%ROWTYPE )
IS
   key_ VARCHAR2(2000);
BEGIN
   key_ := remrec_.company || '^' || remrec_.identity || '^' || Party_Type_API.Decode(remrec_.party_type) || '^';
   Reference_SYS.Do_Cascade_Delete(lu_name_, key_);
   DELETE
      FROM  identity_pay_info_tab
      WHERE &OBJID = objid_;
END Delete___;

-----------------------------------------------------------------------------
-------------------- PRIVATE BASE METHODS -----------------------------------
-----------------------------------------------------------------------------
-- Lock__
--    Client-support to lock a specific instance of the logical unit.
--
-- New__
--    Client-support interface to create LU instances.
--       action_ = 'PREPARE'
--          Default values and handle of information to client.
--          The default values are set in procedure Prepare_Insert___.
--       action_ = 'CHECK'
--          Check all attributes before creating new object and handle of
--          information to client. The attribute list is unpacked, checked
--          and prepared (defaults) in procedure Unpack_Check_Insert___.
--       action_ = 'DO'
--          Creation of new instances of the logical unit and handle of
--          information to client. The attribute list is unpacked, checked
--          and prepared (defaults) in procedure Unpack_Check_Insert___
--          before calling procedure Insert___.
--
-- Modify__
--    Client-support interface to modify attributes for LU instances.
--       action_ = 'CHECK'
--          Check all attributes before modifying an existing object and
--          handle of information to client. The attribute list is unpacked,
--          checked and prepared(defaults) in procedure Unpack_Check_Update___.
--       action_ = 'DO'
--          Modification of an existing instance of the logical unit. The
--          procedure unpacks the attributes, checks all values before
--          procedure Update___ is called.
--
-- Remove__
--    Client-support interface to remove LU instances.
--       action_ = 'CHECK'
--          Check whether a specific LU-instance may be removed or not.
--          The procedure fetches the complete record by calling procedure
--          Get_Object_By_Id___. Then the check is made by calling procedure
--          Check_Delete___.
--       action_ = 'DO'
--          Remove an existing instance of the logical unit. The procedure
--          fetches the complete LU-record, checks for a delete and then
--          deletes the record by calling procedure Delete___.
-----------------------------------------------------------------------------

PROCEDURE Lock__ (
   info_       OUT VARCHAR2,
   objid_      IN  VARCHAR2,
   objversion_ IN  VARCHAR2 )
IS
   dummy_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Lock__');
   dummy_ := Lock_By_Id___(objid_, objversion_);
   info_ := Client_SYS.Get_All_Info;
END Lock__;


PROCEDURE New__ (
   info_       OUT    VARCHAR2,
   objid_      OUT    VARCHAR2,
   objversion_ OUT    VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   newrec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'New__');
   IF (action_ = 'PREPARE') THEN
      Prepare_Insert___(attr_);
   ELSIF (action_ = 'CHECK') THEN
      Unpack_Check_Insert___(attr_, newrec_);
   ELSIF (action_ = 'DO') THEN
      Unpack_Check_Insert___(attr_, newrec_);
      Insert___(objid_, objversion_, newrec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END New__;

PROCEDURE Modify__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   oldrec_ &TABLE%ROWTYPE;
   newrec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Modify__');
   IF (action_ = 'CHECK') THEN
      newrec_ := Get_Object_By_Id___(objid_);
      Unpack_Check_Update___(attr_, newrec_, objid_);
   ELSIF (action_ = 'DO') THEN
      oldrec_ := Lock_By_Id___(objid_, objversion_);
      newrec_ := oldrec_;

      Save_Identity_Notes___(attr_, newrec_ );

      Unpack_Check_Update___(attr_, newrec_, objid_);
      Update___(objid_, oldrec_, newrec_, attr_, objversion_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Modify__;


PROCEDURE Remove__ (
   info_       OUT VARCHAR2,
   objid_      IN  VARCHAR2,
   objversion_ IN  VARCHAR2,
   action_     IN  VARCHAR2 )
IS
   remrec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Remove__');
   IF (action_ = 'CHECK') THEN
      remrec_ := Get_Object_By_Id___(objid_);
      Check_Delete___(remrec_);
   ELSIF (action_ = 'DO') THEN
      remrec_ := Lock_By_Id___(objid_, objversion_);
      Check_Delete___(remrec_);
      Delete___(objid_, remrec_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Remove__;

-----------------------------------------------------------------------------
-------------------- PUBLIC BASE METHODS ------------------------------------
-----------------------------------------------------------------------------
-- Exist
--   Checks if given pointer (e.g. primary key) to an instance of this
--   logical unit exists. If not an exception will be raised.
-----------------------------------------------------------------------------

PROCEDURE Exist (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 )
IS
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Exist', TRUE);
   IF (NOT Check_Exist___(company_, identity_, Party_Type_API.Encode(party_type_))) THEN
      -- Bug 72612, Begin, Modified IF condition
      IF Party_Type_API.Encode(party_type_) IN ('CUSTOMER', 'SUPPLIER') THEN
         Error_SYS.Record_General(lu_name_, 'IDENTITYPAYEXIST: :P1 :P2 does not exist in company :P3 in Payment module.', party_type_, identity_, company_);
      -- Bug 72612, End.
         -- Bug 71612, Begin, Added IF condition, IF Party type 'COMPANY' display an error message
         ELSIF (Party_Type_API.Encode(party_type_) = 'COMPANY') THEN
            Error_SYS.Record_General(lu_name_, 'NOTPAYCOMPANY: Parked payments are allowed only against the payment company.');
         -- Bug 72612, End.
      ELSE
         Error_SYS.Record_Not_Exist(lu_name_);
      END IF;
   END IF;
END Exist;


PROCEDURE Exist_Db (
   company_       IN VARCHAR2,
   identity_      IN VARCHAR2,
   party_type_db_ IN VARCHAR2 )
IS
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Exist', TRUE);
   IF (NOT Check_Exist___(company_, identity_, party_type_db_)) THEN
      IF party_type_db_ IN ('CUSTOMER', 'SUPPLIER', 'COMPANY') THEN
         Error_SYS.Record_General(lu_name_, 'IDENTITYPAYEXIST2: :P1 :P2 does not exist in company :P3 in Payment module.', Party_Type_API.Decode(party_type_db_), identity_, company_);
      ELSE
         Error_SYS.Record_Not_Exist(lu_name_);
      END IF;
   END IF;
END Exist_Db;

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC IMPLEMENTATION METHODS ---------------------
-----------------------------------------------------------------------------
PROCEDURE Save_Identity_Notes___ (
   attr_       IN VARCHAR2,
   newrec_     IN &TABLE%ROWTYPE )
IS
   note_   VARCHAR2(2000);
   note_update_   VARCHAR2(20);

BEGIN
   note_ := Client_SYS.Get_Item_Value('NOTE',attr_);
   note_update_ := Client_SYS.Get_Item_Value('NOTE_UPDATE',attr_);

   IF ((note_ IS NULL) AND (note_update_ IS NULL)) THEN
      RETURN;
   END IF;

   Identity_Invoice_Info_API.Set_Notes(newrec_.company,
                                       newrec_.identity,
                                       Party_Type_Api.Decode(newrec_.party_type),
                                       note_ );
END Save_Identity_Notes___;

FUNCTION Get_Next_Format_No___ (
   company_       IN VARCHAR2 ) RETURN NUMBER
IS
   CURSOR rec IS
      SELECT MAX( format_no )
      FROM &TABLE
      WHERE company   = company_;

   max_format_   NUMBER;
BEGIN
   OPEN rec;
   FETCH rec INTO max_format_;
   IF ( rec%NOTFOUND ) THEN
      CLOSE rec;
      RETURN 1;
   END IF;
   CLOSE rec;

   RETURN ( NVL(max_format_,0) + 1 );
END Get_Next_Format_No___;

PROCEDURE Check_Cascade___ (
   company_       IN VARCHAR2,
   identity_      IN VARCHAR2,
   party_type_db_ IN VARCHAR2 )
IS
   CURSOR get_ledger_item1 IS                                         
      SELECT rowtype
      FROM   ledger_item_tab
      WHERE  company    = company_
      AND    party_type = party_type_db_
      AND    identity   = identity_;

   CURSOR get_ledger_item2 IS                                         
      SELECT rowtype
      FROM   ledger_item_tab
      WHERE  company        = company_
      AND    party_type     = party_type_db_
      AND    payer_identity = identity_;

   CURSOR get_ledger_item3 IS                                         
      SELECT rowtype
      FROM   ledger_item_tab
      WHERE  company        = company_
      AND    party_type     = party_type_db_
      AND    payee_identity = identity_;
BEGIN
   FOR ledger_item_ IN get_ledger_item1 LOOP
      IF (ledger_item_.rowtype = 'InvoiceLedgerItem') THEN
         Error_SYS.Appl_General(lu_name_, 'INVOICESEXIST: Invoices exist for :P1 :P2', Party_Type_API.Decode(party_type_db_), identity_);
      ELSIF (ledger_item_.rowtype = 'OnAccountLedgerItem') THEN
         Error_SYS.Appl_General(lu_name_, 'PAYMENTONACCNTEXIST: Payments on account exist for :P1 :P2', Party_Type_API.Decode(party_type_db_), identity_);
      ELSE
         Error_SYS.Appl_General(lu_name_, 'LEDGERITEMSEXIST: Ledger items exist for :P1 :P2', Party_Type_API.Decode(party_type_db_), identity_);
      END IF;
   END LOOP;

   FOR ledger_item_ IN get_ledger_item2 LOOP
      IF (ledger_item_.rowtype = 'InvoiceLedgerItem') THEN
         Error_SYS.Appl_General(lu_name_, 'INVOICESEXIST: Invoices exist for :P1 :P2', Party_Type_API.Decode(party_type_db_), identity_);
      ELSIF (ledger_item_.rowtype = 'OnAccountLedgerItem') THEN
         Error_SYS.Appl_General(lu_name_, 'PAYMENTONACCNTEXIST: Payments on account exist for :P1 :P2', Party_Type_API.Decode(party_type_db_), identity_);
      ELSE
         Error_SYS.Appl_General(lu_name_, 'LEDGERITEMSEXIST: Ledger items exist for :P1 :P2', Party_Type_API.Decode(party_type_db_), identity_);
      END IF;
   END LOOP;

   FOR ledger_item_ IN get_ledger_item3 LOOP
      IF (ledger_item_.rowtype = 'InvoiceLedgerItem') THEN
         Error_SYS.Appl_General(lu_name_, 'INVOICESEXIST: Invoices exist for :P1 :P2', Party_Type_API.Decode(party_type_db_), identity_);
      ELSIF (ledger_item_.rowtype = 'OnAccountLedgerItem') THEN
         Error_SYS.Appl_General(lu_name_, 'PAYMENTONACCNTEXIST: Payments on account exist for :P1 :P2', Party_Type_API.Decode(party_type_db_), identity_);
      ELSE
         Error_SYS.Appl_General(lu_name_, 'LEDGERITEMSEXIST: Ledger items exist for :P1 :P2', Party_Type_API.Decode(party_type_db_), identity_);
      END IF;
   END LOOP;
END Check_Cascade___;

PROCEDURE Import___ (
   crecomp_rec_ IN ENTERP_COMP_CONNECT_V160_API.Crecomp_Lu_Public_Rec )
IS
   CURSOR get_data IS
      SELECT C1,C2,N1,C3,C4,C5,C6,N2,N3,N4,C7,N5,C8,C9,C10,C11,C12,C13,C14,C15
      FROM   Create_Company_Tem_Detail src
      WHERE  component = '&MODULE'
      AND    lu        = lu_name_
      AND    template_id = crecomp_rec_.template_id
      AND    version     = crecomp_rec_.version
      AND NOT EXISTS (SELECT 1
                      FROM &TABLE dest
                      WHERE dest.company = crecomp_rec_.company
                      AND dest.identity = crecomp_rec_.company
                      AND dest.party_type = src.c2);

   -- Bug 74138, Begin, Added condition to fetch data when party_type = 'COMPANY'  
   CURSOR exist_company IS
      SELECT 'X'
      FROM   &TABLE
      WHERE  company = crecomp_rec_.company
      AND    party_type = 'COMPANY';
   -- Bug 74138, End

   dummy_         VARCHAR2(1);
   attr_          VARCHAR2(2000);
   objid_         VARCHAR2(2000);
   objversion_    VARCHAR2(2000);
   newrec_        &TABLE%ROWTYPE;
   msg_           VARCHAR2(2000);
   i_             NUMBER := 0;
   update_by_key_ BOOLEAN DEFAULT FALSE;
   empty_lu_      BOOLEAN := FALSE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Import___', TRUE);

   update_by_key_ := Enterp_Comp_Connect_V160_API.Use_Keys(module_, lu_name_, crecomp_rec_);

   IF (NOT update_by_key_) THEN
      empty_lu_ := FALSE;
      OPEN exist_company;
      FETCH exist_company INTO dummy_;
      IF ( exist_company%NOTFOUND ) THEN
         CLOSE exist_company;
         empty_lu_ := TRUE;
      END IF;
   END IF;

   IF ( update_by_key_ OR empty_lu_ ) THEN
      FOR rec_ IN get_data LOOP
         i_ := i_ + 1;
         BEGIN
            newrec_.company                        := crecomp_rec_.company;
            newrec_.identity                       := crecomp_rec_.company;
            newrec_.party_type                     := rec_.c2;
            newrec_.priority                       := rec_.n1;
            newrec_.blocked_for_payment            := rec_.c3;
            newrec_.other_payee_identity           := rec_.c4;
            newrec_.interest_template              := rec_.c5;
            newrec_.reminder_template              := rec_.c6;
            newrec_.payment_delay                  := rec_.n2;
            newrec_.amount_tolerance               := rec_.n3;
            newrec_.percent_tolerance              := rec_.n4;
            newrec_.disc_days_tolerance            := rec_.n5;
            newrec_.netting_allowed                := rec_.c7;
            newrec_.format_no                      := rec_.n5;
            newrec_.payment_advice                 := rec_.c8;
            newrec_.deduction_group                := rec_.c9;
            newrec_.corporation_id                 := rec_.c10;
            newrec_.member_id                      := rec_.c11;
            newrec_.send_reminder_to_payer         := rec_.c12;
            newrec_.send_interest_inv_to_payer     := rec_.c13;
            newrec_.payment_receipt_type           := rec_.c14;
            newrec_.send_statement_of_acc_to_payer := rec_.c15;
            
            Company_API.Exist(newrec_.company);
            Payment_Library_API.Exist_In_Enterp(newrec_.company, newrec_.company, Party_Type_API.Decode(newrec_.party_type));
            IF (newrec_.blocked_for_payment IS NOT NULL AND newrec_.blocked_for_payment NOT IN ('TRUE', 'FALSE')) THEN
               Error_SYS.Record_General(lu_name_,'TRUEORFALSE: The value must be TRUE or FALSE');
            END IF;
            IF (newrec_.other_payee_identity IS NOT NULL) THEN
               Identity_Pay_Info_API.Exist(newrec_.company, newrec_.other_payee_identity, Party_Type_API.Decode(newrec_.party_type));
            END IF;
            IF (newrec_.interest_template IS NOT NULL) THEN
               Interest_Template_API.Exist(newrec_.company, newrec_.interest_template);
            END IF;
            IF (newrec_.reminder_template IS NOT NULL) THEN
               Reminder_Template_API.Exist(newrec_.company, newrec_.reminder_template);
            END IF;
            IF (TRUNC(newrec_.payment_delay) <> newrec_.payment_delay) THEN
               Error_SYS.Record_General(lu_name_, 'NOTWHOLENUM: A whole number must be specified for the payment delay.');
            END IF;
            IF (newrec_.netting_allowed NOT IN ('TRUE', 'FALSE')) THEN
               Error_SYS.Record_General(lu_name_,'TRUEORFALSE: The value must be TRUE or FALSE');
            END IF;
            IF (newrec_.payment_advice IS NOT NULL) THEN
               Payment_Advice_API.Exist_Db(newrec_.payment_advice);
            END IF;
            IF (newrec_.deduction_group IS NOT NULL) THEN
               Deduction_Group_API.Exist(newrec_.company, newrec_.deduction_group);
            END IF;
            IF (newrec_.payment_receipt_type IS NOT NULL) THEN
               Payment_Receipt_Type_API.Exist_Db(newrec_.payment_receipt_type);
            END IF;

            Error_SYS.Check_Not_Null(lu_name_, 'COMPANY', newrec_.company);
            Error_SYS.Check_Not_Null(lu_name_, 'IDENTITY', newrec_.identity);
            Error_SYS.Check_Not_Null(lu_name_, 'PARTY_TYPE', newrec_.party_type);
            Error_SYS.Check_Not_Null(lu_name_, 'NETTING_ALLOWED', newrec_.netting_allowed);

            IF (newrec_.party_type = 'SUPPLIER') THEN
               Error_SYS.Check_Not_Null(lu_name_, 'PRIORITY', newrec_.priority);
               Error_SYS.Check_Not_Null(lu_name_, 'BLOCKED_FOR_PAYMENT', newrec_.blocked_for_payment);
            END IF;
            IF (newrec_.party_type = 'CUSTOMER') THEN
               Error_SYS.Check_Not_Null(lu_name_, 'INTEREST_TEMPLATE', newrec_.interest_template);
               Error_SYS.Check_Not_Null(lu_name_, 'REMINDER_TEMPLATE', newrec_.reminder_template);
               Error_SYS.Check_Not_Null(lu_name_, 'PAYMENT_RECEIPT_TYPE', newrec_.payment_receipt_type);
            END IF;

            Error_SYS.Check_Not_Null(lu_name_, 'IDENTITY', newrec_.identity);

            IF (newrec_.identity = newrec_.other_payee_identity) THEN
               Error_SYS.Record_General(lu_name_, 'SAMEPARTY: Other Payee cannot refer to itself.');
            END IF;

            Insert___(objid_, objversion_, newrec_, attr_);
         EXCEPTION
            WHEN OTHERS THEN
               msg_ := SQLERRM;
               Enterp_Comp_Connect_V160_API.Log_Logging(crecomp_rec_.company, module_, '&PKG', 'Error', msg_);
         END;
      END LOOP;
      IF ( i_ = 0 ) THEN
         msg_ := language_sys.translate_constant(lu_name_, 'NODATAFOUND:No Data Found');
         Enterp_Comp_Connect_V160_API.Log_Logging(crecomp_rec_.company, module_, '&PKG', 'CreatedSuccessfully', msg_);
      ELSE
         IF msg_ IS NULL THEN
            Enterp_Comp_Connect_V160_API.Log_Logging(crecomp_rec_.company, module_, '&PKG', 'CreatedSuccessfully');
         ELSE
            Enterp_Comp_Connect_V160_API.Log_Logging(crecomp_rec_.company, module_, '&PKG', 'CreatedWithErrors');
         END IF;
      END IF;
   END IF;
   -- This statement is to add to the log that the Create company process for LUs is finished if
   -- update_by_key_ and empty_lu are FALSE
   IF ( NOT update_by_key_ AND NOT empty_lu_ ) THEN
      Enterp_Comp_Connect_V160_API.Log_Logging(crecomp_rec_.company, module_, '&PKG', 'CreatedSuccessfully');
   END IF;
EXCEPTION
   WHEN OTHERS THEN
      msg_ := SQLERRM;
      Enterp_Comp_Connect_V160_API.Log_Logging(crecomp_rec_.company, module_, '&PKG', 'Error', msg_);
      Enterp_Comp_Connect_V160_API.Log_Logging(crecomp_rec_.company, module_, '&PKG', 'CreatedWithErrors');
END Import___;


PROCEDURE Copy___ (
   crecomp_rec_   IN ENTERP_COMP_CONNECT_V160_API.Crecomp_Lu_Public_Rec )
IS
   dummy_         VARCHAR2(1);
   msg_           VARCHAR2(2000);
   update_by_key_ BOOLEAN DEFAULT FALSE;
   empty_lu_      BOOLEAN := FALSE;

   CURSOR exist_company IS
      SELECT 'X'
      FROM   &TABLE
      WHERE  company = crecomp_rec_.company;

   CURSOR get_data IS
      SELECT *
      FROM   &TABLE src
      WHERE  company = crecomp_rec_.old_company
      AND    identity = crecomp_rec_.old_company
      AND    party_type = 'COMPANY'
      AND NOT EXISTS (SELECT 1
                      FROM &TABLE dest
                      WHERE dest.company = crecomp_rec_.company
                      AND dest.identity = src.identity
                      AND dest.party_type = src.party_type);
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Copy___', TRUE);

   update_by_key_ := Enterp_Comp_Connect_V160_API.Use_Keys(module_, lu_name_, crecomp_rec_);

   IF (NOT update_by_key_) THEN
      empty_lu_ := FALSE;
      OPEN exist_company;
      FETCH exist_company INTO dummy_;
      IF ( exist_company%NOTFOUND ) THEN
         CLOSE exist_company;
         empty_lu_ := TRUE;
      END IF;
   END IF;

   IF ( update_by_key_ OR empty_lu_ ) THEN
      FOR rec_ IN get_data LOOP
         BEGIN
            INSERT
               INTO identity_pay_info_tab (
                  company,
                  identity,
                  party_type,
                  priority,
                  blocked_for_payment,
                  other_payee_identity,
                  interest_template,
                  reminder_template,
                  payment_delay,
                  amount_tolerance,
                  percent_tolerance,
                  disc_days_tolerance,
                  netting_allowed,
                  format_no,
                  payment_advice,
                  deduction_group,
                  corporation_id,
                  member_id,
                  send_reminder_to_payer,
                  send_interest_inv_to_payer,
                  next_payment_matching_id,
                  payment_receipt_type,
                  send_statement_of_acc_to_payer,
                  rowversion)
               VALUES (
                  crecomp_rec_.company,
                  crecomp_rec_.company,
                  rec_.party_type,
                  rec_.priority,
                  rec_.blocked_for_payment,
                  rec_.other_payee_identity,
                  rec_.interest_template,
                  rec_.reminder_template,
                  rec_.payment_delay,
                  rec_.amount_tolerance,
                  rec_.percent_tolerance,
                  rec_.disc_days_tolerance,
                  rec_.netting_allowed,
                  rec_.format_no,
                  rec_.payment_advice,
                  rec_.deduction_group,
                  rec_.corporation_id,
                  rec_.member_id,
                  rec_.send_reminder_to_payer,
                  rec_.send_interest_inv_to_payer,
                  0,
                  rec_.payment_receipt_type,
                  rec_.send_statement_of_acc_to_payer,
                  1);
         END;
      END LOOP;
      Enterp_Comp_Connect_V160_API.Log_Logging(crecomp_rec_.company, module_, '&PKG', 'CreatedSuccessfully');
   END IF;
   -- This statement is to add to the log that the Create company process for LUs is finished if
   -- update_by_key_ and empty_lu are FALSE
   IF ( NOT update_by_key_ AND NOT empty_lu_ ) THEN
      Enterp_Comp_Connect_V160_API.Log_Logging(crecomp_rec_.company, module_, '&PKG', 'CreatedSuccessfully');
   END IF;
EXCEPTION
   WHEN OTHERS THEN
      msg_ := SQLERRM;
      Enterp_Comp_Connect_V160_API.Log_Logging(crecomp_rec_.company, module_, '&PKG', 'Error', msg_);
      Enterp_Comp_Connect_V160_API.Log_Logging(crecomp_rec_.company, module_, '&PKG', 'CreatedWithErrors');
END Copy___;



PROCEDURE Export___ (
   crecomp_rec_   IN ENTERP_COMP_CONNECT_V160_API.Crecomp_Lu_Public_Rec )
IS
   pub_rec_       Enterp_Comp_Connect_V160_API.Tem_Public_Rec;
   i_             NUMBER := 1;

   CURSOR get_data IS
      SELECT *
      FROM   &VIEWPCT
      WHERE  company = crecomp_rec_.company
      AND    party_type_db = 'COMPANY';
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Export___', TRUE);
   FOR pctrec_ IN get_data LOOP
      pub_rec_.template_id := crecomp_rec_.template_id;
      pub_rec_.component := '&MODULE';
      pub_rec_.version  := crecomp_rec_.version;
      pub_rec_.lu       := lu_name_;
      pub_rec_.item_id  := i_;
      pub_rec_.c1 := '<NEW COMPANY>';
      pub_rec_.c2 := pctrec_.party_type_db;
      pub_rec_.n1 := pctrec_.priority;
      pub_rec_.c3 := pctrec_.blocked_for_payment;
      pub_rec_.c4 := pctrec_.other_payee_identity;
      pub_rec_.c5 := pctrec_.interest_template;
      pub_rec_.c6 := pctrec_.reminder_template;
      pub_rec_.n2 := pctrec_.payment_delay;
      pub_rec_.n3 := pctrec_.amount_tolerance;
      pub_rec_.n4 := pctrec_.percent_tolerance;
      pub_rec_.n5 := pctrec_.disc_days_tolerance;
      pub_rec_.c7 := pctrec_.netting_allowed;
      pub_rec_.n5 := pctrec_.format_no;
      pub_rec_.c8 := pctrec_.payment_advice_db;
      pub_rec_.c9 := pctrec_.deduction_group;
      pub_rec_.c10 := pctrec_.corporation_id;
      pub_rec_.c11 := pctrec_.member_id;
      pub_rec_.c12 := pctrec_.send_reminder_to_payer;
      pub_rec_.c13 := pctrec_.send_interest_inv_to_payer;
      pub_rec_.c14 := pctrec_.payment_receipt_type_db;
      pub_rec_.c15 := pctrec_.send_statement_of_acc_to_payer;
      Enterp_Comp_Connect_V160_API.Tem_Insert_Detail_Data(pub_rec_);
      i_ := i_ + 1;
   END LOOP;
END Export___;

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PRIVATE METHODS ----------------------------
-----------------------------------------------------------------------------

PROCEDURE Check_Cascade_Customer__ (
   attr_ IN VARCHAR2 )
IS
   CURSOR customer_in_company (identity_      IN VARCHAR2,
                               party_type_db_ IN VARCHAR2 ) IS
      SELECT company
      FROM   &TABLE
      WHERE  identity   = identity_
      AND    party_type = party_type_db_;

   identity_        VARCHAR2(20);
   party_type_db_   VARCHAR2(20);
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Check_Cascade_Customer__');

   identity_ := substr(attr_,1,instr(attr_,'^',1,1)-1);
   party_type_db_  := 'CUSTOMER';
   FOR comp_ IN customer_in_company (identity_, party_type_db_) LOOP
      Check_Cascade___(comp_.company, identity_, party_type_db_);
   END LOOP;
END Check_Cascade_Customer__;

PROCEDURE Check_Cascade_Supplier__ (
   attr_ IN VARCHAR2 )
IS
   CURSOR supplier_in_company (identity_      IN VARCHAR2,
                               party_type_db_ IN VARCHAR2 ) IS
      SELECT company
      FROM   &TABLE
      WHERE  identity   = identity_
      AND    party_type = party_type_db_;

   identity_        VARCHAR2(20);
   party_type_db_   VARCHAR2(20);
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Check_Cascade_Supplier__');

   identity_ := substr(attr_,1,instr(attr_,'^',1,1)-1);
   party_type_db_  := 'SUPPLIER';
   FOR comp_ IN supplier_in_company (identity_, party_type_db_) LOOP
      Check_Cascade___(comp_.company, identity_, party_type_db_);
   END LOOP;
END Check_Cascade_Supplier__;

PROCEDURE Cascade_Delete_Customer__ (
   attr_ IN VARCHAR2 )
IS
   identity_        VARCHAR2(20);
   party_type_db_   VARCHAR2(20);
   info_            VARCHAR2(2000);

   CURSOR customer_in_company (identity_      IN VARCHAR2,
                               party_type_db_ IN VARCHAR2 ) IS
      SELECT &OBJID       objid,
             &OBJVERSION  objversion
      FROM   &TABLE
      WHERE  identity   = identity_
      AND    party_type = party_type_db_;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Cascade_Delete_Customer__');

   Check_Cascade_Customer__(attr_);
   identity_ := substr(attr_,1,instr(attr_,'^',1,1)-1);
   party_type_db_  := 'CUSTOMER';

   FOR comp_ IN customer_in_company (identity_, party_type_db_) LOOP
      Remove__(info_, comp_.objid, comp_.objversion, 'DO');
   END LOOP;

END Cascade_Delete_Customer__;

PROCEDURE Cascade_Delete_Supplier__ (
   attr_ IN VARCHAR2 )
IS
   identity_        VARCHAR2(20);
   party_type_db_   VARCHAR2(20);
   info_            VARCHAR2(2000);

   CURSOR supplier_in_company (identity_      IN VARCHAR2,
                               party_type_db_ IN VARCHAR2 ) IS
      SELECT &OBJID       objid,
             &OBJVERSION  objversion
      FROM   &TABLE
      WHERE  identity   = identity_
      AND    party_type = party_type_db_;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Cascade_Delete_Supplier__');

   Check_Cascade_Supplier__(attr_);
   identity_ := substr(attr_,1,instr(attr_,'^',1,1)-1);
   party_type_db_  := 'SUPPLIER';

   FOR comp_ IN supplier_in_company (identity_, party_type_db_) LOOP
      Remove__(info_, comp_.objid, comp_.objversion, 'DO');
   END LOOP;

END Cascade_Delete_Supplier__;

FUNCTION Create_Other_Payee_Attr__ (
   company_  IN VARCHAR2,
   payer_id_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   value_attr_ VARCHAR2(32000);

   CURSOR get_supplier IS
      SELECT identity
      FROM   &TABLE
      WHERE  company              = company_
      AND    other_payee_identity = payer_id_
      AND    party_type           = 'SUPPLIER';
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Create_Other_Payee_Attr__');

   value_attr_ := payer_id_;
   FOR supplier_info_ IN get_supplier LOOP
      value_attr_ := value_attr_ || CHR(39) || ',' || CHR(39) || supplier_info_.identity;
   END LOOP;

   RETURN value_attr_;
END Create_Other_Payee_Attr__;

FUNCTION Create_Cus_Other_Payee_Attr__ (
   company_  IN VARCHAR2,
   payer_id_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   value_attr_ VARCHAR2(32000);

   CURSOR get_customer IS
      SELECT identity
      FROM   &TABLE
      WHERE  company = company_
      AND    other_payee_identity = payer_id_
      AND    party_type = 'CUSTOMER';
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Create_Cus_Other_Payee_Attr__');

   value_attr_ := payer_id_;
   FOR customer_info_ IN get_customer LOOP
      value_attr_ := value_attr_ || CHR(39) || ',' || CHR(39) || customer_info_.identity;
   END LOOP;

   RETURN value_attr_;
END Create_Cus_Other_Payee_Attr__;
-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PROTECTED METHODS --------------------------
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PUBLIC METHODS -----------------------------
-----------------------------------------------------------------------------

FUNCTION Get_Priority (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_  Public_Rec;
BEGIN
   temp_ := Get(company_, identity_, Party_Type_API.Encode(party_type_));
   RETURN temp_.priority;
END Get_Priority;

FUNCTION Get_Blocked_For_Payment (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ Public_Rec;
BEGIN
   temp_ := Get(company_, identity_, Party_Type_API.Encode(party_type_));
   RETURN temp_.blocked_for_payment;
END Get_Blocked_For_Payment;

FUNCTION Get_Payment_Delay (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ Public_Rec;
BEGIN
   temp_ := Get(company_, identity_, Party_Type_API.Encode(party_type_));
   RETURN NVL(temp_.payment_delay, 0);
END Get_Payment_Delay;

FUNCTION Get_Amount_Tolerance (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ Public_Rec;
BEGIN
   temp_ := Get(company_, identity_, Party_Type_API.Encode(party_type_));
   RETURN temp_.amount_tolerance;
END Get_Amount_Tolerance;

FUNCTION Get_Percent_Tolerance (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ Public_Rec;
BEGIN
   temp_ := Get(company_, identity_, Party_Type_API.Encode(party_type_));
   RETURN temp_.percent_tolerance;
END Get_Percent_Tolerance;

FUNCTION Get_Disc_Days_Tolerance (
   company_ IN VARCHAR2,
   identity_ IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..disc_days_tolerance%TYPE;
   CURSOR get_attr IS
      SELECT disc_days_tolerance
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Disc_Days_Tolerance;

FUNCTION Get_Netting_Allowed (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..netting_allowed%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT netting_allowed
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   IF (NOT Company_Finance_API.Is_User_Authorized(company_)) THEN
      RETURN temp_;
   END IF;
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Netting_Allowed;

FUNCTION Get_Check_Recipient (
   company_ IN VARCHAR2,
   identity_ IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..check_recipient%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT check_recipient
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Check_Recipient_API.Decode(temp_);
END Get_Check_Recipient;

FUNCTION Get_Check_Recipient_Db (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..check_recipient%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT check_recipient
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Check_Recipient_Db;

FUNCTION Get_Next_Pay_Matching_Id (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   dummy_  NUMBER;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Get_Next_Pay_Matching_Id');
   dummy_ := Get_Payment_Matching_Id ( company_,
                                       identity_,
                                       party_type_ ) + 1;
   UPDATE identity_pay_info_tab
      SET next_payment_matching_id = dummy_
   WHERE  company  = company_
   AND    identity = identity_
   AND    party_type = party_type_ ;
   RETURN  dummy_ ;
END Get_Next_Pay_Matching_Id;

FUNCTION Get_Payment_Matching_Id (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   CURSOR get_matching_id   IS
   SELECT next_payment_matching_id
   FROM   &TABLE
   WHERE  company  = company_
   AND    identity = identity_
   AND    party_type = party_type_ ;

   dummy_  NUMBER;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Get_Payment_Matching_Id');
   OPEN  get_matching_id;
   FETCH get_matching_id INTO dummy_;
   CLOSE get_matching_id;

   RETURN  dummy_ ;
END Get_Payment_Matching_Id;

FUNCTION Get_Format_No (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ &TABLE..format_no%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT format_no
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   IF (NOT Company_Finance_API.Is_User_Authorized(company_)) THEN
      RETURN temp_;
   END IF;
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Format_No;

FUNCTION Get_Other_Payee_Ded_Group_Desc (
   company_           IN VARCHAR2,
   payee_identity_    IN VARCHAR2,
   party_type_        IN VARCHAR2 ) RETURN VARCHAR2
IS
   deduction_group_      VARCHAR2(20);
BEGIN
   deduction_group_ := Get_Deduction_Group(company_,
                                           payee_identity_,
                                           party_type_ );
   IF (deduction_group_ IS NULL) THEN
      RETURN NULL;
   END IF;

   RETURN Deduction_Group_API.Get_Description(company_,deduction_group_);
END Get_Other_Payee_Ded_Group_Desc;

FUNCTION Get_Deduction_Group (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..deduction_group%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT deduction_group
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   IF (NOT Company_Finance_API.Is_User_Authorized(company_)) THEN
      RETURN temp_;
   END IF;
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Deduction_Group;

FUNCTION Get_Template_Id (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..template_id%TYPE;
   CURSOR get_attr IS
      SELECT template_id
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Template_Id;

FUNCTION Get_Corporation_Id (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..corporation_id%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT corporation_id
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   IF (NOT Company_Finance_API.Is_User_Authorized(company_)) THEN
      RETURN temp_;
   END IF;
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Corporation_Id;

FUNCTION Get_Member_Id (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..member_id%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT member_id
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   IF (NOT Company_Finance_API.Is_User_Authorized(company_)) THEN
      RETURN temp_;
   END IF;
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Member_Id;

FUNCTION Get_Send_Reminder_To_Payer (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..send_reminder_to_payer%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT send_reminder_to_payer
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   IF (NOT Company_Finance_API.Is_User_Authorized(company_)) THEN
      RETURN temp_;
   END IF;
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Send_Reminder_To_Payer;

FUNCTION Get_Send_Interest_Inv_To_Payer (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..send_interest_inv_to_payer%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT send_interest_inv_to_payer
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   IF (NOT Company_Finance_API.Is_User_Authorized(company_)) THEN
      RETURN temp_;
   END IF;
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Send_Interest_Inv_To_Payer;

FUNCTION Get_Payment_Advice (
   company_ IN VARCHAR2,
   identity_ IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..payment_advice%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT payment_advice
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   IF (NOT Company_Finance_API.Is_User_Authorized(company_)) THEN
      RETURN temp_;
   END IF;
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Payment_Advice_API.Decode(temp_);
END Get_Payment_Advice;

FUNCTION Get_Payment_Advice_Db (
   company_ IN VARCHAR2,
   identity_ IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..payment_advice%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT payment_advice
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   IF (NOT Company_Finance_API.Is_User_Authorized(company_)) THEN
      RETURN temp_;
   END IF;
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Payment_Advice_Db;


FUNCTION Get_Other_Payee_Identity (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_  Public_Rec;
BEGIN
   temp_ := Get(company_, identity_, Party_Type_API.Encode(party_type_));
   RETURN temp_.other_payee_identity;
END Get_Other_Payee_Identity;

FUNCTION Get_Interest_Template (
   company_    IN VARCHAR2,
   identity_ IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_  Public_Rec;
BEGIN
   temp_ := Get(company_, identity_, Party_Type_API.Encode(party_type_));
   RETURN temp_.interest_template;
END Get_Interest_Template;

FUNCTION Get_Reminder_Template (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ Public_Rec;
BEGIN
   temp_ := Get(company_, identity_, Party_Type_API.Encode(party_type_));
   RETURN temp_.reminder_template;
END Get_Reminder_Template;

FUNCTION Get_Rule_Id (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..rule_id%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT rule_id
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   IF (NOT Company_Finance_API.Is_User_Authorized(company_)) THEN
      RETURN temp_;
   END IF;
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Rule_Id;

FUNCTION Get_Payment_Receipt_Type (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..payment_receipt_type%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT payment_receipt_type
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN Payment_Receipt_Type_API.Decode(temp_);
END Get_Payment_Receipt_Type;

FUNCTION Get_Payment_Receipt_Type_Db (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ &TABLE..payment_receipt_type%TYPE;
   CURSOR get_attr (party_type_db_ IN VARCHAR2) IS
      SELECT payment_receipt_type
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   OPEN get_attr(Party_Type_API.Encode(party_type_));
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Payment_Receipt_Type_Db;

PROCEDURE Instance_Exists (
   info_       OUT VARCHAR2,
   company_    IN  VARCHAR2,
   identity_   IN  VARCHAR2,
   party_type_ IN  VARCHAR2 )
IS
   CURSOR getrec (party_type_db_ IN VARCHAR2) IS
      SELECT '1'
      FROM   &TABLE
      WHERE  company    = company_
      AND    identity   = identity_
      AND    party_type = party_type_db_;
   lu_rec_ getrec%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Instance_Exists');
   OPEN getrec(Party_Type_API.Encode(party_type_));
   FETCH getrec INTO lu_rec_;
   IF (getrec%FOUND) THEN
      info_ := 'TRUE';
   ELSE
      info_ := 'FALSE';
   END IF;
   CLOSE getrec;
END Instance_Exists;

PROCEDURE Create_Party_Type_Id (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 )
IS
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Create_Party_Type_Id');
   Create_Identity_Pay_Info(company_, identity_, party_type_);
END Create_Party_Type_Id;

PROCEDURE Create_Identity_Pay_Info (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 )
IS
   info_             VARCHAR2(2000);
   objid_            &VIEW..objid%TYPE;
   objversion_       &VIEW..objversion%TYPE;
   attr_             VARCHAR2(2000);
   def_template_     VARCHAR2(20);
   nodefinteresttemp EXCEPTION;
   nodefremindertemp EXCEPTION;
   party_type_db_    &TABLE..party_type%TYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Create_Identity_Pay_Info');

   party_type_db_ := Party_Type_API.Encode(party_type_);

   New__(info_, objid_, objversion_, attr_, 'PREPARE');
   Client_SYS.Add_To_Attr('COMPANY', company_, attr_);
   Client_SYS.Add_To_Attr('IDENTITY', identity_, attr_);
   Client_SYS.Add_To_Attr('PARTY_TYPE', party_type_, attr_);
   IF (party_type_db_ = 'SUPPLIER') THEN
      Client_SYS.Add_To_Attr('BLOCKED_FOR_PAYMENT', 'FALSE', attr_);
      Client_SYS.Add_To_Attr('PRIORITY', 1, attr_);
      Client_SYS.Add_To_Attr('CHECK_RECIPIENT', 'PAYEE', attr_);
   ELSIF (party_type_db_ = 'CUSTOMER') THEN
      def_template_ := Interest_Template_API.Get_Default_Template(company_);
      IF (def_template_ IS NULL) THEN
         RAISE nodefinteresttemp;
      ELSE
         Client_SYS.Add_To_Attr('INTEREST_TEMPLATE', def_template_, attr_);
      END IF;
      def_template_ := Reminder_Template_API.Get_Default_Template(company_);
      IF (def_template_ IS NULL) THEN
         RAISE nodefremindertemp;
      ELSE
         Client_SYS.Add_To_Attr('REMINDER_TEMPLATE', def_template_, attr_);
      END IF;
      IF Company_Invoice_Info_API.Get_Use_Tax_Invoice(company_) = 'TRUE' THEN
         Client_SYS.Add_To_Attr('PAYMENT_RECEIPT_TYPE_DB', 'AT_MATCHING', attr_);
      ELSE
         Client_SYS.Add_To_Attr('PAYMENT_RECEIPT_TYPE_DB', 'NO_RECEIPT', attr_);
      END IF;
   END IF;
   New__(info_, objid_, objversion_, attr_, 'DO');
EXCEPTION
   WHEN nodefremindertemp THEN
      Error_SYS.Record_General(lu_name_, 'NODEFREMINDERTEMP: There is no default reminder template defined');
   WHEN nodefinteresttemp THEN
      Error_SYS.Record_General(lu_name_, 'NODEFINTERESTTEMP: There is no default interest template defined');
END Create_Identity_Pay_Info;

FUNCTION Validate_Identity (
   company_    IN VARCHAR2,
   party_type_ IN VARCHAR2,
   identity_   IN VARCHAR2 ) RETURN VARCHAR2
IS
   dummy_ NUMBER;
   CURSOR exist_identity (party_type_db_ IN VARCHAR2) IS
      SELECT 1
      FROM   &TABLE
      WHERE  company    = company_
      AND    party_type = party_type_db_
      AND    identity   = identity_ ;
BEGIN
   OPEN exist_identity(Party_Type_API.Encode(party_type_));
   FETCH exist_identity INTO dummy_;
   IF (exist_identity %FOUND) THEN
      CLOSE exist_identity ;
      RETURN('TRUE');
   END IF;
   CLOSE exist_identity ;
   RETURN('FALSE');
END Validate_Identity;

PROCEDURE Fetch_Tolerance (
   amount_tolerance_   OUT NUMBER,
   percent_tolerance_  OUT NUMBER,
   company_            IN VARCHAR2,
   identity_           IN VARCHAR2,
   party_type_         IN VARCHAR2,
   currency_           IN VARCHAR2,
   curr_rate_          IN NUMBER,
   conv_factor_        IN NUMBER,
   date_               IN DATE,
   action_             IN VARCHAR2 )
IS
   acc_currency_              VARCHAR2(20);
   div_factor_                NUMBER;
   amount_tolerance_acc_curr_ NUMBER;
   currency_rate_             NUMBER;
   dummy_                     VARCHAR2(5);
   party_type_db_             VARCHAR2(20);

   CURSOR get_identity_tolerance_ IS
      SELECT percent_tolerance, amount_tolerance
      FROM   &TABLE
      WHERE  company = company_
      AND    identity = identity_
      AND    party_type = party_type_db_;

   CURSOR get_company_tolerance_ IS
      SELECT percent_tolerance, amount_tolerance
      FROM   COMPANY_PAY_INFO_TAB
      WHERE  company = company_;

BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Fetch_Tolerance');

   party_type_db_ := Party_Type_API.Encode(party_type_);

   IF party_type_db_ = 'CUSTOMER' THEN
       OPEN  get_identity_tolerance_;
       FETCH get_identity_tolerance_  INTO percent_tolerance_, amount_tolerance_acc_curr_;
       CLOSE get_identity_tolerance_;

   -- general payment tolerance
      IF percent_tolerance_ IS NULL AND amount_tolerance_acc_curr_ IS NULL THEN
         OPEN  get_company_tolerance_;
         FETCH get_company_tolerance_  INTO percent_tolerance_, amount_tolerance_acc_curr_;
         CLOSE get_company_tolerance_;
      END IF;

   ELSIF party_type_db_ = 'SUPPLIER' THEN
   -- general payment tolerance
         OPEN  get_company_tolerance_;
         FETCH get_company_tolerance_  INTO percent_tolerance_, amount_tolerance_acc_curr_;
         CLOSE get_company_tolerance_;
   END IF;

   IF action_ = 'NOCALCULATE' THEN
      amount_tolerance_ := amount_tolerance_acc_curr_;
      RETURN;
   END IF;

   acc_currency_ := Company_Finance_API.Get_Currency_Code(company_);

   IF acc_currency_ = currency_ THEN
      amount_tolerance_ := amount_tolerance_acc_curr_;
      RETURN;
   END IF;
   div_factor_:= conv_factor_;
   currency_rate_ := curr_rate_;
   IF ( (div_factor_ IS NULL) OR (currency_rate_ IS NULL)) THEN
      Payment_Library_API.Get_Currency_Rate(
         currency_rate_,
         div_factor_,
         dummy_,
         dummy_,
         company_,
         currency_,
         NVL( date_, sysdate),
         NULL,
         party_type_db_,
         identity_
         );
   END IF;
   IF (date_ IS NOT NULL) AND ((div_factor_ IS NULL) OR (currency_rate_ IS NULL)) THEN
      Payment_Library_API.Get_Currency_Rate(
         currency_rate_,
         div_factor_,
         dummy_,
         dummy_,
         company_,
         currency_,
         sysdate,
         NULL,
         party_type_db_,
         identity_
         );
   END IF;

   Payment_Library_API.Recalculate_To_Curr_Round(
      amount_tolerance_,
      company_,
      amount_tolerance_acc_curr_,
      curr_rate_,
      div_factor_,
      currency_);
END Fetch_Tolerance;

PROCEDURE Copy_Payway_Per_Identity___ (
   company_               IN VARCHAR2,
   identity_              IN VARCHAR2,
   party_type_db_         IN VARCHAR2,
   new_identity_          IN VARCHAR2 )
IS
   CURSOR get_pay_way IS
      SELECT *
      FROM   PAYMENT_WAY_PER_IDENTITY_TAB
      WHERE  company    = company_
        AND  identity   = identity_
        AND  party_type = party_type_db_;
BEGIN
   FOR pay_way_ IN get_pay_way LOOP
        INSERT INTO PAYMENT_WAY_PER_IDENTITY_TAB (company, identity, party_type,
                                                  way_id, default_payment_way, rowversion )
               VALUES (pay_way_.company, new_identity_, pay_way_.party_type,
                       pay_way_.way_id, pay_way_.default_payment_way, 1 );
   END LOOP;
END Copy_Payway_Per_Identity___;

PROCEDURE Copy_Payment_Address___ (
   company_               IN VARCHAR2,
   identity_              IN VARCHAR2,
   party_type_db_         IN VARCHAR2,
   new_identity_          IN VARCHAR2 )
IS
   CURSOR get_pay_addr IS
      SELECT *
      FROM   PAYMENT_ADDRESS_TAB
      WHERE  company    = company_
        AND  identity   = identity_
        AND  party_type = party_type_db_;
BEGIN
   FOR pay_addr_ IN get_pay_addr LOOP
      -- Bug 72177, Begin, Added bic_code
      INSERT INTO PAYMENT_ADDRESS_TAB (company, identity, party_type, way_id,
                                       address_id,description, default_address,
                                       data1, data2, data3, data4, data5, data6,
                                       data7, data8, data9, data10, data11, data12,
                                       data13, data14, data15, data16, data17, data18,
                                       data19, data20, data21, data22,
                                       account, bic_code, rowversion, rowtype )
             VALUES (pay_addr_.company, new_identity_, pay_addr_.party_type, pay_addr_.way_id,
                     pay_addr_.address_id,
                     pay_addr_.description, pay_addr_.default_address,
                     pay_addr_.data1, pay_addr_.data2, pay_addr_.data3,
                     pay_addr_.data4, pay_addr_.data5, pay_addr_.data6,
                     pay_addr_.data7, pay_addr_.data8, pay_addr_.data9,
                     pay_addr_.data10, pay_addr_.data11, pay_addr_.data12,
                     pay_addr_.data13, pay_addr_.data14, pay_addr_.data15,
                     pay_addr_.data16, pay_addr_.data17, pay_addr_.data18,
                     pay_addr_.data19, pay_addr_.data20, pay_addr_.data21,
                     pay_addr_.data22,pay_addr_.account, pay_addr_.bic_code, 1, pay_addr_.rowtype );
      -- Bug 72177, End

   END LOOP;
END Copy_Payment_Address___;

PROCEDURE Copy_Customer (
   customer_identity_old_ IN VARCHAR2,
   customer_identity_new_ IN VARCHAR2,
   company_               IN VARCHAR2 )
IS
   CURSOR get_customer IS
      SELECT *
      FROM   IDENTITY_PAY_INFO_TAB
      WHERE  identity   = customer_identity_old_
        AND  company    = company_
        AND  party_type = 'CUSTOMER';

   CURSOR get_credit_info IS
      SELECT *
      FROM   CUSTOMER_CREDIT_INFO_TAB
      WHERE  identity = customer_identity_old_
        AND  company = company_;

   format_no_ NUMBER;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Copy_Customer');
   FOR customer_ IN get_customer LOOP
      format_no_ := Get_Next_Format_No___ (company_);
      -- Bug 73125, Begin, Added template_id 
      INSERT INTO IDENTITY_PAY_INFO_TAB (company, identity, party_type,
                                         reminder_template, interest_template, payment_delay,
                                         amount_tolerance, percent_tolerance, disc_days_tolerance,
                                         netting_allowed, format_no, payment_advice,
                                         deduction_group, corporation_id,
                                         other_payee_identity, member_id,
                                         send_reminder_to_payer, send_interest_inv_to_payer,
                                         payment_receipt_type,send_statement_of_acc_to_payer ,
                                         next_payment_matching_id,
                                         template_id,rowversion )
             VALUES (customer_.company, customer_identity_new_, 'CUSTOMER',
                     customer_.reminder_template, customer_.interest_template, customer_.payment_delay,
                     customer_.amount_tolerance, customer_.percent_tolerance, customer_.disc_days_tolerance,
                     customer_.netting_allowed, format_no_, customer_.payment_advice,
                     customer_.deduction_group, customer_.corporation_id,
                     customer_.other_payee_identity, customer_.member_id,
                     customer_.send_reminder_to_payer, customer_.send_interest_inv_to_payer,
                     customer_.payment_receipt_type,
                     customer_.send_statement_of_acc_to_payer, 1,
                     customer_.template_id,1 );
      -- Bug 73125, End


      Copy_Payway_Per_Identity___( customer_.company,
                                   customer_identity_old_,
                                   'CUSTOMER',
                                   customer_identity_new_ );
      Copy_Payment_Address___( customer_.company,
                               customer_identity_old_,
                               'CUSTOMER',
                               customer_identity_new_ );
   END LOOP;

   FOR credit_ IN get_credit_info LOOP
      INSERT INTO CUSTOMER_CREDIT_INFO_TAB (company, identity, last4q_sales,
                                            note_text, credit_number, credit_rating, avg_days_for_payment,
                                            credit_comments,credit_limit,credit_block,
                                            next_review_date,corp_credit_relation_exist,
                                            credit_relationship_type,message_type,
                                            party_type,parent_identity,parent_company,
                                            credit_analyst_code,rowversion )
             VALUES (credit_.company, customer_identity_new_, credit_.last4q_sales,
                     credit_.note_text, credit_.credit_number, credit_.credit_rating, credit_.avg_days_for_payment,
                     credit_.credit_comments,credit_.credit_limit,credit_.credit_block,
                     credit_.next_review_date,'FALSE',
                     NULL,credit_.message_type,
                     credit_.party_type,NULL,NULL,
                     credit_.credit_analyst_code, sysdate );
   END LOOP;
END Copy_Customer;

PROCEDURE Copy_Supplier (
   supplier_identity_old_ IN VARCHAR2,
   supplier_identity_new_ IN VARCHAR2,
   company_               IN VARCHAR2 )
IS
   CURSOR get_supplier IS
      SELECT *
      FROM   IDENTITY_PAY_INFO_TAB
      WHERE  identity   = supplier_identity_old_
        AND  company    = company_
        AND  party_type = 'SUPPLIER';

   attr_       VARCHAR2(2000);
   info_       VARCHAR2(2000);
   objid_      VARCHAR2(2000);
   objversion_ VARCHAR2(2000);
   format_no_  NUMBER;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Copy_Supplier');
   FOR supplier_ IN get_supplier LOOP
      format_no_ := Get_Next_Format_No___ (company_);
      -- Bug 73125, Begin, Added template_id 
      INSERT INTO IDENTITY_PAY_INFO_TAB (company, identity, party_type,
                                         priority, blocked_for_payment,
                                         reminder_template, interest_template,
                                         amount_tolerance, percent_tolerance,
                                         netting_allowed, format_no,
                                         payment_advice, next_payment_matching_id,check_recipient,
                                         template_id, rowversion )
             VALUES (supplier_.company, supplier_identity_new_, 'SUPPLIER',
                     supplier_.priority, supplier_.blocked_for_payment,
                     supplier_.reminder_template, supplier_.interest_template,
                     supplier_.amount_tolerance, supplier_.percent_tolerance,
                     supplier_.netting_allowed,  format_no_,
                     supplier_.payment_advice, 1, supplier_.check_recipient,
                     supplier_.template_id,1 );
      -- Bug 73125, End
      Copy_Payway_Per_Identity___( supplier_.company,
                                   supplier_identity_old_,
                                   'SUPPLIER',
                                   supplier_identity_new_ );
      Copy_Payment_Address___( supplier_.company,
                               supplier_identity_old_,
                               'SUPPLIER',
                               supplier_identity_new_ );
   END LOOP;
END Copy_Supplier;

FUNCTION Get (
   company_       IN VARCHAR2,
   identity_      IN VARCHAR2,
   party_type_db_ IN VARCHAR2 ) RETURN Public_Rec
IS
   temp_ Public_Rec;
   CURSOR get_attr IS
      SELECT priority, blocked_for_payment, other_payee_identity, interest_template, reminder_template,payment_delay,
             amount_tolerance, percent_tolerance, disc_days_tolerance, netting_allowed, format_no, payment_advice,
             deduction_group,corporation_id,member_id,send_reminder_to_payer,send_interest_inv_to_payer,payment_receipt_type, 
             template_id, check_recipient, send_statement_of_acc_to_payer
      FROM &TABLE
      WHERE company = company_
      AND   identity = identity_
      AND   party_type = party_type_db_;
BEGIN
   IF (NOT Company_Finance_API.Is_User_Authorized(company_)) THEN
      RETURN temp_;
   END IF;

   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get;

PROCEDURE User_Allowed___(
   company_   IN VARCHAR2)
IS
  fnd_user_  VARCHAR2(2000);

BEGIN

  fnd_user_ := Fnd_Session_API.Get_Fnd_User;

  IF NOT (company_finance_api.Is_User_Authorized(company_)) then
        Error_SYS.Appl_General(lu_name_,'NOTUSERALLOWED: User :P1 is not allowed to use Company :P2',fnd_user_,company_);
  END IF;

END User_Allowed___;


-- --------------------------------------------------------------------------
-- Server-side functions used by new report (Output Servicese)
-- --------------------------------------------------------------------------
FUNCTION Get_Group_For_Identity (
   company_               IN VARCHAR2,
   identity_              IN VARCHAR2,
   party_type_db_         IN VARCHAR2 ) RETURN VARCHAR2
IS
   CURSOR get_group IS
      SELECT group_id
      FROM   IDENTITY_INVOICE_INFO
      WHERE  company = company_
        AND  identity = identity_
        AND  party_type_db = party_type_db_ ;
   group_id_       VARCHAR2(20);
BEGIN
   OPEN  get_group;
   FETCH get_group INTO group_id_;
   IF (get_group%NOTFOUND) THEN
      CLOSE get_group;
      RETURN NULL;
   END IF;
   CLOSE get_group;

   RETURN group_id_;
END Get_Group_For_Identity;

PROCEDURE Make_Company (
   attr_         IN VARCHAR2 )
IS
   rec_        Enterp_Comp_Connect_V160_API.Crecomp_Lu_Public_Rec;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Make_Company');

   rec_ := Enterp_Comp_Connect_V160_API.Get_Crecomp_Lu_Rec('&MODULE', attr_);

   IF (rec_.make_company = 'EXPORT') THEN
      Export___(rec_);
   ELSIF (rec_.make_company = 'IMPORT') THEN
      IF (rec_.action = 'NEW') THEN
         Import___(rec_);
      ELSIF (rec_.action = 'DUPLICATE') THEN
         Copy___(rec_);
      END IF;
   END IF;
END Make_Company;

FUNCTION Cust_Open_Items_Exist (
   company_ 	IN VARCHAR2,
   identity_ 	IN VARCHAR2 ) RETURN VARCHAR2
IS
   dummy_ NUMBER;
   CURSOR exist_control IS
      SELECT 1
      FROM   LEDGER_ITEM_TAB
      WHERE  company = company_
      AND    identity = identity_
      AND    (payer_identity IS NOT NULL AND payer_identity != identity)
      AND    ledger_status_type = 'NORMAL'
      AND   ((fully_paid_voucher_date IS NULL) OR
             (rowstate in ('Unpaid', 'PartlyPaid'))
             OR (rowstate in ('Created', 'BeforeDueDate', 'SentForCashing')))
      AND   (party_type = 'CUSTOMER' OR (party_type = 'COMPANY' AND parked_pay_type = 'CUSTOMER'));

BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Cust_Open_Items_Exist');
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN('TRUE');
   END IF;
   CLOSE exist_control;
   RETURN('FALSE');
END Cust_Open_Items_Exist;

FUNCTION Get_Send_Stmt_Of_Acc_To_Payer (
   company_    IN VARCHAR2,
   identity_   IN VARCHAR2,
   party_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_  Public_Rec;
BEGIN
   IF (NOT Company_Finance_API.Is_User_Authorized(company_)) THEN
      RETURN NULL;
   END IF;
   temp_ := Get(company_, identity_, Party_Type_API.Encode(party_type_));
   RETURN temp_.send_statement_of_acc_to_payer;
END Get_Send_Stmt_Of_Acc_To_Payer;
-----------------------------------------------------------------------------
-------------------- FOUNDATION1 METHODS ------------------------------------
-----------------------------------------------------------------------------
-- Init
--   Dummy procedure that can be called at database startup to ensure that
--   this package is loaded into memory for performance reasons only.
-----------------------------------------------------------------------------

PROCEDURE Init
IS
BEGIN
   NULL;
END Init;


END &PKG;
/
SHOW ERROR

-----------------------------------------------------------------------------

----------------------------------------------------------
-- <UNDEFINE_SECTION>
----------------------------------------------------------
-- This section is reserved for undefine statements
-- nothing should be manually written below because
-- that would be overwritten everytime the IFS / Undefine
-- tool is run.
-- Also do NOT make any changes to the above tag because
-- this will result in duplicated code
----------------------------------------------------------
UNDEFINE MODULE
UNDEFINE LU
UNDEFINE TABLE

UNDEFINE VIEW
UNDEFINE VIEWPCT
UNDEFINE VIEW_SU_QRY
UNDEFINE VIEW_CU_QRY
UNDEFINE VIEW_SUPP
UNDEFINE VIEW_CUST
UNDEFINE VIEW_MULTI_CUST
UNDEFINE VIEW_MULTI_SUP
UNDEFINE VIEW_LOV
UNDEFINE VIEW_ALL
UNDEFINE VIEW_MULTI_CUS
UNDEFINE VIEW_MULTI_SUP
UNDEFINE VIEW_MULTI_ADD

UNDEFINE PKG
UNDEFINE OBJID
UNDEFINE OBJVERSION
UNDEFINE OBJID_PTIPI
UNDEFINE OBJVERSION_PTIPI
