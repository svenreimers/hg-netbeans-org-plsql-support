-----------------------------------------------------------------------------
--
--  Package: Dictionary_SYS
--
--  Purpose: This package creates system services for logical unit dictionary.
--           The services includes dictionary searches of various kinds and
--           decoding routines for comment strings.
--
--  IFS/Design Template Version 2.3
--
--  Date    Sign  History
--  ------  ----  -----------------------------------------------------------
--  950823  STLA  Created.
--  950901  STLA  Corrected fetch of enumerated lu list.
--  950901  STLA  Searches methods from user_source instead of sys.argument$.
--  950904  ERFO  Separator fetched from Client_SYS and standard changes.
--  950905  ERFO  Rearrangements in method orders, change headings...
--  950905  ERFO  Changed separator character in Enumerate_Logical_Units_
--                and Enumerate_Data_Items_.
--  950911  STLA  Removed last call to sys.argument$
--  950912  STLA  Added funtion to get item prompt
--  950912  STLA  Modified fetch of views and packages belonging to a LU
--  950915  STLA  Added funtion to get lu view for list of values
--  950926  STLA  Removed picture option from DATATYPE comments
--  950927  STLA  Added method to fetch list of system services
--  950928  STLA  Added method to fetch description for logical unit
--  950928  STLA  Added method to fetch list of domains (eg IIDs)
--  951005  STLA  Added backwards compatibility for Get_Lu_View_
--                Added method Get_Logical_Unit_Ref_Methods_
--  951005  BOIS  Corrected into variable length in Get_View_Logical_Unit_
--  951006  ERFO  Removed method Get_View_Logical_Unit_
--  951006  STLA  Made Generate_<_Comment_ generate dummy comment if
--                database column is not found.
--  951006  STLA  Added foreign key methods to Enumerate_Data_Items_
--                Removed reference to Client_SYS.field_separator_
--  951030  STLA  Corrected Get_Logical_Unit_Ref_Methods_ returning
--                incorrect enumerate syntax.
--  951030  STLA  Added pragma restict_references for att methods
--  951030  STLA  Corrected Enumerate_Domains_ uninitialized variable
--  951030  STLA  Added method Get_Logical_Unit_Method_
--  951030  DAJO  Added method Get_System_Service_Properties_ for
--                system service translation support.
--  951101  ERFO  Added work-around BIGCHAR2 for Enumerate_Data_Items_
--                and Enumerate_Logical_Units_.
--  951208  STLA  Corrected method Get_Data_Item_Properties_ (Bug #283).
--  960110  STLA  Added overloaded version of Get_Logical_Unit_Properties_
--                so that grant/revoke tool can operate efficiently.
--  960111  STLA  Use of 32730 as max length for long VARCHAR2 (Bug #325).
--  960111  ERFO  Added method Activate_Language_Refresh_ to support
--                language setting changes on the fly (Idea #326).
--  960225  ERFO  Added new module property methods to support the module
--                concept within the LU-dictionary (Idea #409).
--  960319  ERFO  Added extra method for logical unit properties to support
--                new features within system service Document_SYS (Idea #463).
--  960325  ERFO  Added methods for internal dictionary storage to support
--                performance needs from IFS/Security (Idea #452).
--  960326  ERFO  Added new parent/child property methods to support relations
--                between parent and children for logical units (Idea #410).
--  960326  ERFO  Add cache techniques in LU-dictionary by sending an extra
--                in parameter which tells if the cached value, stored in a
--                package global may be used or not (Idea #466).
--  960401  ERFO  Split this package into two for deployment reasons.
--  960402  ERFO  Changed cursor in method Get_Logical_Unit_Parent_ as a
--                work-around due to a PL/SQL bug in Oracle 7.1.
--  960404  ERFO  Two new facilities in method Comment_Value_ to support NULL-
--                values in a comment string and to support ambigous key names
--                in a comment sting to support IFS/Info Services.
--  960404  ERFO  Changes to be ORACLE 7.3 compliant (Bug #473).
--  960415  ERFO  Changes in method Enumerate_Data_Items to retrieve package
--                name information by using name conventions instead of using
--                the LU-dictionary for optimal performance in the dialog for
--                Foundation Properties (Idea #491).
--  960429  ERFO  Changes in old method Enumerate_System_Services_ and added
--                PRAGMA-option WNPS where possible.
--  960503  STLA  Make Get_Data_Item_Properties_ do exception when column
--                not found.
--  960506  ERFO  Added dummy parameter to method Rebuild_Dictionary_Storage.
--                Removed use of field separator in beginning of the package
--                and view list columns in Rebuild_Dictionary_Storage and
--                added a special filter for company styled global keys.
--                Added parent child relationship by name convention for
--                IID-domains and ordinary logical units.
--  960508  ERFO  Added implementation method Method_Security_Enabled__ to
--                ensure correct security handle of package methods.
--  960517  ERFO  Fixed BIGCHAR2 problem by changing to VARCHAR2 (Bug #607).
--                Changed representation and logic in dictionary help table
--                to support very big logical units (Bug #611).
--                Added method Init to the list of non-security methods.
--  960528  ERFO  Changed order of close cursor in help method.
--  960610  ERFO  Changes in method Enum_Modules_ not to be case-sensitive
--                in the short name of the module identity (Bug #663).
--  960612  ERFO  Rearrangements and performance improvements in method
--                Rebuild_Dictionary_Storage_ to support all kinds of PL/SQL
--                without depending on too much name conventions in the way of
--                using the language (Bug #664).
--  960819  ERFO  Changes in Activate_Language_Refresh_ to improve performance
--                when searching for translation candidates (Idea #746).
--  960826  ERFO  Increased size of method variable in the implementation
--                of Rebuild_Dictionary_Storage_ (Bug #768).
--  960827  MANY  Changes in Enumerate_System_Services_, now performs a distinct
--                list of services (Bug #769).
--                Changes in Get_System_Service_Properties_, now returns a list
--                of packages (Bug #769).
--  960911  ERFO  Added error handling for occasions when using illegal module
--                name in logical unit source code package header (Idea #790).
--  960916  ERFO  Decreased result set for all cursor against package globals
--                in the view USER_SOURCE for optimal performance (Idea #798).
--  960919  ERFO  Rearrangements in Rebuild_Dictionary_Storage concerning
--                methods without any parameters.
--  961028  MANY  Changes in several locations, including Rebuild_Dictionary_Storage
--                and Get_Logical_Unit_Properties to ensure that reports are treated
--                correctly within the dictionary.
--  961029  ERFO  Added method Get_Logical_Unit_Keys_ to retrieve key names and/or
--                values for a specific logical unit instance (Idea #845).
--  961029  ERFO  Even more performance improvements in LU-dictionary (Idea #798)
--                and adjustments in Rebuild_Dictionary_Storage_.
--  961116  ERFO  Ensure that the conversion methods between db and client
--                names does not result in any exception (Bug #859).
--  961117  ERFO  Removed method Lock__ from being security aware.
--  961118  ERFO  Solve problem with naming conflicts in IFS/Accounting Rules.
--  961125  ERFO  Language change on the fly for client state values and added
--                state methods in function Method_Security_Enabled___.
--  961128  ERFO  Add filter to remove Foundation1 modules from IFS/Security
--                and corrected view problem in Get_Logical_Unit_Ref_Methods.
--  970122  ERFO  Solved problem with timestamp on the security cache after
--                that the Foundation1-modules being removed (Bug #944).
--  970127  ERFO  Illegal OR-statement in Get_Lov_View_ corrected to avoid
--                returning view connected to IFS/Info Services (Bug #957).
--  970212  ERFO  Correction in Get_Lu_Prompt_ to choose the first view
--                found instead of choosing the last one (Bug #977).
--  970213  ERFO  Add refresh of document dictionary info (Bug #985).
--  970403  ERFO  Removed third parameter in method Comment_Value_.
--  970424  ERFO  Changes in method Enumerate_Data_Items_ to include
--                more functions in the pseudo column list (Bug #1035).
--  970507  ERFO  Removed unused methods from the package (ToDo #1107).
--  970725  DOZE  Added method Get_Logical_Unit_Tables_ for history (ToDo #1109).
--  970825  ERFO  Re-installed Foundation1 modules in dictionary cache.
--  970826  ERFO  Solved problem in Rebuild_Dictionary_Storage_ when having
--                LU reference definitions longer than 100 bytes (Bug #1610).
--  971022  ERFO  Refresh only be run as application owner (ToDo #1286).
--                Removed additional refresh of Document_SYS cache.
--  971124  ERFO  Changes in Generate_Function_Comment___ to get correct
--                function data type to Foundation1 Properties (Bug #718).
--  971218  ERFO  String length is changed from 20 to 200 in method
--                Generate_Default_Comment to solve IID limits.
--  971218  ERFO  Added method Get_Data_Source_Properties__ and method
--                Get_Data_Item_Properties__ supporting the new SORT-flag
--                for view order-by clauses (ToDo #1633).
--  980211  DOZE  Added method Enum_Table_Columns_ for IFS/Design (ToDo #1867).
--  980418  ERFO  Correction in Activate_Language_Refresh_ (Bug #2365).
--  980504  ERFO  Oracle8-compliance in exception handle (Bug #2412).
--  980505  MANY  Correction in Activate_Language_Refresh_ (Bug #2365), continue
--                looping when error in specific package until all are finished.
--  980211  DOZE  Changed Enum_Table_Columns_ (Bug #2569).
--  980909  MANY  Changed Activate_Language_Refresh_ to only refresh packages
--                that are actually initiated within the active session (Bug #2685)
--  980915  ERFO  Reinstalled old version of Activate_Language_Refresh (Bug #2685).
--  981013  ERFO  Added method Enumerate_Logical_Units__ and reorganization
--                in Rose-model and model properties (ToDo #2774).
--  981207  DOZE  Removed part of Enumerate_Data_Items_ (Bug #2918)
--  990216  ERFO  Correction in Method_Security_Enabled___ to ensure that no
--                methods will be removed from the security tool (Bug #3141).
--  990222  ERFO  Yoshimura: Changes in Rebuild_Dictionary_Storage_ (ToDo #3160).
--  990428  ERFO  Rebuild performance and logical bug fixes (Bug #3333).
--  990605  ERFO  Change cursor in Activate_Language_Refresh_ (Bug #3411).
--  990805  ERFO  Added column METHOD_LIST2 to include large LU:s (ToDo #3365).
--  990922  ERFO  Added method Exist_Db in cursor in Rebuild (Bug #3590).
--  991005  DOZE  Translation between "Ifs Currency" and "IFS Currency" (Bug #3575)
--  000301  ERFO  Added cursor for pragma-methods in Rebuild-logic (Todo #3846).
--  000405  ERFO  Added resolve-operation for Security 2001 (ToDo #3846).
--  000522  ROOD  Performance improvements in Rebuild_Dictionary_Storage_.  (ToDo #3894).
--  000823  ROOD  Added condition for appowner in Get_Logical_Unit_Tables_ (ToDo #3919).
--  001211  ERFO  Added view FND_TAB_COMMENTS and use it in this package (Bug #18619).
--  001214  ERFO  Removed ACCRUL-specific code in Rebuild-procedure (ToDo #3973).
--  010926  ROOD  Added check not null on inparameters in most get-methods (Bug#22111).
--  011014  ROOD  Made Rebuild_Dictionary_Storage_ ignore case and comments (Bug#25453).
--  011122  ROOD  Added view FND_COL_COMMENTS and used it in this package (Bug #26328).
--  020115  ROOD  Moved views to api-file to avoid installation dependencies (Bug #26328).
--  020527  ROOD  Added group by statements to work around Oracle bug in
--                Rebuild_Dictionary_Storage_ (Bug#29242).
--  020628  ROOD  Corrected usage of General_SYS.Init_Method (ToDo#4087).
--  030212  ROOD  Changed module to FNDBAS (ToDo#4149).
--  030317  ROOD  Replaced General_SYS.Get_Database_Properties with
--                Database_SYS.Get_Database_Properties (ToDo#4143).
--  030502  ROOD  Enabled dictionary information for system services (ToD0#4259).
--  030613  ROOD  Rebuilt the Get_Logical_Unit_Properties_xx methods (ToDo#4162).
--  030623  ROOD  Added public methods for runtime dictionary information support.
--                These methods replace equivalents in Transaction_SYS (ToDo#4162)
--  030819  ROOD  Trimmed whitespaces to the right for methods with pragma
--                in method Rebuild_Dictionary_Storage_ (ToDo#4160).
--  030931  HAAR  Obsoleted method Activate_Language_Refresh_ (ToDo#4305).
--  040407  HAAR  Unicode bulk changes,
--                extended define variable length in Get_Logical_Unit_Keys_ (F1PR408B).
--  040507  HAAR  Added Get_Logical_Unit and Get_Logical_Unit_ (F1PR419).
--  040607  ROOD  Added views for dictionary information (F1PR413).
--  040609  HAAR  Changes in Rebuild_Dictionary_Storage_ due to changed behavior in Oracle10g (Bug#44668).
--  040617  ROOD  Removed obsolete interfaces and restructured the implementation.
--                Moved all methods needed in Design-time to new system service
--                Design_SYS (F1PR413).
--  040907  ROOD  Increased the amount of information stored in the dictionary cache, regarding
--                view comments etc. Used new information in implementation.
--                Changed interface Get_Item_Prompt_, renamed Get_Main_View to Get_Base_View,
--                removed Get_Lov_View_ (F1PR413).
--  040908  ROOD  Increased the length for column_reference and added exception handling
--                for extraction of view column comments (F1PR413).
--  040910  ROOD  Changed default values for when column prompts couldn't be evaluated (F1PR413).
--  040916  ROOD  Avoided partial delete of column values if not necessary and other
--                performance improvements (F1PR413).
--  040923  ROOD  Added refresh mode. Made Get_Base_View_ public (F1PR413).
--  041025  ROOD  Modified date comparison in Rebuild_Dictionary_Storage_ and
--                Check_Dictionary_Storage_ to workaround date problems with Unicode (Call#119047).
--  041221  ROOD  Rewrote major parts of Rebuild_Dictionary_Storage_ to add more information
--                into LU dictionary and to improve performance (F1PR413).
--  041228	ROOD  Moved all views to api-file to indicate that they are public (F1PR413).
--  050105  ROOD  Changed values for view type in dictionary_sys_view_tab (F1PR413).
--  050111  JORA  Added view (dictionary_sys_state_event) for states  (F1PR413).
--  050117  JORA  Added view (dictionary_sys_state_trans) for states transitions (F1PR413).
--  050128  JORA  Moved lu_sub_type from  dictionary_sys_tab
--                to dictionary_sys_package_tab (F1PR413).
--  050310  HAAR  Added printout for LU names longer than 25 characters (F1PR480).
--  050408  JORA  Added assertion for dynamic SQL.  (F1PR481)
--  050513  JORA  Added Rebuild_State_Machine___. (F1PR413D)
--  050520  JORA  Added Get_No_Overloads, Get_No_Arguments, Get_Min_No_Arguments,
--                Get_Max_No_Arguments, Get_Argument_Type  (ESCHND-F1).
--  050706  HAAR  Removed depricated functions moved to Design_SYS (Bug#52284).
--                Enum_Modules_, Get_Logical_Unit_Properties_, Get_Data_Source_Properties_
--                Get_Data_Item_Properties_, Get_Logical_Unit_Method_ and Enum_Table_Columns_.
--  050818  JORA  Improved error msg for Rebuild_State_Machine___.
--  050830  JORA  Improved performace of Rebuild_Dictionary_Storage.
--  051003  HAAR  Changed Enum_Module_Logical_Units_ to include system services (F1PR843).
--  051110  HAAR  Added new argument to Enumerate_Logical_Units__.
--  051110  HAAR  Enum_Module_All_Logical_Units_ and Get_Logical_Unit_Properties2__ added (F1PR843).
--  051111  HAAR  Changed so that the follwoing methods are treated as PRAGMA methods:
--                LOCK__, LANGUAGE_REFRESHED, INIT, FINITE_STATE_DECODE__, ENUMERATE_STATES__,
--                FINITE_STATE_EVENTS__, ENUMERATE_EVENTS__, 'ENUMERATE', 'EXIST', 'EXIST_DB' (F1PR483).
--  051128  HAAR  Removed duplicate state values.
--  060105  UTGULK Annotated Sql injection.
--  060130  HAAR  Value error in Rebuild_Dictionary_Storage_ (Call 131508).
--  060426  HAAR  Added support for query against ROWSTATE instead of STATE when possible (Bug#57581).
--  060428  HAAR  Fixed problem in Rebuild_Dictionary_Storage_ when using Oracle 10.2.0.2 (Bug#57648).
--  070111  HAAR  Reroute xxx_Is_Installed methods to Database_SYS methods during Installation.
--                Added method Set_Installation_Mode (Bug#61829).
--  080208  HAAR  Added update of Cache Management when refreshing the cache (Bug#71136).
--  080304  HAAR  Some changes in refresh of cache (Bug#72156):
--                - Packages with errors or used for test can cause our tools to refresh all the time.
--                - Only consider packages with extension _API, _RPI and _SYS.
--                - Make error texts available in out parameter.
--                - Search Domain packages are not considered during the refresh of the Dictionary cache.
--                - Return errors in CLOB out variable.
--  080901  HASPLK Correcetd method Clientnametodbname to work with 30 characters long View names.
--  090309  HASPLK Added method Get_Installation_Mode (Bug#81092).
--  090312  HAAR  Changed so that Check_Method_From_View___ loops over all packages. (Bug#81246).
--                Changed so that ordering of packages in dictionary_sys_package_tab always is sorted in _API , _RPI, _SYS.
--  100324  UsRa  Changed Rebuild_Dictionary_Storage___ to include a new way to locate the base view of an LU (Bug#89730).
--  100531  ChMu  Changed Refresh_Domain_State_Info___ and Tokenize_Lists___.(Bug#90304-Correction not to Patched into Next Core)  
--  100531  GeGu  Modified Rebuild_Dictionary_Storage___ clear the middle tire cache as well
--  100603  ChMu  Modified Tokenize_Lists___ to remove '||' from domain/state information
-----------------------------------------------------------------------------
--
--  Contents:  Property fetching routines for run-time use (private)
--             Naming conversions for client versus database object names
--             Comment decoding routines for LU-dictionary
--             Prompt fetching routines, mainly used for localization
--             Property fetching routines for run-time use (protected)
--             Runtime performance refreshment routines
--             Property fetching routines for design-time use (Depreciated)
--             Public runtime methods for dictionary information support
--
-----------------------------------------------------------------------------

DEFINE MODULE        = FNDBAS
DEFINE SERVICE       = Dictionary
DEFINE PKG           = DICTIONARY_SYS

-----------------------------------------------------------------------------
-------------------- PACKAGES FOR METHODS -----------------------------------
-----------------------------------------------------------------------------

PROMPT Creating &PKG implementation

CREATE OR REPLACE PACKAGE BODY &PKG IS

TYPE lu_struct_type IS TABLE OF VARCHAR2(32000) INDEX BY BINARY_INTEGER;
TYPE object_array IS TABLE OF VARCHAR2(30) INDEX BY BINARY_INTEGER;

field_separator_ CONSTANT VARCHAR2(1)     := Client_SYS.field_separator_;
record_separator_ CONSTANT VARCHAR2(1)    := Client_SYS.record_separator_;
text_separator_  CONSTANT VARCHAR2(1)     := Client_SYS.text_separator_;

installation_     BOOLEAN                 := FALSE;

-----------------------------------------------------------------------------
-------------------- SERVICE SPECIFIC IMPLEMENTATION METHOD DECLARATIONS ----
-----------------------------------------------------------------------------

FUNCTION Check_Method_From_View___ (
   view_name_      IN  VARCHAR2,
   method_name_    IN  VARCHAR2 ) RETURN VARCHAR2;

-----------------------------------------------------------------------------
-------------------- SERVICE SPECIFIC IMPLEMENTATION METHODS ----------------
-----------------------------------------------------------------------------

FUNCTION Check_Method_From_View___ (
   view_name_      IN  VARCHAR2,
   method_name_    IN  VARCHAR2 ) RETURN VARCHAR2
IS
   lu_name_               VARCHAR2(30);
   package_list_          VARCHAR2(2000);
   package_name_          VARCHAR2(30);
   index_                 NUMBER;
BEGIN
   lu_name_      := Get_Logical_Unit(view_name_, 'VIEW');
   package_list_ := Get_Logical_Unit_Packages__(lu_name_);
   index_        := instr(package_list_, field_separator_);
   WHILE (index_ > 0) LOOP
      package_name_ := Substr(package_list_, 1, index_ - 1);
      package_list_ := Substr(package_list_, index_ + 1);
      IF (Method_Is_Installed(package_name_, method_name_)) THEN
         RETURN(package_name_||'.'||method_name_);
      END IF;
      index_ := instr(package_list_, field_separator_);
   END LOOP;
   RETURN(NULL);
END Check_Method_From_View___;

FUNCTION Rebuild_Dictionary_Storage___ (
   dummy_        IN NUMBER,
   refresh_mode_ IN VARCHAR2 DEFAULT 'PARTIAL',
   write_clob_   IN BOOLEAN  DEFAULT FALSE ) RETURN CLOB
IS
   refresh_all_      BOOLEAN := refresh_mode_ = 'FULL';
   refresh_views_    BOOLEAN := refresh_mode_ IN ('VIEWS', 'PARTIAL', 'LIGHT');
   refresh_pkgs_     BOOLEAN := refresh_mode_ IN ('PACKAGES', 'PARTIAL', 'LIGHT');
   rebuild_needed_   NUMBER;
   last_update_      DATE;
   start_time_       DATE;
   packages_         object_array;
   methods_          object_array;
   views_            object_array;

   pkg_lu_name_      VARCHAR2(30);
   pkg_module_       VARCHAR2(6);
   pkg_lu_type_      VARCHAR2(1);
   pkg_lu_sub_type_  VARCHAR2(1);
   pkg_index_        NUMBER;

   method_           VARCHAR2(100);

   view_lu_name_     VARCHAR2(30);
   view_module_      VARCHAR2(6);
   view_prompt_      VARCHAR2(200);
   view_comment_     VARCHAR2(2000);
   view_index_       NUMBER;
   base_view_        BOOLEAN;

   error_text_       CLOB;

   TYPE domain_states_array IS TABLE OF VARCHAR2(120) INDEX BY BINARY_INTEGER;
   db_values_        domain_states_array;
   client_values_    domain_states_array;

   TYPE complete_value_array IS TABLE OF dictionary_sys_domain_tab%ROWTYPE INDEX BY BINARY_INTEGER; -- same as dictionary_sys_state_tab...
   complete_values_  complete_value_array;

   TYPE state_event_array IS TABLE OF dictionary_sys_state_event_tab%ROWTYPE INDEX BY BINARY_INTEGER;
   state_event_values_  state_event_array;

   CURSOR get_last_update IS
      SELECT MAX(rowversion)
      FROM dictionary_sys_tab;

   --
   -- LAST_DDL_TIME:
   --    The timestamp for the last DDL change (including GRANT and REVOKE) to the object.
   --    Format is VARCHAR2(19)...
   --
   -- TIMESTAMP
   --    The timestamp for the specification of the object.
   --    Format is DATE.
   --
   -- VIEWS:
   --    TIMESTAMP for a view is not updated unless the code of the view is modified.
   --
   -- PACKAGES:
   --    TIMESTAMP for a packages is updated as soon as the package code is recompiled.
   --
   -- This is the reason why different criteria is used for views and for packages.
   -- It is necessary that views are refreshed after they have been recompiled,
   -- even if the code has not been modified, since the information is in the comments.
   --

   -- Packages to update (timestamp has changed since last update)
   CURSOR get_pkgs_to_update(last_cache_update_ IN DATE) IS
      SELECT object_name
      FROM user_objects
      WHERE object_type = 'PACKAGE BODY'
      AND substr(object_name, -4) IN ('_API', '_RPI', '_SYS')
      AND timestamp > to_char(last_cache_update_, 'YYYY-MM-DD:HH24:MI:SS')
      ORDER BY substr(object_name, -3); -- The ordering should be API, RPI, SYS

   -- Views to update (last_ddl_time has changed since last update)
   CURSOR get_views_to_update(last_cache_update_ IN DATE) IS
      SELECT object_name
      FROM user_objects
      WHERE object_type = 'VIEW'
      AND last_ddl_time > last_cache_update_
      ORDER BY created;

   -- All packages (used when doing a full refresh for performance reasons)
   CURSOR get_all_pkgs IS
      SELECT object_name
      FROM user_objects
      WHERE object_type = 'PACKAGE'
      AND substr(object_name, -4) IN ('_API', '_RPI', '_SYS')
      ORDER BY substr(object_name, -3); -- The ordering should be API, RPI, SYS

   -- All view (used when doing a full refresh for performance reasons)
   CURSOR get_all_views IS
      SELECT object_name
      FROM user_objects
      WHERE object_type = 'VIEW'
      ORDER BY created;

   -- Package information
   CURSOR get_package_info(package_name_ IN VARCHAR2) IS
      SELECT substr(text,
                    instr(text,'''')+1,
                    instr(text,'''',instr(text,'''')+1)-instr(text,'''')-1) global,
             upper(substr(ltrim(text), 1, 1)) gtype
      FROM   user_source
      WHERE  type = 'PACKAGE'
      AND    name = package_name_
      AND    (text LIKE '%lu_name_%:=%''%''%' OR text LIKE '%module_%:=%''%''%' OR text LIKE '%service_%:=%''%''%' OR text LIKE '%domain_%:=%''%''%')
      AND    text NOT LIKE '--%'
      AND    text NOT LIKE '%/%*%'
      AND    text NOT LIKE '%*%/'
      AND    line BETWEEN 2 AND 6
      ORDER BY line;

   -- View information
   CURSOR get_view_comments(view_name_ IN VARCHAR2) IS
      SELECT comments
      FROM   fnd_tab_comments
      WHERE  table_type = 'VIEW'
      AND    table_name = view_name_;

   PROCEDURE Write_Error_Text___ (
      clob_     IN OUT NOCOPY CLOB,
      text_     IN            VARCHAR2,
      new_line_ IN            BOOLEAN DEFAULT TRUE )
   IS
   BEGIN
      IF write_clob_ THEN
         IF new_line_ THEN
            clob_ := clob_ || chr(10) || text_;
         ELSE
            clob_ := clob_ || text_;
         END IF;
      ELSE
         IF new_line_ THEN
            dbms_output.put_line(text_);
         ELSE
            dbms_output.put(text_);
         END IF;
      END IF;
   END Write_Error_Text___;


   PROCEDURE Get_Next_Pkg_Index___ (
      lu_name_        IN VARCHAR2,
      next_pkg_index_ OUT NUMBER )
   IS
      CURSOR next_index IS
         SELECT nvl(MAX(package_index), 0) + 1
         FROM dictionary_sys_package_tab
         WHERE lu_name = lu_name_;
   BEGIN
      OPEN next_index;
      FETCH next_index INTO next_pkg_index_;
      CLOSE next_index;
   END Get_Next_Pkg_Index___;

   PROCEDURE Get_Next_View_Index___ (
      lu_name_         IN VARCHAR2,
      next_view_index_ OUT NUMBER )
   IS
      CURSOR next_index IS
         SELECT nvl(MAX(view_index), 0) + 1
         FROM dictionary_sys_view_tab
         WHERE lu_name = lu_name_;
   BEGIN
      OPEN next_index;
      FETCH next_index INTO next_view_index_;
      CLOSE next_index;
   END Get_Next_View_Index___;

   PROCEDURE Handle_Possible_State_Pkg___(
      lu_name_     IN VARCHAR2,
      method_name_ IN VARCHAR2 )
   IS
   BEGIN
      IF method_name_ = 'Finite_State_Events__' THEN
         -- Set global variable
         pkg_lu_sub_type_ := 'S';
         -- Update main dictionary information
         UPDATE dictionary_sys_package_tab
            SET package_type = pkg_lu_sub_type_
            WHERE lu_name = lu_name_;
      END IF;
   END Handle_Possible_State_Pkg___;

   PROCEDURE Fill_List_Array___ (
      info_type_       IN VARCHAR2,
      lu_name_         IN VARCHAR2,
      package_name_    IN VARCHAR2,
      db_values_       IN OUT domain_states_array,
      client_values_   IN OUT domain_states_array,
      complete_values_ OUT complete_value_array )
   IS
      stmt_   VARCHAR2(200);
      error_  BOOLEAN := FALSE;
      domain_ BOOLEAN := info_type_ = 'domain';
      client_count_ NUMBER;
      db_count_     NUMBER;
   BEGIN
      -- Check for incorrectness in number of values and remove redundant information if it occurs
      IF db_values_.COUNT != client_values_.COUNT THEN
         client_count_ := client_values_.COUNT;
         db_count_ := db_values_.COUNT;
         IF db_count_ > client_count_ THEN
            -- Missing client values
            Assert_SYS.Assert_Is_Package(package_name_);
            stmt_ := 'BEGIN :client_value_ := '||package_name_||'.Decode(:db_value_); END;';
            FOR i IN Nvl(db_values_.FIRST, 0)..Nvl(db_values_.LAST, -1) LOOP
               -- Try to find more values by calling standard interfaces for domains,
               -- else fill out the array if it is still incomplete...
               IF domain_ THEN
                  BEGIN
                     -- ifs_assert_safe utgulk 20060105
                     EXECUTE IMMEDIATE stmt_ USING OUT client_values_(i), IN db_values_(i);
                  EXCEPTION
                     WHEN OTHERS THEN
                        client_values_(i) := 'Value not defined!';
                        error_ := TRUE;
                  END;
               ELSE
                  -- Can't find the values for other types than domains...
                  client_values_(i) := 'Value not defined!';
                  error_ := TRUE;
               END IF;

            END LOOP;
         ELSE
            -- Missing db values
            Assert_SYS.Assert_Is_Package(package_name_);
            stmt_ := 'BEGIN :db_value_ := '||package_name_||'.Encode(:client_value_); END;';
            FOR i IN Nvl(client_values_.FIRST,0)..Nvl(client_values_.LAST,-1) LOOP
               -- Try to find more values by calling standard interfaces for domains,
               -- else fill out the array if it is still incomplete...
               IF domain_ THEN
                  BEGIN
                     -- ifs_assert_safe utgulk 20060105
                     EXECUTE IMMEDIATE stmt_ USING OUT db_values_(i), IN client_values_(i);
                  EXCEPTION
                     WHEN OTHERS THEN
                        db_values_(i) := 'VALUE NOT DEFINED!';
                        error_ := TRUE;
                  END;
               ELSE
                  -- Can't find the values for other types than domains...
                  db_values_(i) := 'VALUE NOT DEFINED!';
                  error_ := TRUE;
               END IF;
            END LOOP;
         END IF;
         -- Log information if values could not be determined...
         IF error_ THEN
            Write_Error_Text___ (error_text_, '   '||Rpad(Get_Logical_Unit_Module(lu_name_),6)||':Inconsistency between client values and db values for '||info_type_||' package '||package_name_||'!', FALSE);
            Write_Error_Text___ (error_text_, '          '||to_char(db_count_)||' db values and '||to_char(client_count_)||' client values was found!');
         END IF;
      END IF;
      FOR i IN Nvl(db_values_.FIRST,0)..Nvl(db_values_.LAST,-1) LOOP
         complete_values_(i).lu_name      := lu_name_;
         complete_values_(i).package_name := package_name_;
         complete_values_(i).db_value     := db_values_(i);
         complete_values_(i).client_value := client_values_(i);
         complete_values_(i).rowversion   := SYSDATE;
      END LOOP;
   END Fill_List_Array___;

   PROCEDURE Rebuild_State_Machine___(full_mode_ BOOLEAN DEFAULT TRUE) IS

      last_update_ DATE DEFAULT NULL;

      CURSOR state_mach IS
         SELECT decode(upper(regexp_substr(a.text,'[[:alpha:]]+_')) ,
                   'STATE_','START',
                   'EVENT_','EVENT',
                   'FINITE_','END',
                   NULL) TYPE,
               regexp_substr(a.text,'''[[:alpha:]|[:space:]]+''') WHAT,
               a.NAME PACKAGE
         FROM USER_SOURCE A, USER_OBJECTS O
         WHERE EXISTS (SELECT 1 FROM DICTIONARY_SYS_STATE_TAB D WHERE D.PACKAGE_NAME = O.OBJECT_NAME)
           AND A.NAME = O.OBJECT_NAME
           AND A.TYPE = 'PACKAGE BODY'
           AND O.OBJECT_TYPE   = 'PACKAGE'
           AND TO_DATE(timestamp,'RRRR-MM-DD:HH24:MI:SS') > last_update_
           AND regexp_like(a.text,'(state_[[:space:]]*(=|(IS)))|(event_[[:space:]]*(=|(IS)))|(Finite_State_Set___\(rec_,)','i')
         ORDER BY a.name, a.line ASC;

      TYPE state_machine_type IS TABLE OF state_mach%ROWTYPE INDEX BY PLS_INTEGER;
      TYPE dic_state_mach_type IS TABLE OF dictionary_sys_state_mach_tab%ROWTYPE INDEX BY BINARY_INTEGER;

      bulk_errors   EXCEPTION;
      PRAGMA EXCEPTION_INIT(bulk_errors, -24381);

      state_machine     state_machine_type;
      model             dic_state_mach_type;
      start_mode        VARCHAR2(30);
      in_state_transistion  BOOLEAN := FALSE;
      error_count_          NUMBER;
      j                 PLS_INTEGER;
      i                 PLS_INTEGER;
      position_      NUMBER;

      FUNCTION Get_Lu_Name_(
            package_name_ VARCHAR2) RETURN VARCHAR2
         IS
            tmp_ VARCHAR2(60) DEFAULT NULL;
         BEGIN
            SELECT lu_name INTO tmp_
               FROM dictionary_sys_package_tab
               WHERE package_name= package_name_;
            RETURN tmp_;
         EXCEPTION
            WHEN OTHERS THEN
               Write_Error_Text___ (error_text_, '          Failed to find LU name for package '||package_name_);
               RETURN NULL;
         END get_lu_name_;

         FUNCTION trim_str(str_ VARCHAR2) RETURN VARCHAR2
         IS
         BEGIN
              RETURN SUBSTR(str_,2, length(str_)-2);
         END;


   BEGIN
      IF full_mode_ THEN
         last_update_:= SYSDATE-1000;
      ELSE
         SELECT NVL(MAX(updated),SYSDATE-1000) INTO last_update_ FROM dictionary_sys_state_mach_tab;
      END IF;
      OPEN state_mach;
      FETCH state_mach BULK COLLECT INTO state_machine;
      CLOSE state_mach;
      j := 1;
      i:=2;
      WHILE i < state_machine.LAST  LOOP
         IF state_machine(i-1).type ='START' AND state_machine(i).type = 'EVENT' THEN
            in_state_transistion:= TRUE;
            start_mode:=trim_str(state_machine(i-1).what);
             WHILE  in_state_transistion AND i+1 <= state_machine.LAST LOOP
               IF state_machine(i).type='EVENT' AND
                  state_machine(i+1).type='END' AND
                  trim_str(state_machine(i).what) IS NOT NULL THEN
                  model(j).start_state:=start_mode;
                  model(j).event:=trim_str(state_machine(i).what);
                  model(j).end_state:=trim_str(state_machine(i+1).what);
                  model(j).package_name:=state_machine(i).PACKAGE;
                  model(j).lu_name:= get_lu_name_(state_machine(i).PACKAGE);
                  model(j).updated:=SYSDATE;
                  model(j).rowversion:=SYSDATE;
                  i:=i+2;
                  j:=j+1;
               ELSIF state_machine(i).type!='START' AND i < state_machine.LAST THEN
                  i:=i+1;
               ELSE
                  in_state_transistion:=FALSE;
                  i:=i+1;
               END IF;
            END LOOP;
         ELSE
            i:=i+1;
         END IF;
      END LOOP;
--  This line only used when debugging
--      FOR k IN model.FIRST..model.LAST LOOP
--          Write_Error_Text___ (error_text_, model(k).package_name||':'||model(k).start_state||'->'||model(k).event||'->'||model(k).end_state);
--      END LOOP;
       BEGIN
            -- ifs_assert_safe pemase 20060215
            EXECUTE IMMEDIATE 'truncate table dictionary_sys_state_mach_tab';
            Write_Error_Text___ (error_text_, '   -------------------------------------------------------------');
            Write_Error_Text___ (error_text_, '   Dictionary Cache is being updated with '||model.count ||' state machine entrie(s).');
            Write_Error_Text___ (error_text_, '   -------------------------------------------------------------');
            FORALL k IN NVL(model.FIRST,0)..NVL(model.LAST,-1) SAVE EXCEPTIONS
               INSERT INTO dictionary_sys_state_mach_tab VALUES model(k);
         EXCEPTION
            WHEN bulk_errors THEN
               error_count_ := SQL%BULK_EXCEPTIONS.COUNT;
               Write_Error_Text___ (error_text_, '   '||to_char(error_count_)||' problem(s) when inserting dictionary state machine information.');
               FOR i IN 1..error_count_ LOOP
                  position_ := SQL%BULK_EXCEPTIONS(i).ERROR_INDEX;
--                  Write_Error_Text___ (error_text_, '   Position number '||to_char(position_));
                  Write_Error_Text___ (error_text_, '   '||Rpad(Get_Logical_Unit_Module(model(position_).lu_name),6)||':Error ' || SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE)||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'lu_name='||model(position_).lu_name||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'package_name='||model(position_).package_name||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'start_state='||model(position_).start_state||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'event='||model(position_).event||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'end_state='||model(position_).end_state);
               END LOOP;
         END;
   EXCEPTION
      WHEN OTHERS THEN
           Write_Error_Text___ (error_text_, '   '||dbms_utility.format_error_backtrace);
   END  Rebuild_State_Machine___;


   PROCEDURE Rebuild_All_State_Event___(full_mode_ BOOLEAN DEFAULT TRUE) IS

      last_update_ DATE DEFAULT NULL;

      CURSOR  get_events IS
         SELECT regexp_substr(text,'([[:alpha:]]+\^){1,}') event, name
         FROM USER_SOURCE A, USER_OBJECTS O
         WHERE EXISTS (SELECT 1 FROM DICTIONARY_SYS_STATE_TAB D WHERE D.PACKAGE_NAME = O.OBJECT_NAME)
           AND A.NAME = O.OBJECT_NAME
           AND A.TYPE = 'PACKAGE BODY'
           AND O.OBJECT_TYPE   = 'PACKAGE'
           AND TO_DATE(timestamp,'RRRR-MM-DD:HH24:MI:SS') > last_update_
           AND regexp_like(text, '^[[:space:]]{0,}db_events_[[:space:]]{0,}:=');

      TYPE state_array IS TABLE OF get_events%ROWTYPE INDEX BY BINARY_INTEGER;
      TYPE event_array IS TABLE OF VARCHAR(40) INDEX BY PLS_INTEGER;
      state_events_        state_array ;
      state_event_values_  state_event_array;
      event_array_         event_array;

      stmt_          VARCHAR2(100);
      match_         INTEGER;
      counter_       INTEGER;
      event_idx_     INTEGER;
      event_         VARCHAR2(32);
      error_count_   NUMBER;
      position_      NUMBER;
      dup_event_val_ BOOLEAN;


      bulk_errors   EXCEPTION;
      PRAGMA EXCEPTION_INIT(bulk_errors, -24381);

      FUNCTION Get_Lu_Name_(
         package_name_ VARCHAR2) RETURN VARCHAR2
      IS
         tmp_ VARCHAR2(60) DEFAULT NULL;
      BEGIN
         SELECT lu_name INTO tmp_
            FROM dictionary_sys_package_tab
            WHERE package_name= package_name_;
         RETURN tmp_;
      EXCEPTION
         WHEN OTHERS THEN
            Write_Error_Text___ (error_text_, '          Failed to find LU name for package '||package_name_);
            RETURN NULL;
      END get_lu_name_;

   BEGIN

      IF full_mode_ THEN
         last_update_:= SYSDATE-1000;
      ELSE
         SELECT NVL(MAX(updated),SYSDATE-1000) INTO last_update_ FROM dictionary_sys_state_mach_tab;
      END IF;

      OPEN get_events;
      FETCH get_events BULK COLLECT INTO state_events_;
      IF SQL%NOTFOUND THEN
         Write_Error_Text___ (error_text_, '   No state events found.');
         CLOSE get_events;
         RETURN;
      ELSE
         BEGIN
            -- ifs_assert_safe pemase 20060215
            EXECUTE IMMEDIATE 'TRUNCATE TABLE dictionary_sys_state_event_tab';
         EXCEPTION
            WHEN OTHERS THEN
               Write_Error_Text___ (error_text_, '   Failed to truncate dictionary_sys_state_event_tab.');
               Write_Error_Text___ (error_text_, '   '||dbms_utility.format_error_backtrace);
               RETURN;
         END;
      END IF;
      CLOSE get_events;
      Write_Error_Text___ (error_text_, '   -------------------------------------------------------------');
      Write_Error_Text___ (error_text_, '   Dictionary Cache is fetching State Events');
      Write_Error_Text___ (error_text_, '   -------------------------------------------------------------');
      counter_:=1;
      FOR i IN Nvl(state_events_.FIRST,0)..Nvl(state_events_.LAST,-1) LOOP
         match_:=1;
         event_idx_:=1;
         event_array_.DELETE;
         LOOP
            dup_event_val_:= FALSE;
            event_:=REGEXP_SUBSTR(state_events_(i).event,'([[:alpha:]|[:digit:]|[:blank:]]+\^)', 1, match_);
            EXIT WHEN event_ IS NULL;
            IF event_idx_!=1 THEN
               dup_event_val_:= FALSE;
               FOR j IN Nvl(event_array_.FIRST,0)..Nvl(event_array_.LAST,-1) LOOP
                  IF event_array_(j)=event_ THEN
                     dup_event_val_:= TRUE;
                     EXIT;
                  END IF;
               END LOOP;
            END IF;
            IF NOT dup_event_val_ THEN
               event_array_(event_idx_):=event_;
               state_event_values_(counter_).lu_name:=get_lu_name_(state_events_(i).name);
               state_event_values_(counter_).package_name:=state_events_(i).name;
               state_event_values_(counter_).event:=substr(event_,1,length(event_)-1);
               state_event_values_(counter_).rowversion:=SYSDATE;
               counter_:=counter_+1;
               event_idx_:=event_idx_+1;
--            ELSE
--               Write_Error_Text___ (error_text_, '   '||Rpad(Get_Logical_Unit_Module(get_lu_name_(state_events_(i).name)),6)||':Skipping duplicate event ('||substr(event_,1,length(event_)-1)||') for LU:'||get_lu_name_(state_events_(i).name));
            END IF;
            match_:=match_+1;
         END LOOP;
      END LOOP;

      BEGIN
         Write_Error_Text___ (error_text_, '   -------------------------------------------------------------');
         Write_Error_Text___ (error_text_, '   Dictionary Cache is being updated with '||state_event_values_.count ||' State Events');
         Write_Error_Text___ (error_text_, '   -------------------------------------------------------------');
         FORALL j IN Nvl(state_event_values_.FIRST, 0)..Nvl(state_event_values_.LAST, -1) SAVE EXCEPTIONS
            INSERT INTO dictionary_sys_state_event_tab VALUES state_event_values_(j);
      EXCEPTION
         WHEN bulk_errors THEN
            error_count_ := SQL%BULK_EXCEPTIONS.COUNT;
            Write_Error_Text___ (error_text_, '   '||to_char(error_count_)||' problem(s) when inserting dictionary state event information.');
            FOR i IN 1..error_count_ LOOP
               position_ := SQL%BULK_EXCEPTIONS(i).ERROR_INDEX;
--               Write_Error_Text___ (error_text_, '   Position number '||to_char(position_));
               Write_Error_Text___ (error_text_, '   '||Rpad(Get_Logical_Unit_Module(state_event_values_(position_).lu_name),6)||':Error ' || SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE)||', ', FALSE);
               Write_Error_Text___ (error_text_, 'lu_name='||nvl(state_event_values_(position_).lu_name, 'NULL')||', ', FALSE);
               Write_Error_Text___ (error_text_, 'package_name='||nvl(state_event_values_(position_).package_name, 'NULL')||', ', FALSE);
               Write_Error_Text___ (error_text_, 'event='||nvl(state_event_values_(position_).event, 'NULL'));
            END LOOP;
         WHEN OTHERS THEN
            Write_Error_Text___ (error_text_, '   Failed to truncate dictionary_sys_state_event_tab.');
            Write_Error_Text___ (error_text_, '   '||dbms_utility.format_error_backtrace);
      END;

   EXCEPTION
      WHEN OTHERS THEN
         Write_Error_Text___ (error_text_, '   Failed to rebuild dictionary_sys_state_event_tab.');
         Write_Error_Text___ (error_text_, '   '||dbms_utility.format_error_backtrace);
   END Rebuild_All_State_Event___;



   PROCEDURE Rebuild_State_Transitions___(full_mode_ BOOLEAN DEFAULT TRUE) IS

      last_update_ DATE DEFAULT NULL;

      match_         INTEGER;
      counter_       INTEGER;
      allowed_event_ VARCHAR2(32);
      state_trans_   VARCHAR2(130);
      error_count_   NUMBER;
      position_      NUMBER;

      bulk_errors   EXCEPTION;
      PRAGMA EXCEPTION_INIT(bulk_errors, -24381);

      CURSOR get_state_events_
      IS
      SELECT lu_name, package_name, db_state
         FROM dictionary_sys_state_tab d, user_objects o
         WHERE d.package_name = o.object_name
         AND   o.object_type = 'PACKAGE BODY'
           AND TO_DATE(o.timestamp,'RRRR-MM-DD:HH24:MI:SS') > last_update_;

      TYPE state_array IS TABLE OF get_state_events_%ROWTYPE INDEX BY BINARY_INTEGER;
      state_list_      state_array;

      TYPE state_trans_array IS TABLE OF dictionary_sys_state_trans_tab%ROWTYPE INDEX BY BINARY_INTEGER;
      state_trans_values_  state_trans_array;

      FUNCTION Get_Allowed_State_Trans (
                                         pkg_name_ VARCHAR2,
                                         state_ VARCHAR2)
         RETURN VARCHAR2
         IS
         stmt_    VARCHAR2(200);
         events_  VARCHAR2(200);
      BEGIN
         Assert_SYS.Assert_Is_Package(pkg_name_);
         stmt_:='BEGIN :events:='||pkg_name_||'.Finite_State_Events__(:state); END;';
         -- ifs_assert_safe utgulk 20060105
         EXECUTE IMMEDIATE stmt_ USING IN OUT   events_, state_ ;
         RETURN events_;
      EXCEPTION
         WHEN OTHERS THEN
            Write_Error_Text___ (error_text_, '   '||Rpad(Get_Logical_Unit_Module(Get_Logical_Unit(pkg_name_, 'PACKAGE')),6)||':Failed to fetch events for package '||pkg_name_||' and state '||state_);
            RETURN NULL;
      END Get_Allowed_State_Trans;

   BEGIN

      IF full_mode_ THEN
         last_update_:= SYSDATE-1000;
      ELSE
         SELECT NVL(MAX(to_date(timestamp, 'RRRR-MM-DD:HH24:MI:SS')),SYSDATE-1000) INTO last_update_
            FROM dictionary_sys_state_tab d, user_objects o
            WHERE d.package_name = o.object_name
            AND o.object_type = 'PACKAGE BODY';
      END IF;

      OPEN get_state_events_;
      FETCH get_state_events_ BULK COLLECT INTO state_list_;
      IF SQL%NOTFOUND THEN
         Write_Error_Text___ (error_text_, '   No state transitions found.');
         CLOSE get_state_events_;
         RETURN;
      ELSE
         BEGIN
            -- ifs_assert_safe pemase 20060215
            EXECUTE IMMEDIATE 'TRUNCATE TABLE dictionary_sys_state_trans_tab';
         EXCEPTION
            WHEN OTHERS THEN
               Write_Error_Text___ (error_text_, '   Failed to truncate dictionary_sys_state_trans_tab.');
               Write_Error_Text___ (error_text_, '   '||dbms_utility.format_error_backtrace);
               RETURN;
         END;
      END IF;
      CLOSE get_state_events_;
      counter_:=1;
      FOR i IN Nvl(state_list_.FIRST,0)..Nvl(state_list_.LAST,-1) LOOP
         state_trans_:=Get_Allowed_State_Trans(state_list_(i).package_name, state_list_(i).db_state);
         match_:=1;
         LOOP
            allowed_event_:=REGEXP_SUBSTR(state_trans_,'([[:alpha:]|[:digit:]|[:blank:]]+\^)', 1, match_);
            EXIT WHEN allowed_event_ IS NULL;
            state_trans_values_(counter_).lu_name:=state_list_(i).lu_name;
            state_trans_values_(counter_).package_name:=state_list_(i).package_name;
            state_trans_values_(counter_).state:=state_list_(i).db_state;
            state_trans_values_(counter_).allowed_event:=substr(allowed_event_,1,length(allowed_event_)-1);
            state_trans_values_(counter_).rowversion:=SYSDATE;
            match_:=match_+1;
            counter_:=counter_+1;
         END LOOP;
      END LOOP;

      BEGIN
         Write_Error_Text___ (error_text_, '   -------------------------------------------------------------');
         Write_Error_Text___ (error_text_, '   Dictionary Cache is being updated with '||state_trans_values_.count ||' State Transitions');
         Write_Error_Text___ (error_text_, '   -------------------------------------------------------------');
         FORALL j IN Nvl(state_trans_values_.FIRST,0)..Nvl(state_trans_values_.LAST,-1) SAVE EXCEPTIONS
            INSERT INTO dictionary_sys_state_trans_tab VALUES state_trans_values_(j);
      EXCEPTION
         WHEN bulk_errors THEN
            error_count_ := SQL%BULK_EXCEPTIONS.COUNT;
            Write_Error_Text___ (error_text_, '   '||to_char(error_count_)||' problem(s) when inserting dictionary state transition information.');
            FOR i IN 1..error_count_ LOOP
               position_ := SQL%BULK_EXCEPTIONS(i).ERROR_INDEX;
--               Write_Error_Text___ (error_text_, '   Position number '||to_char(position_));
               Write_Error_Text___ (error_text_, '   '||Rpad(Get_Logical_Unit_Module(state_trans_values_(position_).lu_name),6)||':Error ' || SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE)||', ', FALSE);
               Write_Error_Text___ (error_text_, 'lu_name='||nvl(state_trans_values_(position_).lu_name, 'NULL')||', ', FALSE);
               Write_Error_Text___ (error_text_, 'package_name='||nvl(state_trans_values_(position_).package_name, 'NULL')||', ', FALSE);
               Write_Error_Text___ (error_text_, 'state='||nvl(state_trans_values_(position_).state, 'NULL')||', ', FALSE);
               Write_Error_Text___ (error_text_, 'allowed_event='||nvl(state_trans_values_(position_).allowed_event, 'NULL'));
            END LOOP;
      END;

   EXCEPTION
      WHEN OTHERS THEN
         Write_Error_Text___ (error_text_, '   Failed to rebuild dictionary_sys_state_trans_tab.');
         Write_Error_Text___ (error_text_, '   '||dbms_utility.format_error_backtrace);
   END Rebuild_State_Transitions___;

   PROCEDURE Tokenize_Lists___ (
      value_list_ IN VARCHAR2,
      values_     IN OUT domain_states_array )
   IS
      i_        NUMBER      := 0;
      pos_      NUMBER      := 1;
      end_pos_  NUMBER      := 1;
      sep_      VARCHAR2(1) := Client_SYS.text_separator_;
      len_      NUMBER      := length(value_list_);
      ind_      NUMBER      := Nvl(values_.LAST+1,0);
      temp_     VARCHAR2(120);
   BEGIN
      end_pos_ := instr(value_list_, sep_, 1, i_ + 1);
      WHILE end_pos_ < len_ AND end_pos_ != 0 LOOP
         BEGIN
            temp_ := REPLACE(substr(value_list_, pos_, end_pos_ - pos_),'''||''','');
            values_(ind_) := REPLACE(temp_,''' || ''',''); 
         EXCEPTION
            WHEN value_error THEN
               values_(ind_) := 'ERROR!!!';
         END;
         pos_ := end_pos_ + 1;
         i_ := i_ + 1;
         ind_:=ind_+1;
         end_pos_ := instr(value_list_, sep_, 1, i_ + 1);
      END LOOP;
   END Tokenize_Lists___;

   PROCEDURE Insert_Package_Information___ (
      lu_name_      IN VARCHAR2,
      module_       IN VARCHAR2,
      package_name_ IN VARCHAR2,
      lu_type_      IN VARCHAR2,
      lu_sub_type_  IN VARCHAR2 )
   IS
      package_index_ NUMBER;
   BEGIN
      BEGIN
         INSERT INTO dictionary_sys_tab
            (lu_name, module, lu_type, rowversion)
         VALUES
            (lu_name_, module_, lu_type_, SYSDATE);
         IF length(lu_name_) > 25 THEN
            Write_Error_Text___ (error_text_, '   '||rpad(module_,6)||':LU Name '||nvl(lu_name_, 'NULL')||' is longer than 25 characters, this is not allowed.');
         END IF;
      EXCEPTION
         WHEN dup_val_on_index THEN
            UPDATE dictionary_sys_tab
               SET rowversion = SYSDATE,
                   module = module_,
                   lu_type = lu_type_
               WHERE lu_name = lu_name_;
         WHEN OTHERS THEN
            Write_Error_Text___ (error_text_, '   '||rpad(module_,6)||':Undefined problem when inserting LU dictionary information for package '||package_name_||', ', FALSE);
            Write_Error_Text___ (error_text_, 'LU Name='||nvl(lu_name_, 'NULL')||', ', FALSE);
            Write_Error_Text___ (error_text_, 'LU Type='||nvl(lu_type_, 'NULL'));
      END;
      -- Insert and if already existing then update.
      -- This is more efficient when performing a full refresh!
      BEGIN
         Get_Next_Pkg_Index___(lu_name_, package_index_);
         INSERT INTO dictionary_sys_package_tab
            (lu_name, package_name, package_index, package_type, rowversion)
         VALUES
            (lu_name_, package_name_, package_index_, lu_sub_type_, SYSDATE);
         --
         --  Fix problems with LU that has more than one _API package (e.g. for state handling).
         --
         UPDATE Dictionary_Sys_Package_Tab
            SET package_index = 0
          WHERE lu_name IN (SELECT lu_name
                              FROM Dictionary_Sys_Package_Tab
                             WHERE package_name LIKE '%_API'
                          GROUP BY lu_name
                            HAVING count(*) > 1)
            AND package_name = Upper(Regexp_Replace(lu_name,
                                           '([a-z])([A-Z])',
                                           '\1_\2',
                                           1,
                                           0,
                                           'c') || '_API')
            AND package_index != 1;
          --
      EXCEPTION
         WHEN dup_val_on_index THEN
            UPDATE dictionary_sys_package_tab
               SET rowversion = SYSDATE
               WHERE lu_name = lu_name_
               AND   package_name = package_name_;
         WHEN OTHERS THEN
            Write_Error_Text___ (error_text_, '   '||Rpad(Get_Logical_Unit_Module(lu_name_),6)||':Undefined problem when inserting dictionary information for package '||package_name_||', ', FALSE);
            Write_Error_Text___ (error_text_, 'LU Name='||nvl(lu_name_, 'NULL')||', ', FALSE);
            Write_Error_Text___ (error_text_, 'Package Name='||nvl(package_name_, 'NULL')||', ', FALSE);
            Write_Error_Text___ (error_text_, 'Package Index='||nvl(to_char(pkg_index_), 'NULL')||', ', FALSE);
            Write_Error_Text___ (error_text_, 'Package Type='||nvl(lu_sub_type_, 'NULL'));
      END;
   END Insert_Package_Information___;

   PROCEDURE Insert_View_Information___(
      lu_name_      IN VARCHAR2,
      module_       IN VARCHAR2,
      view_name_    IN VARCHAR2,
      view_prompt_  IN VARCHAR2 )
   IS
      base_view_  BOOLEAN;
      view_index_ NUMBER;
      view_type_  VARCHAR2(1);
      lu_prompt_  VARCHAR2(200);
   BEGIN
      -- Find the base view according to naming conventions...
      -- (Other possible base views are handled at the end of the process)
      IF view_name_ =  Clientnametodbname_(lu_name_) THEN
         lu_prompt_ := view_prompt_;
         base_view_ := TRUE;
      ELSE
         lu_prompt_ := NULL;
         base_view_ := FALSE;
      END IF;
      -- Insert into dictionary_sys_tab. It is likely this entry already exist (from package information),
      -- then only updating the prompt and rowversion is more efficent.
      IF base_view_ THEN
         UPDATE dictionary_sys_tab
            SET rowversion = SYSDATE,
                lu_prompt = lu_prompt_
            WHERE lu_name = lu_name_;
         IF SQL%NOTFOUND THEN
            INSERT INTO dictionary_sys_tab
               (lu_name, module, lu_prompt, rowversion)
            VALUES
               (lu_name_, module_, lu_prompt_, SYSDATE);
         END IF;
      ELSE
         UPDATE dictionary_sys_tab
            SET rowversion = SYSDATE
            WHERE lu_name = lu_name_;
         IF SQL%NOTFOUND THEN
            INSERT INTO dictionary_sys_tab
               (lu_name, module, rowversion)
            VALUES
               (lu_name_, module_, SYSDATE);
         END IF;
      END IF;
      -- Insert into dictionary_sys_view_tab
      -- Insert and if already existing then update.
      -- This is more efficient when performing a full refresh!
      BEGIN
         Get_Next_View_Index___(lu_name_, view_index_);
         IF base_view_ THEN
            view_type_ := 'B';
         ELSIF substr(view_name_, -4) = '_REP' THEN
            view_type_ := 'R';
         ELSE
            view_type_ := 'A';
         END IF;
         INSERT INTO dictionary_sys_view_tab
            (lu_name, view_name, view_type, view_prompt, view_index, rowversion)
         VALUES
            (lu_name_, view_name_, view_type_, view_prompt_, view_index_, SYSDATE);
      EXCEPTION
         WHEN dup_val_on_index THEN
            UPDATE dictionary_sys_view_tab
               SET view_type = view_type_,
                   view_prompt = view_prompt_,
                   rowversion = SYSDATE
               WHERE lu_name = lu_name_
               AND view_name = view_name_;
         WHEN OTHERS THEN
            Write_Error_Text___ (error_text_, '   '||Rpad(module_,6)||':Undefined problem when inserting dictionary information for view '||view_name_||', ', FALSE);
            Write_Error_Text___ (error_text_, 'LU Name='||nvl(lu_name_, 'NULL')||', ', FALSE);
            Write_Error_Text___ (error_text_, 'View Name='||nvl(view_name_, 'NULL')||', ', FALSE);
            Write_Error_Text___ (error_text_, 'View Prompt='||nvl(view_prompt_, 'NULL')||', ', FALSE);
            Write_Error_Text___ (error_text_, 'View Index='||nvl(to_char(view_index_), 'NULL')||', ');
      END;
   END Insert_View_Information___;

   PROCEDURE Refresh_View_Columns___ (
      all_views_  IN BOOLEAN,
      start_time_ IN DATE )
   IS
      CURSOR get_view_columns IS
         SELECT u.table_name view_name, u.column_name column_name, c.comments comments, u.column_id column_id
         FROM   user_tab_columns u, fnd_col_comments c
         WHERE  u.table_name = c.table_name
         AND    u.column_name = c.column_name
         ORDER BY u.table_name, u.column_name;

      CURSOR get_new_view_columns IS
         SELECT u.table_name view_name, u.column_name column_name, c.comments comments, u.column_id column_id
         FROM   user_tab_columns u, fnd_col_comments c, dictionary_sys_view_tab v
         WHERE  u.table_name = c.table_name
         AND    u.table_name = v.view_name
         AND    u.column_name = c.column_name
         AND    v.rowversion >= start_time_
         ORDER BY u.table_name, u.column_name;

      column_flags_ VARCHAR2(5);
      lu_name_      VARCHAR2(30);
      prev_view_    VARCHAR2(30) := 'NIL';
      n_            NUMBER := 0;
      position_     NUMBER;
      error_count_  NUMBER;
      bulk_errors   EXCEPTION;
      PRAGMA EXCEPTION_INIT(bulk_errors, -24381);

      TYPE view_column_array IS TABLE OF get_view_columns%ROWTYPE INDEX BY BINARY_INTEGER;
      view_columns_ view_column_array;

      TYPE complete_array IS TABLE OF dictionary_sys_view_column_tab%ROWTYPE INDEX BY BINARY_INTEGER;
      complete_columns_ complete_array;
   BEGIN
      --
      -- Fetch view column information and delete old information
      --
      IF all_views_ THEN
         OPEN get_view_columns;
         FETCH get_view_columns BULK COLLECT INTO view_columns_;
         CLOSE get_view_columns;
         -- Remove all old information
         -- ifs_assert_safe pemase 20060215
         EXECUTE IMMEDIATE 'TRUNCATE TABLE dictionary_sys_view_column_tab';
      ELSE
         OPEN get_new_view_columns;
         FETCH get_new_view_columns BULK COLLECT INTO view_columns_;
         CLOSE get_new_view_columns;
         -- Remove old information for all of the methods that is being updated
         DELETE FROM dictionary_sys_view_column_tab c
            WHERE EXISTS (SELECT 1
                          FROM dictionary_sys_view_tab v
                          WHERE v.view_name = c.view_name
                          AND v.rowversion >= start_time_);
      END IF;

      -- Process all of the view column information
      IF view_columns_.COUNT > 0 THEN
         FOR i IN Nvl(view_columns_.FIRST,0)..Nvl(view_columns_.LAST,-1) LOOP
            -- Find the lu name for the view if view has changed
            IF (prev_view_ <> view_columns_(i).view_name) THEN
               lu_name_ := Get_Logical_Unit(view_columns_(i).view_name, 'VIEW');
               prev_view_ := view_columns_(i).view_name;
            END IF;
            IF lu_name_ IS NOT NULL THEN
               BEGIN
                  complete_columns_(n_).lu_name          := lu_name_;
                  complete_columns_(n_).view_name        := view_columns_(i).view_name;
                  complete_columns_(n_).column_name      := view_columns_(i).column_name;
                  complete_columns_(n_).column_index     := view_columns_(i).column_id;
                  complete_columns_(n_).rowversion       := SYSDATE;
                  complete_columns_(n_).column_datatype  := Comment_Value_('DATATYPE',view_columns_(i).comments);
                  complete_columns_(n_).column_prompt    := Comment_Value_('PROMPT',view_columns_(i).comments);
                  complete_columns_(n_).column_reference := Comment_Value_('REF',view_columns_(i).comments);
                  column_flags_                          := Comment_Value_('FLAGS',view_columns_(i).comments);
                  complete_columns_(n_).type_flag        := substr(column_flags_,1,1);
                  complete_columns_(n_).required_flag    := substr(column_flags_,2,1);
                  complete_columns_(n_).insert_flag      := substr(column_flags_,3,1);
                  complete_columns_(n_).update_flag      := substr(column_flags_,4,1);
                  complete_columns_(n_).lov_flag         := substr(column_flags_,5,1);
               EXCEPTION
                  WHEN OTHERS THEN
                     Write_Error_Text___ (error_text_, '   ??????:Incorrect comments for view column '||view_columns_(i).view_name||'.'||view_columns_(i).column_name);
                     complete_columns_(n_).column_datatype  := NULL;
                     complete_columns_(n_).column_prompt    := NULL;
                     complete_columns_(n_).column_reference := NULL;
                     complete_columns_(n_).type_flag        := NULL;
                     complete_columns_(n_).required_flag    := NULL;
                     complete_columns_(n_).insert_flag      := NULL;
                     complete_columns_(n_).update_flag      := NULL;
                     complete_columns_(n_).lov_flag         := NULL;
               END;
               n_ := n_ + 1;
            END IF;
         END LOOP;

         -- Insert all the values into dictionary_sys_view_column_tab
         BEGIN
            FORALL j IN Nvl(complete_columns_.FIRST,0)..Nvl(complete_columns_.LAST,-1) SAVE EXCEPTIONS
               INSERT INTO dictionary_sys_view_column_tab VALUES complete_columns_(j);
         EXCEPTION
            WHEN bulk_errors THEN
               error_count_ := SQL%BULK_EXCEPTIONS.COUNT;
               Write_Error_Text___ (error_text_, '   '||to_char(error_count_)||' problem(s) when inserting dictionary view column information!');
               FOR i IN 1..error_count_ LOOP
                  position_ := SQL%BULK_EXCEPTIONS(i).ERROR_INDEX;
                  Write_Error_Text___ (error_text_, '   '||Rpad(Get_Logical_Unit_Module(complete_columns_(position_).lu_name),6)||':Error ' || SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE)||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'Lu Name='||nvl(complete_columns_(position_).lu_name, 'NULL')||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'View Name='||nvl(complete_columns_(position_).view_name, 'NULL')||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'Column Name='||nvl(complete_columns_(position_).column_name, 'NULL'));
               END LOOP;
         END;
      END IF;
   END Refresh_View_Columns___;

   -- Handles both domain and state information, behaves different depending on info_type
   PROCEDURE Refresh_Domain_State_Info___ (
      info_type_    IN VARCHAR2,
      lu_name_      IN VARCHAR2,
      package_name_ IN VARCHAR2 )
   IS
      -- Domain information
      CURSOR get_domain_info(package_name_ IN VARCHAR2,list_type_ VARCHAR2) IS
         SELECT ltrim(rtrim(substr(text, instr(text, '''')+ 1) )) list_values,line
         FROM   user_source t
         WHERE  type = 'PACKAGE BODY'
         AND    name = package_name_
         AND    text NOT LIKE '--%'
         AND    text NOT LIKE '%/%*%'
         AND    text NOT LIKE '%*%/'
         AND line BETWEEN (SELECT MIN(line) 
                           FROM   user_source x
                           WHERE  type = 'PACKAGE BODY'
                           AND    name = package_name_
                           AND    x.text LIKE '%'||list_type_||'%:=%''%''%') 
                     AND 
                          (SELECT MIN(line) 
                           FROM user_source y 
                           WHERE  type = 'PACKAGE BODY'
                           AND    y.name = package_name_
                           AND y.text LIKE '%;%'
                           AND y.line >= (SELECT min(line) 
                                          FROM   user_source
                                          WHERE  type = 'PACKAGE BODY'
                                          AND    name = package_name_
                                          AND    text LIKE '%'||list_type_||'%:=%''%''%'));   

  
      -- State information
      CURSOR get_state_info(package_name_ IN VARCHAR2) IS
         SELECT ltrim(rtrim(substr(text, 1, instr(text, 'CONSTANT') - 1))) list_type, ltrim(rtrim(substr(text, instr(text, '''')+ 1) )) list_values
         FROM   user_source
         WHERE  type = 'PACKAGE BODY'
         AND    name = package_name_
         AND    (text LIKE '%db_state_list_%:=%''%''%' OR text LIKE '%client_state_list_%:=%''%''%')
         AND    text NOT LIKE '--%'
         AND    text NOT LIKE '%/%*%'
         AND    text NOT LIKE '%*%/';
--         AND    line BETWEEN 2 AND 11;

      refresh_domain_ BOOLEAN := info_type_ = 'domain';
      position_       NUMBER;
      error_count_    NUMBER;
      bulk_errors     EXCEPTION;
      PRAGMA EXCEPTION_INIT(bulk_errors, -24381);        
      list_type_    VARCHAR2(100);

      TYPE domain_array IS TABLE OF get_domain_info%ROWTYPE INDEX BY BINARY_INTEGER;
      list_ domain_array;
   BEGIN
      -- Delete old values (they can only exist if this is not a full refresh)
      IF NOT refresh_all_ THEN
         IF refresh_domain_ THEN
            DELETE FROM dictionary_sys_domain_tab
               WHERE lu_name = lu_name_
               AND package_name = package_name_;
         ELSE
            DELETE FROM dictionary_sys_state_tab
               WHERE lu_name = lu_name_
               AND package_name = package_name_;
         END IF;
      END IF;

      -- Clear variables
      db_values_.DELETE;
      client_values_.DELETE;
      complete_values_.DELETE;

      IF refresh_domain_ THEN

         OPEN get_domain_info(package_name_,'db_value_list_');
         FETCH get_domain_info BULK COLLECT INTO list_;
         CLOSE get_domain_info;

         FOR j_ IN Nvl(list_.FIRST,0)..Nvl(list_.LAST,-1) LOOP
            Tokenize_Lists___(list_(j_).list_values, db_values_);
         END LOOP;

         list_.DELETE;
         OPEN get_domain_info(package_name_,'client_value_list_');
         FETCH get_domain_info BULK COLLECT INTO list_;
         CLOSE get_domain_info;

         FOR j_ IN Nvl(list_.FIRST,0)..Nvl(list_.LAST,-1) LOOP
            Tokenize_Lists___(list_(j_).list_values, client_values_);
         END LOOP;
      ELSE
         FOR list IN get_state_info(package_name_) LOOP
            -- Break down the list into single values in an array
            IF list.list_type = 'db_state_list_' THEN
               Tokenize_Lists___(list.list_values, db_values_);
            ELSIF list.list_type = 'client_state_list_' THEN
               Tokenize_Lists___(list.list_values, client_values_);
            END IF;
         END LOOP;
         -- Get state events
         -- translate db values to an PL/SQL collection

      END IF;

      IF db_values_.count > 0 THEN
         -- Fill the result array with the rest of the necessary information
         Fill_List_Array___(info_type_, lu_name_, package_name_, db_values_, client_values_, complete_values_);

         -- Insert all of the values into dictionary_sys_domain_tab
         BEGIN
            IF refresh_domain_ THEN
               FORALL j IN Nvl(complete_values_.FIRST,0)..Nvl(complete_values_.LAST,-1) SAVE EXCEPTIONS
                  INSERT INTO dictionary_sys_domain_tab VALUES complete_values_(j);
            ELSE
               FORALL j IN Nvl(complete_values_.FIRST,0)..Nvl(complete_values_.LAST,-1) SAVE EXCEPTIONS
                  INSERT INTO dictionary_sys_state_tab VALUES complete_values_(j);
            END IF;
         EXCEPTION
            WHEN bulk_errors THEN
               error_count_ := SQL%BULK_EXCEPTIONS.COUNT;
               Write_Error_Text___ (error_text_, '   '||to_char(error_count_)||' problem(s) when inserting dictionary information for '||info_type_||' package '||package_name_||'!');
               FOR i IN 1..error_count_ LOOP
                  position_ := SQL%BULK_EXCEPTIONS(i).ERROR_INDEX - 1;
--                  Write_Error_Text___ (error_text_, '   Position number '||to_char(position_));
                  Write_Error_Text___ (error_text_, '   '||Rpad(Get_Logical_Unit_Module(lu_name_),6)||':Error ' || SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE)||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'Db Value='||nvl(complete_values_(position_).db_value, 'NULL')||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'Client Value='||nvl(complete_values_(position_).client_value, 'NULL'));
               END LOOP;
         END;
      END IF;
   END Refresh_Domain_State_Info___;

   PROCEDURE Refresh_Method_Arguments___ (
      all_methods_  IN BOOLEAN,
      start_time_   IN DATE )
   IS
      CURSOR get_met_arguments IS
         SELECT package_name, object_name method_name, argument_name, position, data_type, in_out, nvl(to_number(overload), 0) overload
         FROM user_arguments
         WHERE package_name IS NOT NULL
         AND argument_name IS NOT NULL
         AND data_type IS NOT NULL
         AND data_level = 0
         ORDER BY package_name, object_name;

      CURSOR get_new_met_arguments IS
         SELECT ua.package_name, ua.object_name method_name, ua.argument_name, ua.position, ua.data_type, ua.in_out, nvl(to_number(ua.overload), 0) overload
         FROM user_arguments ua, dictionary_sys_package_tab p
         WHERE ua.package_name IS NOT NULL
         AND ua.argument_name IS NOT NULL
         AND ua.data_type IS NOT NULL
         AND ua.data_level = 0
         AND ua.package_name = p.package_name
         AND p.rowversion >= start_time_
         ORDER BY ua.package_name, ua.object_name;

      lu_name_     VARCHAR2(30);
      prev_pkg_    VARCHAR2(30) := 'NIL';
      n_           NUMBER := 0;
      position_    NUMBER;
      error_count_ NUMBER;
      bulk_errors  EXCEPTION;
      PRAGMA EXCEPTION_INIT(bulk_errors, -24381);

      TYPE met_argument_array IS TABLE OF get_met_arguments%ROWTYPE INDEX BY BINARY_INTEGER;
      met_arguments met_argument_array;

      TYPE complete_array IS TABLE OF dictionary_sys_argument_tab%ROWTYPE INDEX BY BINARY_INTEGER;
      all_arguments_ complete_array;
   BEGIN
      --
      -- Fetch method argument information and delete old information
      --
      IF all_methods_ THEN
         OPEN get_met_arguments;
         FETCH get_met_arguments BULK COLLECT INTO met_arguments;
         CLOSE get_met_arguments;
         -- Remove all old information
         -- ifs_assert_safe pemase 20060215
         EXECUTE IMMEDIATE 'TRUNCATE TABLE dictionary_sys_argument_tab';
      ELSE
         OPEN get_new_met_arguments;
         FETCH get_new_met_arguments BULK COLLECT INTO met_arguments;
         CLOSE get_new_met_arguments;
         -- Remove old information for all of the methods that is being updated
         DELETE FROM dictionary_sys_argument_tab a
            WHERE EXISTS (SELECT 1
                          FROM dictionary_sys_package_tab p
                          WHERE a.package_name = p.package_name
                          AND p.rowversion >= start_time_);
      END IF;
      --
      -- Process method argument information
      --
      IF met_arguments.COUNT > 0 THEN
         FOR i IN Nvl(met_arguments.FIRST,0)..Nvl(met_arguments.LAST,-1) LOOP
            -- Find the lu name for the package if package has changed
            IF (prev_pkg_ <> met_arguments(i).package_name) THEN
               lu_name_ := Get_Logical_Unit(met_arguments(i).package_name, 'PACKAGE');
               prev_pkg_ := met_arguments(i).package_name;
            END IF;
            IF lu_name_ IS NOT NULL THEN
               -- Insert the values into the complete array
               all_arguments_(n_).lu_name           := lu_name_;
               all_arguments_(n_).package_name      := met_arguments(i).package_name;
               all_arguments_(n_).method_name       := met_arguments(i).method_name;
               all_arguments_(n_).argument_name     := met_arguments(i).argument_name;
               all_arguments_(n_).argument_index    := met_arguments(i).position;
               all_arguments_(n_).argument_datatype := met_arguments(i).data_type;
               all_arguments_(n_).argument_type     := met_arguments(i).in_out;
               all_arguments_(n_).overload          := met_arguments(i).overload;
               all_arguments_(n_).rowversion        := SYSDATE;
               n_ := n_ + 1;
            END IF;
         END LOOP;

         -- Insert all the values into dictionary_sys_argument_tab
         BEGIN
            FORALL j IN Nvl(all_arguments_.FIRST,0)..Nvl(all_arguments_.LAST,-1) SAVE EXCEPTIONS
               INSERT INTO dictionary_sys_argument_tab VALUES all_arguments_(j);
         EXCEPTION
            WHEN bulk_errors THEN
               error_count_ := SQL%BULK_EXCEPTIONS.COUNT;
               Write_Error_Text___ (error_text_, '   '||to_char(error_count_)||' problem(s) when inserting dictionary method argument information!');
               FOR i IN 1..error_count_ LOOP
                  position_ := SQL%BULK_EXCEPTIONS(i).ERROR_INDEX;
                  Write_Error_Text___ (error_text_, '   '||Rpad(Get_Logical_Unit_Module(all_arguments_(position_).lu_name),6)||':Error ' || SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE)||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'Lu Name='||nvl(all_arguments_(position_).lu_name, 'NULL')||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'Package Name='||nvl(all_arguments_(position_).package_name, 'NULL')||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'Method Name='||nvl(all_arguments_(position_).method_name, 'NULL')||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'Argument Name='||nvl(all_arguments_(position_).argument_name, 'NULL'));
               END LOOP;
         END;

      END IF;
   END Refresh_Method_Arguments___;

   PROCEDURE Refresh_Methods___ (
      all_methods_  IN BOOLEAN,
      start_time_   IN DATE )
   IS
      CURSOR get_methods IS
         SELECT p.object_name pkg, procedure_name met
         FROM  user_procedures p
         WHERE substr(object_name, -4) IN ('_API', '_RPI', '_SYS')
         AND   procedure_name IS NOT NULL
         GROUP BY procedure_name, object_name
         ORDER BY object_name;

      CURSOR get_pragma_methods IS
         SELECT name pkg,
                rtrim(ltrim(replace(replace(replace(
                   upper(substr(text,1,instr(text,',') - 1 ))
                   ,'(',''),'PRAGMA',''),'RESTRICT_REFERENCES',''))) met
         FROM  user_source
         WHERE type = 'PACKAGE'
         AND   upper(text) LIKE '%PRAGMA%(%,%WNDS%'
         AND   text NOT LIKE '--%'
         ORDER BY name;

      CURSOR get_new_methods IS
         SELECT ua.object_name pkg, ua.procedure_name met
         FROM  user_procedures ua, dictionary_sys_package_tab p
         WHERE substr(object_name, -4) IN ('_API', '_RPI', '_SYS')
         AND   p.package_name = ua.object_name
         AND   procedure_name IS NOT NULL
         AND   p.rowversion >= start_time_
         GROUP BY ua.object_name, ua.procedure_name
         ORDER BY ua.object_name;

      CURSOR get_new_pragma_methods IS
         SELECT u.name pkg,
                rtrim(ltrim(replace(replace(replace(
                   upper(substr(u.text,1,instr(u.text,',') - 1 ))
                   ,'(',''),'PRAGMA',''),'RESTRICT_REFERENCES',''))) met
         FROM  user_source u, dictionary_sys_package_tab p
         WHERE u.type = 'PACKAGE'
         AND   upper(u.text) LIKE '%PRAGMA%(%,%WNDS%'
         AND   u.text NOT LIKE '--%'
         AND   u.name = p.package_name
         AND   p.rowversion >= start_time_
         ORDER BY name;

      lu_name_     VARCHAR2(30);
      prev_pkg_    VARCHAR2(30) := 'NIL';
      n_           NUMBER := 0;
      position_    NUMBER;
      error_count_ NUMBER;
      bulk_errors  EXCEPTION;
      PRAGMA EXCEPTION_INIT(bulk_errors, -24381);

      TYPE method_array IS TABLE OF get_methods%ROWTYPE INDEX BY BINARY_INTEGER;
      methods_ method_array;

      TYPE complete_array IS TABLE OF dictionary_sys_method_tab%ROWTYPE INDEX BY BINARY_INTEGER;
      complete_methods_ complete_array;
   BEGIN
      --
      -- Fetch method information and delete old information
      --
      IF all_methods_ THEN
         OPEN get_methods;
         FETCH get_methods BULK COLLECT INTO methods_;
         CLOSE get_methods;
         -- Remove all old information for methods
         -- ifs_assert_safe pemase 20060215
         EXECUTE IMMEDIATE 'TRUNCATE TABLE dictionary_sys_method_tab';
      ELSE
         OPEN get_new_methods;
         FETCH get_new_methods BULK COLLECT INTO methods_;
         CLOSE get_new_methods;
         -- Remove old information for all of the methods that is being updated
         DELETE FROM dictionary_sys_method_tab m
            WHERE EXISTS (SELECT 1
                          FROM dictionary_sys_package_tab p
                          WHERE p.package_name = m.package_name
                          AND p.rowversion >= start_time_);
      END IF;
      --
      -- Process method information
      --
      IF methods_.COUNT > 0 THEN
         FOR i IN Nvl(methods_.FIRST,0)..Nvl(methods_.LAST,-1) LOOP
            IF (prev_pkg_ <> methods_(i).pkg) THEN
               lu_name_ := Get_Logical_Unit(methods_(i).pkg, 'PACKAGE');
               prev_pkg_ := methods_(i).pkg;
            END IF;
            IF lu_name_ IS NOT NULL THEN
               method_ := replace(initcap(replace(methods_(i).met,'_',' ')),' ','_');
               -- Insert the values into the complete array
               complete_methods_(n_).lu_name      := lu_name_;
               complete_methods_(n_).package_name := methods_(i).pkg;
               complete_methods_(n_).method_name  := method_;
               complete_methods_(n_).method_type  := 'N';
               complete_methods_(n_).rowversion   := SYSDATE;
               n_ := n_ + 1;
            END IF;
         END LOOP;

         -- Insert all the values into dictionary_sys_method_tab
         BEGIN
            FORALL j IN Nvl(complete_methods_.FIRST,0)..Nvl(complete_methods_.LAST,-1) SAVE EXCEPTIONS
               INSERT INTO dictionary_sys_method_tab VALUES complete_methods_(j);
         EXCEPTION
            WHEN bulk_errors THEN
               error_count_ := SQL%BULK_EXCEPTIONS.COUNT;
               Write_Error_Text___ (error_text_, '   '||to_char(error_count_)||' problem(s) when inserting dictionary method information!');
               FOR i IN 1..error_count_ LOOP
                  position_ := SQL%BULK_EXCEPTIONS(i).ERROR_INDEX;
                  Write_Error_Text___ (error_text_, '   '||Rpad(Get_Logical_Unit_Module(complete_methods_(position_).lu_name),6)||':Error ' || SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE)||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'Lu Name='||nvl(complete_methods_(position_).lu_name, 'NULL')||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'Package Name='||nvl(complete_methods_(position_).package_name, 'NULL')||', ', FALSE);
                  Write_Error_Text___ (error_text_, 'Method Name='||nvl(complete_methods_(position_).method_name, 'NULL'));
               END LOOP;
         END;
      END IF;

      -- Clear arrays
      methods_.DELETE;
      complete_methods_.DELETE;

      --
      -- Fetch pragma method information
      --
      IF all_methods_ THEN
         OPEN get_pragma_methods;
         FETCH get_pragma_methods BULK COLLECT INTO methods_;
         CLOSE get_pragma_methods;
      ELSE
         OPEN get_new_pragma_methods;
         FETCH get_new_pragma_methods BULK COLLECT INTO methods_;
         CLOSE get_new_pragma_methods;
      END IF;
      --
      -- Process pragma method information
      --
      IF methods_.COUNT > 0 THEN
         -- Initiate sub type
         pkg_lu_sub_type_ := 'N';
         FOR i IN Nvl(methods_.FIRST,0)..Nvl(methods_.LAST,-1) LOOP
            -- Find the name of the LU for every new package
            IF (prev_pkg_ <> methods_(i).pkg) THEN
               lu_name_ := Get_Logical_Unit(methods_(i).pkg, 'PACKAGE');
               prev_pkg_ := methods_(i).pkg;
            END IF;
            IF lu_name_ IS NOT NULL THEN
               method_ := replace(initcap(replace(methods_(i).met,'_',' ')),' ','_');
               -- Update the record in dictionary_sys_method_tab
               BEGIN
                  UPDATE dictionary_sys_method_tab
                     SET method_type = 'P',
                         rowversion = SYSDATE
                     WHERE lu_name = lu_name_
                     AND   package_name = methods_(i).pkg
                     AND   method_name = method_;
                  IF SQL%NOTFOUND THEN
                     INSERT INTO dictionary_sys_method_tab
                        (lu_name, package_name, method_name, method_type, rowversion)
                     VALUES
                        (lu_name_, methods_(i).pkg, method_, 'P', SYSDATE);
                  END IF;
               EXCEPTION
                  WHEN OTHERS THEN
                     Write_Error_Text___ (error_text_, '   '||Rpad(Get_Logical_Unit_Module(lu_name_),6)||':Undefined problem when inserting dictionary information for PRAGMA-method '||method_||' in package '||methods_(i).pkg||', ', FALSE);
                     Write_Error_Text___ (error_text_, 'Lu Name='||nvl(lu_name_, 'NULL')||', ', FALSE);
                     Write_Error_Text___ (error_text_, 'Package Name='||nvl(methods_(i).pkg, 'NULL')||', ', FALSE);
                     Write_Error_Text___ (error_text_, 'Method Name='||nvl(method_, 'NULL'));
               END;
               -- Handle if current package contains a state machine (identified by a specific PRAGMA method)
               -- This call set the global variable pkg_lu_sub_type
               Handle_Possible_State_Pkg___(lu_name_, method_);
               -- Fetch and insert state information if current package contains a state machine
               IF pkg_lu_sub_type_ = 'S' THEN
                  IF (refresh_mode_ != 'LIGHT') THEN
                     Refresh_Domain_State_Info___('state', lu_name_, methods_(i).pkg);
                  END IF;
                  -- Reset the sub_type to avoid multiple unnecessary searches
                  pkg_lu_sub_type_ := 'N';
               END IF;
            END IF;
         END LOOP;
      END IF;
      --
      -- Update special handled methods to PRAGMA (Read-only) methods
      --
      UPDATE dictionary_sys_method_tab t
         SET method_type = 'P'
       WHERE upper(t.method_name)
          IN ('ENUMERATE',
              'EXIST',
              'EXIST_DB',
              'LOCK__',
              'LANGUAGE_REFRESHED',
              'INIT',
              'FINITE_STATE_DECODE__',
              'FINITE_STATE_ENCODE__',
              'ENUMERATE_STATES__',
              'FINITE_STATE_EVENTS__',
              'ENUMERATE_EVENTS__');
   END Refresh_Methods___;

BEGIN
   General_SYS.Init_Method(service_, '&PKG', 'Rebuild_Dictionary_Storage_');
   Write_Error_Text___ (error_text_, '-------------------------------------------------------------');
   Write_Error_Text___ (error_text_, 'Dictionary Cache started');
   Write_Error_Text___ (error_text_, '-------------------------------------------------------------');
   --
   -- Validate refresh mode before proceeding
   --
   IF refresh_mode_ IS NULL OR refresh_mode_ NOT IN ('FULL', 'PARTIAL', 'VIEWS', 'PACKAGES', 'LIGHT') THEN
      Error_SYS.Appl_General(service_, 'INVALIDMODE: Invalid Refresh Mode! Mode should be one of the values [:P1]', 'FULL, PARTIAL, VIEWS, PACKAGES');
   END IF;
   --
   -- If a refresh is not necessary and a full refresh is not ordered, abort immediately...
   -- This is more effecient than doing a complete search for packages and views.
   --
   -- In this procedure Dbms_Output should be used instead of Trace_SYS to enable
   -- traces during installation time.
   --
   IF NOT refresh_all_ THEN
      Check_Dictionary_Storage_(rebuild_needed_);
      IF rebuild_needed_ = 0 THEN
         Write_Error_Text___ (error_text_, 'Dictionary Cache is already up-to-date.');
         RETURN(error_text_);
      END IF;

      -- Find last update time
      OPEN get_last_update;
      FETCH get_last_update INTO last_update_;
      CLOSE get_last_update;

      -- Set full refresh mode if no dictionary data exist
      IF last_update_ IS NULL THEN
         refresh_all_ := TRUE;
      END IF;
   END IF;

   IF refresh_all_ THEN
      Write_Error_Text___ (error_text_, 'Full Refresh of Dictionary Cache!');

      -- Fetch the objects to update
      OPEN get_all_pkgs;
      FETCH get_all_pkgs BULK COLLECT INTO packages_;
      CLOSE get_all_pkgs;

      OPEN get_all_views;
      FETCH get_all_views BULK COLLECT INTO views_;
      CLOSE get_all_views;
   ELSE
      -- Spool information about what "mode" is used
      IF refresh_views_ AND refresh_pkgs_ THEN
         Write_Error_Text___ (error_text_, 'Partial Refresh of Dictionary Cache!');
      ELSIF refresh_pkgs_ THEN
         Write_Error_Text___ (error_text_, 'Partial Refresh of Dictionary Cache only for packages!');
      ELSIF refresh_views_ THEN
         Write_Error_Text___ (error_text_, 'Partial Refresh of Dictionary Cache only for views!');
      END IF;
      Write_Error_Text___ (error_text_, 'Last Update of Dictionary Cache occured at '||to_char(last_update_, 'YYYY-MM-DD HH24:MI:SS'));

      -- Fetch the objects to update
      IF refresh_pkgs_ THEN
         OPEN get_pkgs_to_update(last_update_);
         FETCH get_pkgs_to_update BULK COLLECT INTO packages_;
         CLOSE get_pkgs_to_update;
      END IF;

      IF refresh_views_ THEN
         OPEN get_views_to_update(last_update_);
         FETCH get_views_to_update BULK COLLECT INTO views_;
         CLOSE get_views_to_update;
      END IF;
   END IF;
   --
   -- Refresh package and method information
   --
   Write_Error_Text___ (error_text_, '   -------------------------------------------------------------');
   Write_Error_Text___ (error_text_, '   Dictionary Cache is being updated for '||to_char(packages_.count)||' Packages');
   Write_Error_Text___ (error_text_, '   -------------------------------------------------------------');
   IF packages_.COUNT > 0 THEN
      -- Save start date for package refresh
      start_time_ := SYSDATE;
      -- Remove old information if full refresh
      IF refresh_all_ THEN
         -- ifs_assert_safe pemase 20060215
         EXECUTE IMMEDIATE 'TRUNCATE TABLE dictionary_sys_tab';
         -- ifs_assert_safe pemase 20060215
         EXECUTE IMMEDIATE 'TRUNCATE TABLE dictionary_sys_package_tab';
         -- ifs_assert_safe pemase 20060215
         EXECUTE IMMEDIATE 'TRUNCATE TABLE dictionary_sys_domain_tab';
         -- ifs_assert_safe pemase 20060215
         EXECUTE IMMEDIATE 'TRUNCATE TABLE dictionary_sys_state_tab';
         -- ifs_assert_safe pemase 20060215
         EXECUTE IMMEDIATE 'TRUNCATE TABLE dictionary_sys_state_event_tab';
      END IF;

      FOR i IN Nvl(packages_.FIRST,0)..Nvl(packages_.LAST,-1) LOOP
         pkg_module_      := NULL;
         pkg_lu_name_     := NULL;
         pkg_lu_type_     := NULL;
         pkg_lu_sub_type_ := 'N';
         FOR pkg_info IN get_package_info(packages_(i)) LOOP
            -- Investigate module, lu name and sub type of the lu
            IF (pkg_info.gtype = 'M') THEN
               pkg_module_ := substr(pkg_info.global, 1, 6);
            ELSIF pkg_info.gtype IN ('L', 'S') THEN
               pkg_lu_name_ := pkg_info.global;
               pkg_lu_type_ := pkg_info.gtype;
            ELSIF pkg_info.gtype = 'D' THEN
               pkg_lu_sub_type_ := pkg_info.gtype;
            END IF;
         END LOOP;
         IF pkg_lu_name_ IS NOT NULL AND pkg_module_ IS NOT NULL THEN
            -- Insert the information into the dictionary
            Insert_Package_Information___(pkg_lu_name_,
                                          pkg_module_,
                                          packages_(i),
                                          pkg_lu_type_,
                                          pkg_lu_sub_type_);

            -- Refresh domain or state information depending on sub type of the LU (stored in global variable)
            IF pkg_lu_sub_type_ = 'D' THEN
               -- Refresh domain information if this is identified as an IID package
               IF (refresh_mode_ != 'LIGHT') THEN
                  Refresh_Domain_State_Info___('domain', pkg_lu_name_, packages_(i));
               END IF;
            END IF;
         ELSE
            Write_Error_Text___ (error_text_, '   ??????:Missing Module- or LU-information for package '||packages_(i)||'! Make sure that correct package globals exist for '||packages_(i));
         END IF;
      END LOOP;
      --
      -- Refresh methods once all packages are updated
      --
      Refresh_Methods___(refresh_all_, start_time_);
      --
      -- Refresh arguments for methods once all methods are updated
      --
      Refresh_Method_Arguments___(refresh_all_, start_time_);

/* Commented for now, since the code has several bugs. Maybe corrected in future Service Pack
      IF (refresh_mode_ != 'LIGHT') THEN
         IF refresh_all_ THEN
            Rebuild_All_State_Event___(TRUE);
            Rebuild_State_Transitions___(TRUE);
            Rebuild_State_Machine___(TRUE);
         ELSE
            Rebuild_All_State_Event___(FALSE);
            Rebuild_State_Transitions___(FALSE);
            Rebuild_State_Machine___(FALSE);
         END IF;
      END IF;
*/
   END IF;
   --
   -- Refresh view information
   --
   Write_Error_Text___ (error_text_, '   -------------------------------------------------------------');
   Write_Error_Text___ (error_text_, '   Dictionary Cache is being updated for '||to_char(views_.count)||' Views');
   Write_Error_Text___ (error_text_, '   -------------------------------------------------------------');
   IF views_.COUNT > 0 THEN
      -- Save start date for view refresh
      start_time_ := SYSDATE;
      -- Remove old information if full refresh
      IF refresh_all_ THEN
         -- ifs_assert_safe pemase 20060215
         EXECUTE IMMEDIATE 'TRUNCATE TABLE dictionary_sys_view_tab';
      ELSE
         FORALL j IN Nvl(views_.FIRST,0)..Nvl(views_.LAST,-1)
            DELETE FROM dictionary_sys_view_tab
               WHERE view_name = views_(j);
      END IF;

      FOR i IN Nvl(views_.FIRST,0)..Nvl(views_.LAST,-1) LOOP
         OPEN get_view_comments(views_(i));
         FETCH get_view_comments INTO view_comment_;
         CLOSE get_view_comments;
         view_module_  := NULL;
         view_lu_name_ := NULL;
         view_module_  := upper(substr(Dictionary_SYS.Comment_Value_('MODULE', view_comment_), 1, 6));
         IF view_module_ = 'IGNORE' THEN
            view_lu_name_ := 'IGNORE';
         END IF;
         IF view_lu_name_ IS NULL THEN
            view_lu_name_ := Dictionary_SYS.Comment_Value_('LU', view_comment_);
            IF view_lu_name_ IS NULL THEN
               view_lu_name_ := Dictionary_SYS.Comment_Value_('SERVICE', view_comment_);
            END IF;
         END IF;
         view_prompt_  := Dictionary_SYS.Comment_Value_('PROMPT', view_comment_);
         IF view_module_ IS NOT NULL AND view_lu_name_ IS NOT NULL THEN
            IF view_module_ != 'IGNORE' THEN
               Insert_View_Information___(view_lu_name_,
                                          view_module_,
                                          views_(i),
                                          view_prompt_);
            END IF;
         ELSE
            Write_Error_Text___ (error_text_, '   ??????:Missing Module- or LU-information for view '||views_(i)||'! Make sure that correct view comments exist for '||views_(i));
         END IF;
      END LOOP;
      --
      -- Refresh view columns once all view are updated
      --
      Refresh_View_Columns___(refresh_all_, start_time_);

   END IF;

   IF NOT refresh_all_ THEN
      --
      -- Delete information for objects no longer in the database
      --
      DELETE FROM dictionary_sys_package_tab p
         WHERE NOT EXISTS (SELECT 1
                           FROM user_objects o
                           WHERE o.object_type = 'PACKAGE'
                           AND p.package_name = o.object_name);

      DELETE FROM dictionary_sys_method_tab m
         WHERE NOT EXISTS (SELECT 1
                           FROM dictionary_sys_package_tab p
                           WHERE m.package_name = p.package_name);

      DELETE FROM dictionary_sys_view_tab v
         WHERE NOT EXISTS (SELECT 1
                           FROM user_objects o
                           WHERE o.object_type = 'VIEW'
                           AND v.view_name = o.object_name);

      DELETE FROM dictionary_sys_view_column_tab c
         WHERE NOT EXISTS (SELECT 1
                           FROM dictionary_sys_view_tab v
                           WHERE v.lu_name = c.lu_name
                           AND v.view_name = c.view_name);

      DELETE FROM dictionary_sys_tab l
         WHERE NOT EXISTS (SELECT 1
                           FROM dictionary_sys_package_tab p
                           WHERE p.lu_name = l.lu_name
                           UNION
                           SELECT 1
                           FROM dictionary_sys_view_tab v
                           WHERE v.lu_name = l.lu_name);
   END IF;

   --
   -- Attempt 1:
   -- At this point we have the basic information about the dictionary
   -- but some base views are missing. This is the first method to fix it.
   --
   UPDATE dictionary_sys_view_tab
      SET view_type = 'B'
    WHERE lu_name NOT IN ( SELECT lu_name
                             FROM dictionary_sys_view_tab
                            WHERE view_type = 'B' )
      AND view_name IN   ( SELECT view_name
                             FROM dictionary_sys_view_tab    dv,
                                  dictionary_sys_package_tab dp
                            WHERE dv.lu_name = dp.lu_name
                              AND ( dv.view_name || '_API') = dp.package_name );

   --
   -- Attempt 2:
   -- Set the first view as base view for Logical Units that does not yet have been
   -- assigned any base view according to naming standard rules.
   --
   UPDATE dictionary_sys_view_tab
      SET view_type = 'B'
      WHERE lu_name NOT IN (SELECT lu_name
                            FROM dictionary_sys_view_tab
                            WHERE view_type = 'B')
      AND view_index = 1;
   --
   -- Set prompts for all Logical Units that didn't have a clearly defined view with a prompt.
   -- Create the prompt from the Logical Unit name.
   --
   UPDATE dictionary_sys_tab
      SET lu_prompt = replace(initcap(Dictionary_SYS.Clientnametodbname_(lu_name)),'_',' ')
   WHERE lu_prompt IS NULL;

   Cache_Management_API.Refresh_Cache('Dictionary');
   
   --
   -- Call activity ManageApplicationServerCache.ClearDataDictionaryCache
   --
   DECLARE
      record_  PLSQLAP_Record_API.type_record_;
   BEGIN
      record_ := PLSQLAP_Record_API.New_Record('');
      PLSQLAP_Server_API.Invoke_Record_('ManageApplicationServerCache', 'ClearDataDictionaryCache', record_);
      PLSQLAP_Record_API.Clear_Record(record_);
   EXCEPTION
      WHEN OTHERS THEN
         NULL; -- Don't stop if error occurs
         PLSQLAP_Record_API.Clear_Record(record_);
   END;

   Write_Error_Text___ (error_text_, '-------------------------------------------------------------');
   Write_Error_Text___ (error_text_, 'Dictionary Cache finished');
   Write_Error_Text___ (error_text_, '-------------------------------------------------------------');
   RETURN(error_text_);

END Rebuild_Dictionary_Storage___;


-----------------------------------------------------------------------------
-------------------- SERVICE SPECIFIC PRIVATE METHODS -----------------------
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Property fetching routines for run-time use (private)
-----------------------------------------------------------------------------

-- Modified implementation to use dictionary cache. Designtime version moved to Design_SYS
PROCEDURE Enumerate_Logical_Units__ (
   lu_list1_ OUT VARCHAR2,
   lu_list2_ OUT VARCHAR2,
   lu_list3_ OUT VARCHAR2,
   lu_list4_ OUT VARCHAR2 )
IS
   temp_  lu_struct_type;
   limit_ NUMBER := 31000;
   n_     NUMBER := 1;

   CURSOR units IS
      SELECT lu_name
      FROM   dictionary_sys_tab
      WHERE lu_type = 'L'
      ORDER BY lu_name;
BEGIN
   --
   -- Init used elements
   --
   temp_(1) := NULL;
   temp_(2) := NULL;
   temp_(3) := NULL;
   temp_(4) := NULL;
   --
   -- Fetch all packages and views associated with a logical unit
   -- Convert to client naming and append to list
   --
   FOR unit IN units LOOP
      temp_(n_) := temp_(n_)||unit.lu_name||field_separator_;
      IF (length(temp_(n_)) > limit_) THEN
         n_ := n_ + 1;
      END IF;
   END LOOP;
   --
   -- Return complete lists
   --
   lu_list1_ := temp_(1);
   lu_list2_ := temp_(2);
   lu_list3_ := temp_(3);
   lu_list4_ := temp_(4);
END Enumerate_Logical_Units__;

PROCEDURE Get_Logical_Unit_Properties__ (
   lu_name_        IN  VARCHAR2,
   view_list_      OUT VARCHAR2,
   package_list_   OUT VARCHAR2,
   method_list_    OUT VARCHAR2,
   all_methods_    IN  VARCHAR2 DEFAULT 'TRUE' )
IS
BEGIN
   Get_Logical_Unit_Views__(lu_name_, view_list_);
   Get_Logical_Unit_Packages__(lu_name_, package_list_);
   Get_Logical_Unit_Methods__(lu_name_, method_list_, all_methods_);
END Get_Logical_Unit_Properties__;

PROCEDURE Get_Logical_Unit_Properties2__ (
   lu_name_        IN  VARCHAR2,
   view_list_      OUT VARCHAR2,
   package_list_   OUT VARCHAR2,
   method_list_    OUT VARCHAR2,
   all_methods_    IN  VARCHAR2 DEFAULT 'TRUE' )
IS
BEGIN
   Get_Logical_Unit_Views__(lu_name_, view_list_);
   Get_Logical_Unit_Packages__(lu_name_, package_list_);
   Get_LU_Method_Types__(lu_name_, method_list_);
END Get_Logical_Unit_Properties2__;

PROCEDURE Get_Logical_Unit_Views__ (
   lu_name_        IN  VARCHAR2,
   view_list_      OUT VARCHAR2 )
IS
BEGIN
   view_list_ := Get_Logical_Unit_Views__(lu_name_);
END Get_Logical_Unit_Views__;

FUNCTION Get_Logical_Unit_Views__ (
   lu_name_        IN  VARCHAR2) RETURN VARCHAR2
IS
   view_array_     object_array;
   view_list_      VARCHAR2(4000);

   CURSOR get_lu_views IS
      SELECT view_name
      FROM dictionary_sys_view_tab
      WHERE lu_name = lu_name_
      ORDER BY view_index;
BEGIN
   OPEN  get_lu_views;
   FETCH get_lu_views BULK COLLECT INTO view_array_;
   CLOSE get_lu_views;
   IF view_array_.count > 0 THEN
      FOR i IN Nvl(view_array_.first, 0)..Nvl(view_array_.last, -1) LOOP
         view_list_ := view_list_||view_array_(i)||field_separator_;
      END LOOP;
   END IF;
   RETURN view_list_;
END Get_Logical_Unit_Views__;

PROCEDURE Get_Logical_Unit_Packages__ (
   lu_name_        IN  VARCHAR2,
   package_list_   OUT VARCHAR2 )
IS
BEGIN
   package_list_ := Get_Logical_Unit_Packages__(lu_name_);
END Get_Logical_Unit_Packages__;


FUNCTION Get_Logical_Unit_Packages__ (
   lu_name_        IN  VARCHAR2 ) RETURN VARCHAR2
IS
   package_array_  object_array;
   package_list_   VARCHAR2(4000);

   CURSOR get_lu_packages IS
      SELECT package_name
      FROM dictionary_sys_package_tab
      WHERE lu_name = lu_name_
      ORDER BY package_index;
BEGIN
   OPEN  get_lu_packages;
   FETCH get_lu_packages BULK COLLECT INTO package_array_;
   CLOSE get_lu_packages;
   IF package_array_.count > 0 THEN
      FOR i IN Nvl(package_array_.first, 0)..Nvl(package_array_.last, -1) LOOP
         package_list_ := package_list_||package_array_(i)||field_separator_;
      END LOOP;
   END IF;
   RETURN package_list_;
END Get_Logical_Unit_Packages__;

PROCEDURE Get_Logical_Unit_Methods__ (
   lu_name_        IN  VARCHAR2,
   method_list_    OUT VARCHAR2,
   all_methods_    IN  VARCHAR2 DEFAULT 'TRUE' )
IS
   method_array_  object_array;
   package_array_ object_array;

   CURSOR get_all_lu_methods IS
      SELECT package_name, method_name
      FROM dictionary_sys_method_tab
      WHERE lu_name = lu_name_
      ORDER BY package_name;

   CURSOR get_lu_methods IS
      SELECT package_name, method_name
      FROM dictionary_sys_method_tab
      WHERE lu_name = lu_name_
      AND method_type = 'N'
      ORDER BY package_name;

BEGIN
   IF all_methods_ = 'TRUE' THEN
      OPEN get_all_lu_methods;
      FETCH get_all_lu_methods BULK COLLECT INTO package_array_, method_array_;
      CLOSE get_all_lu_methods;
   ELSE
      OPEN get_lu_methods;
      FETCH get_lu_methods BULK COLLECT INTO package_array_, method_array_;
      CLOSE get_lu_methods;
   END IF;

   IF method_array_.count > 0 THEN
      FOR lu_methods IN Nvl(method_array_.first, 0)..Nvl(method_array_.last, -1) LOOP
         method_list_ := method_list_||package_array_(lu_methods)||'.'||method_array_(lu_methods)||field_separator_;
      END LOOP;
   END IF;
END Get_Logical_Unit_Methods__;

PROCEDURE Get_LU_Method_Types__ (
   lu_name_        IN  VARCHAR2,
   method_list_    OUT VARCHAR2 )
IS
   method_array_  object_array;
   package_array_ object_array;
   type_array_    object_array;

   CURSOR get_all_lu_methods IS
      SELECT package_name, method_name, method_type
      FROM dictionary_sys_method_tab
      WHERE lu_name = lu_name_
      ORDER BY package_name;

BEGIN
   OPEN get_all_lu_methods;
   FETCH get_all_lu_methods BULK COLLECT INTO package_array_, method_array_, type_array_;
   CLOSE get_all_lu_methods;

   IF method_array_.count > 0 THEN
      FOR lu_methods IN Nvl(method_array_.first, 0)..Nvl(method_array_.last, -1) LOOP
         method_list_ := method_list_||package_array_(lu_methods)||'.'||method_array_(lu_methods)||field_separator_||type_array_(lu_methods)||record_separator_;
      END LOOP;
   END IF;
END Get_LU_Method_Types__;

FUNCTION Get_State_Encode_Method__ (
   view_name_      IN  VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN(Check_Method_From_View___(view_name_, 'FINITE_STATE_ENCODE__'));
END Get_State_Encode_Method__;

FUNCTION Get_State_Enumerate_Method__ (
   view_name_      IN  VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN(Check_Method_From_View___(view_name_, 'ENUMERATE_STATES__'));
END Get_State_Enumerate_Method__;

-----------------------------------------------------------------------------
-------------------- SERVICE SPECIFIC PROTECTED METHODS ---------------------
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Naming conversions for client versus database object names
-----------------------------------------------------------------------------

FUNCTION Dbnametoclientname_ (
   db_name_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   cnt_  NUMBER;
BEGIN
   -- Find number of trailing underscores
   cnt_ := length(db_name_) - length(rtrim(db_name_,'_'));
   -- Return client name with leading underscores
   IF (cnt_ = 1) THEN
      RETURN('_'||replace(initcap(db_name_),'_',''));
   ELSIF (cnt_ = 2) THEN
      RETURN('__'||replace(initcap(db_name_),'_',''));
   END IF;
   RETURN(replace(initcap(db_name_),'_',''));
EXCEPTION
   WHEN OTHERS THEN
      RETURN(NULL);
END DbNameToClientName_;


FUNCTION Clientnametodbname_ (
   client_name_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   cnt_   NUMBER;
   index_ NUMBER;
   temp_  VARCHAR2(30);
   char_  VARCHAR2(1);
BEGIN
   -- Find number of leading underscores
   cnt_ := length(client_name_) - length(ltrim(client_name_,'_'));
   -- Add intermediate underscores where needed
   FOR index_ IN cnt_+1..length(client_name_) LOOP
      char_ := substr(client_name_,index_,1);
      IF (char_ between 'A' and 'Z')  AND (temp_ IS NOT NULL) THEN
         temp_ := temp_||'_'||char_;
      ELSE
         temp_ := temp_||char_;
      END IF;
   END LOOP;
   -- Return database name with trailing underscores
   IF (cnt_ = 1) THEN
      RETURN(ltrim(upper(temp_),'_')||'__');
   ELSIF (cnt_ = 2) THEN
      RETURN(ltrim(upper(temp_),'_')||'__');
   END IF;
   RETURN(ltrim(upper(temp_),'_'));
EXCEPTION
   WHEN OTHERS THEN
      RETURN(NULL);
END ClientNameToDbName_;

-----------------------------------------------------------------------------
-- Comment decoding routines for LU-dictionary
-----------------------------------------------------------------------------

FUNCTION Comment_Value_ (
   name_    IN VARCHAR2,
   comment_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   nlen_ NUMBER;
   from_ NUMBER;
   to_   NUMBER;
BEGIN
   -- Find keyword name position within comment
   nlen_ := length(name_);
   -- New fix to support ambigous names in report definitions in IFS/Info Services
   from_ := instr(upper('^'||comment_), '^'||name_||'=');
   -- If found, return value from comment
   IF (from_ > 0) THEN
      to_ := instr(comment_, '^', from_);
      IF ( to_ = 0 ) THEN
        to_ := length(comment_) + 1;
      END IF;
      RETURN(substr(comment_, from_+nlen_+1, to_-from_-nlen_-1));
   -- If not found, return null value
   ELSE
      RETURN(NULL);
   END IF;
END Comment_Value_;

-----------------------------------------------------------------------------
-- Prompt fetching routines, mainly used for localization
-----------------------------------------------------------------------------

FUNCTION Get_View_Prompt_ (
   view_name_        IN VARCHAR2 ) RETURN VARCHAR2
IS
   prompt_ VARCHAR2(200);
   CURSOR get_prompt IS
      SELECT view_prompt
      FROM   dictionary_sys_view_tab
      WHERE  view_name = view_name_;
BEGIN
   OPEN get_prompt;
   FETCH get_prompt INTO prompt_;
   CLOSE get_prompt;
   RETURN prompt_;
END Get_View_Prompt_;

FUNCTION Get_Lu_Prompt_ (
   lu_name_        IN VARCHAR2 ) RETURN VARCHAR2
IS
   prompt_              VARCHAR2(200);
   CURSOR get_prompt IS
      SELECT lu_prompt
      FROM   dictionary_sys_tab
      WHERE  lu_name = lu_name_;
BEGIN
   -- Check that inparameters make sense before proceeding.
   IF lu_name_ IS NULL THEN
      RETURN NULL;
   END IF;

   OPEN get_prompt;
   FETCH get_prompt INTO prompt_;
   CLOSE get_prompt;
   RETURN prompt_;
END Get_Lu_Prompt_;

FUNCTION Get_Item_Prompt_ (
   lu_name_        IN VARCHAR2,
   view_name_      IN VARCHAR2,
   item_name_      IN VARCHAR2 ) RETURN VARCHAR2
IS
   view_   VARCHAR2(30) := view_name_;
   prompt_ dictionary_sys_view_column_tab.column_prompt%TYPE;

   CURSOR get_prompt IS
      SELECT column_prompt
      FROM   dictionary_sys_view_column_tab
      WHERE lu_name = lu_name_
      AND view_name = view_
      AND column_name = item_name_;
BEGIN
   IF (view_ IS NULL) THEN
      view_ := ClientNameToDbName_(lu_name_);
   END IF;
   OPEN get_prompt;
   FETCH get_prompt INTO prompt_;
   CLOSE get_prompt;
   RETURN prompt_;
END Get_Item_Prompt_;

-----------------------------------------------------------------------------
-- Property fetching routines for run-time use (protected)
-----------------------------------------------------------------------------

PROCEDURE Get_Logical_Unit_Keys_ (
   name_list_  OUT VARCHAR2,
   value_list_ OUT VARCHAR2,
   lu_name_    IN  VARCHAR2,
   objid_      IN  VARCHAR2 DEFAULT NULL )
IS
   dummy_     NUMBER;
   stmt_      VARCHAR2(2000);
   view_      VARCHAR2(30);
   temp_list_ VARCHAR2(32000);

   -- To check that the suggested base view actually contain an objid...
   CURSOR find_objid (lu_name_ IN VARCHAR2, view_name_ IN VARCHAR2) IS
      SELECT 1
      FROM   dictionary_sys_view_column_tab
      WHERE  lu_name = lu_name_
      AND    view_name = view_name_
      AND    column_name = 'OBJID';

   CURSOR get_keys (view_name_ IN VARCHAR2) IS
      SELECT column_name
      FROM dictionary_sys_view_column_tab
      WHERE lu_name = lu_name_
      AND view_name = view_name_
      AND type_flag IN ('P','K')
      ORDER BY column_index;
BEGIN
   General_SYS.Init_Method(service_, '&PKG', 'Get_Logical_Unit_Keys_');

   name_list_  := NULL;
   value_list_ := NULL;
   -- Fetch the view name from LU-dictionary
   view_ := Get_Base_View(lu_name_);
   -- Verify that this view contains an objid
   OPEN find_objid(lu_name_, view_);
   FETCH find_objid INTO dummy_;
   IF find_objid%FOUND THEN
      CLOSE find_objid;
      -- View found, fetch the keys!
      FOR keyrec IN get_keys(view_) LOOP
         temp_list_ := temp_list_||keyrec.column_name||text_separator_;
      END LOOP;
      name_list_ := temp_list_;
      IF (objid_ IS NOT NULL) THEN
         -- Fetch instance key information by using dynamic SQL
         BEGIN
            temp_list_ := substr(temp_list_, 1, length(temp_list_) - 1);
            temp_list_ := REPLACE(temp_list_, text_separator_, '||''^''||')||'||''^''';
            stmt_ := 'SELECT '|| temp_list_ ||' FROM '||view_||' WHERE OBJID = :objid_';
            Assert_SYS.Assert_Is_View(view_);
            -- ifs_assert_safe utgulk 20060105
            EXECUTE IMMEDIATE stmt_ INTO value_list_ USING objid_;
        EXCEPTION
           WHEN OTHERS THEN
              value_list_ := NULL;
         END;
      END IF;
   ELSE
      CLOSE find_objid;
   END IF;
END Get_Logical_Unit_Keys_;

-- Could not completely rely on cached information, since table information is not extracted to the cache
PROCEDURE Get_Logical_Unit_Tables_ (
   table_list_ OUT VARCHAR2,
   lu_name_    IN  VARCHAR2 )
IS
   view_name_ VARCHAR2(30);
   app_owner_ VARCHAR2(30);
   CURSOR view_tables IS
      SELECT nvl(referenced_name,'') name
         FROM   user_dependencies
         WHERE  referenced_owner = app_owner_
         AND    referenced_type = 'TABLE'
         AND    name = view_name_
         AND    type = 'VIEW'
         UNION
         SELECT nvl(referenced_name,'') name
         FROM   user_dependencies
         WHERE  referenced_owner = app_owner_
         AND    referenced_type = 'TABLE'
         AND    name = view_name_||'_API'
         AND    type = 'PACKAGE BODY'
         UNION
         SELECT nvl(table_name,'') name
         FROM user_tables
         WHERE table_name = view_name_||'_TAB';
BEGIN
   -- Check that inparameters make sense before proceeding.
   IF lu_name_ IS NULL THEN
      RETURN;
   END IF;

   app_owner_ := Fnd_Session_API.Get_App_Owner;
   view_name_ := Get_Base_View(lu_name_);
   FOR t IN view_tables LOOP
      table_list_ := table_list_||t.name||field_separator_;
   END LOOP;
END Get_Logical_Unit_Tables_;

-- Introduced new method and implemented to use dictionary cache.
PROCEDURE Enum_Modules_ (
   module_list_ OUT VARCHAR2 )
IS
   CURSOR modules IS
      SELECT DISTINCT module
      FROM   dictionary_sys_tab
      ORDER BY module;
BEGIN
   FOR module IN modules LOOP
      module_list_ := module_list_||module.module||field_separator_;
   END LOOP;
END Enum_Modules_;

PROCEDURE Enum_Module_Names_ (
   module_list_ OUT VARCHAR2,
   name_list_   OUT VARCHAR2 )
IS
   module_array_  object_array;
   name_array_    lu_struct_type;

   CURSOR modules IS
      SELECT module, name
      FROM   module_tab
      ORDER BY name;
BEGIN
   OPEN  modules;
   FETCH modules BULK COLLECT INTO module_array_, name_array_;
   CLOSE modules;
   IF module_array_.count > 0 THEN
      FOR i IN Nvl(module_array_.first, 0)..Nvl(module_array_.last, -1) LOOP
         module_list_ := module_list_||module_array_(i)||field_separator_;
         name_list_   := name_list_||name_array_(i)||field_separator_;
      END LOOP;
   END IF;
END Enum_Module_Names_;

-- Modified implementation to use dictionary cache. Designtime version moved to Design_SYS
PROCEDURE Enum_Module_All_Logical_Units_ (
   lu_list_ OUT VARCHAR2,
   module_  IN  VARCHAR2 )
IS
   lu_array_  object_array;

   CURSOR units IS
      SELECT lu_name
      FROM   dictionary_sys_tab
      WHERE  module = module_
      AND lu_type IN ('L', 'S')
      ORDER BY lu_name;
BEGIN
   OPEN  units;
   FETCH units BULK COLLECT INTO lu_array_;
   CLOSE units;
   IF lu_array_.count > 0 THEN
      FOR i IN Nvl(lu_array_.first, 0)..Nvl(lu_array_.last, -1) LOOP
         lu_list_ := lu_list_||lu_array_(i)||field_separator_;
      END LOOP;
   END IF;
END Enum_Module_All_Logical_Units_;

-- Modified implementation to use dictionary cache. Designtime version moved to Design_SYS
PROCEDURE Enum_Module_Logical_Units_ (
   lu_list_ OUT VARCHAR2,
   module_  IN  VARCHAR2 )
IS
   lu_array_  object_array;

   CURSOR units IS
      SELECT lu_name
      FROM   dictionary_sys_tab
      WHERE  module = module_
      AND lu_type = 'L'
      ORDER BY lu_name;
BEGIN
   OPEN  units;
   FETCH units BULK COLLECT INTO lu_array_;
   CLOSE units;
   IF lu_array_.count > 0 THEN
      FOR i IN Nvl(lu_array_.first, 0)..Nvl(lu_array_.last, -1) LOOP
         lu_list_ := lu_list_||lu_array_(i)||field_separator_;
      END LOOP;
   END IF;
END Enum_Module_Logical_Units_;

-- Modified implementation using dictionary cache.
PROCEDURE Enum_Module_System_Services_ (
   sys_list_ OUT VARCHAR2,
   module_   IN  VARCHAR2 )
IS
   CURSOR units IS
      SELECT lu_name
      FROM   dictionary_sys_tab
      WHERE  module = module_
      AND lu_type = 'S'
      ORDER BY lu_name;
BEGIN
   FOR unit IN units LOOP
      sys_list_ := sys_list_||unit.lu_name||field_separator_;
   END LOOP;
END Enum_Module_System_Services_;

-----------------------------------------------------------------------------
-- Runtime performance refreshment routines
-----------------------------------------------------------------------------

-- Obsolete!
PROCEDURE Activate_Language_Refresh_
IS
BEGIN
   General_SYS.Init_Method(service_, '&PKG', 'Activate_Language_Refresh_');
   Error_SYS.Appl_General(service_, 'LANGERR: The method Activate_Language_Refresh_ (Change Server Language) is obsolete. Please log on again to change language.');
END Activate_Language_Refresh_;

PROCEDURE Rebuild_Dictionary_Storage_ (
   dummy_        IN NUMBER,
   refresh_mode_ IN VARCHAR2 DEFAULT 'PARTIAL' )
IS
   error_text_ CLOB;
BEGIN
   error_text_ := Rebuild_Dictionary_Storage___(dummy_, refresh_mode_, FALSE);
END Rebuild_Dictionary_Storage_;

PROCEDURE Rebuild_Dictionary_Storage_ (
   error_text_   IN OUT NOCOPY CLOB,
   dummy_        IN NUMBER,
   refresh_mode_ IN VARCHAR2 DEFAULT 'PARTIAL' )
IS
BEGIN
   error_text_ := Rebuild_Dictionary_Storage___(dummy_, refresh_mode_, TRUE);
END Rebuild_Dictionary_Storage_;

PROCEDURE Check_Dictionary_Storage_ (
   rebuild_needed_ OUT NUMBER )
IS
   dummy_       NUMBER;
   last_update_ DATE;

   CURSOR get_last_update IS
      SELECT max(rowversion)
      FROM dictionary_sys_tab;

   CURSOR get_objects(last_cache_update_ IN DATE) IS
      SELECT 1
      FROM user_objects
      WHERE (object_type LIKE 'PACKAGE%'
         AND timestamp > to_char(last_cache_update_, 'RRRR-MM-DD:HH24:MI:SS')
         AND substr(object_name, -4) IN ('_API', '_RPI', '_SYS'))
      OR    (object_type IN ('VIEW')
         AND last_ddl_time > last_cache_update_);
BEGIN
   OPEN get_last_update;
   FETCH get_last_update INTO last_update_;
   IF (last_update_ IS NULL) THEN
      rebuild_needed_ := 1;               -- Return TRUE
   ELSE
      OPEN get_objects(last_update_);
      FETCH get_objects INTO dummy_;
      IF (get_objects%NOTFOUND) THEN
         rebuild_needed_ := 0;            -- Return FALSE
      ELSE
         rebuild_needed_ := 1;            -- Return TRUE
      END IF;
      CLOSE get_objects;
   END IF;
   CLOSE get_last_update;
END Check_Dictionary_Storage_;

-----------------------------------------------------------------------------
-------------------- SERVICE SPECIFIC PUBLIC METHODS ------------------------
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Public runtime methods for dictionary information support
-----------------------------------------------------------------------------

FUNCTION Get_Base_View (
   lu_name_        IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ VARCHAR2(30);
   CURSOR get_view IS
      SELECT view_name
      FROM   dictionary_sys_view_tab
      WHERE lu_name = lu_name_
      AND view_type = 'B';
BEGIN
   OPEN get_view;
   FETCH get_view INTO temp_;
   CLOSE get_view;
   RETURN temp_;
END Get_Base_View;

FUNCTION Get_Component (
   object_name_ IN VARCHAR2,
   object_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   component_ VARCHAR2(6);
   CURSOR get_pkg_component IS
      SELECT d.module
      FROM   dictionary_sys_tab d, dictionary_sys_package_tab p
      WHERE  p.package_name = upper(object_name_)
      AND    p.lu_name = d.lu_name;

   CURSOR get_view_component IS
      SELECT d.module
      FROM   dictionary_sys_tab d, dictionary_sys_view_tab v
      WHERE  v.view_name = upper(object_name_)
      AND    v.lu_name = d.lu_name;
BEGIN
   IF upper(object_type_) = 'PACKAGE' THEN
      OPEN get_pkg_component;
      FETCH get_pkg_component INTO component_;
      CLOSE get_pkg_component;
   ELSIF upper(object_type_) = 'VIEW' THEN
      OPEN get_view_component;
      FETCH get_view_component INTO component_;
      CLOSE get_view_component;
   ELSE
      component_ := NULL;
   END IF;
   RETURN component_;
END Get_Component;

FUNCTION Get_Logical_Unit (
   object_name_ IN VARCHAR2,
   object_type_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   lu_name_ VARCHAR2(30);
   CURSOR get_pkg_lu IS
      SELECT lu_name
      FROM   dictionary_sys_package_tab
      WHERE  package_name = upper(object_name_);

   CURSOR get_view_lu IS
      SELECT lu_name
      FROM   dictionary_sys_view_tab
      WHERE  view_name = upper(object_name_);
BEGIN
   IF upper(object_type_) = 'PACKAGE' THEN
      OPEN get_pkg_lu;
      FETCH get_pkg_lu INTO lu_name_;
      CLOSE get_pkg_lu;
   ELSIF upper(object_type_) = 'VIEW' THEN
      OPEN get_view_lu;
      FETCH get_view_lu INTO lu_name_;
      CLOSE get_view_lu;
   ELSE
      lu_name_ := NULL;
   END IF;
   RETURN lu_name_;
END Get_Logical_Unit;

FUNCTION Get_Logical_Unit_Module (
   lu_name_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   module_ VARCHAR2(6);
   CURSOR get_module IS
      SELECT module
      FROM   dictionary_sys_lu
      WHERE  lu_name = lu_name_;
BEGIN
   OPEN  get_module;
   FETCH get_module INTO module_;
   CLOSE get_module;
   RETURN module_;
END Get_Logical_Unit_Module;

FUNCTION Package_Is_Installed (
   package_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   CURSOR get_pkg IS
      SELECT 1
      FROM   dictionary_sys_package_tab
      WHERE  package_name = upper(package_name_);
BEGIN
   -- Reroute to Database_SYS during installation
   IF installation_ THEN
      RETURN(Database_SYS.Package_Exist(package_name_));
   ELSE
      OPEN  get_pkg;
      FETCH get_pkg INTO dummy_;
      IF (get_pkg%FOUND) THEN
         CLOSE get_pkg;
         RETURN TRUE;
      ELSE
         CLOSE get_pkg;
         RETURN FALSE;
      END IF;
   END IF;
END Package_Is_Installed;

FUNCTION Method_Is_Installed (
   package_name_ IN VARCHAR2,
   method_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   CURSOR get_method IS
      SELECT 1
      FROM   dictionary_sys_method_tab
      WHERE  package_name = upper(package_name_)
      AND    method_name  = initcap(method_name_);
BEGIN
   -- Reroute to Database_SYS during installation
   IF installation_ THEN
      RETURN(Database_SYS.Method_Exist(package_name_, method_name_));
   ELSE
      OPEN  get_method;
      FETCH get_method INTO dummy_;
      IF (get_method%FOUND) THEN
         CLOSE get_method;
         RETURN TRUE;
      ELSE
         CLOSE get_method;
         RETURN FALSE;
      END IF;
   END IF;
END Method_Is_Installed;

FUNCTION View_Is_Installed (
   view_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   CURSOR get_view IS
      SELECT 1
      FROM   dictionary_sys_view_tab
      WHERE  view_name = upper(view_name_);
BEGIN
   -- Reroute to Database_SYS during installation
   IF installation_ THEN
      RETURN(Database_SYS.View_Exist(view_name_));
   ELSE
      OPEN  get_view;
      FETCH get_view INTO dummy_;
      IF (get_view%FOUND) THEN
         CLOSE get_view;
         RETURN TRUE;
      ELSE
         CLOSE get_view;
         RETURN FALSE;
      END IF;
   END IF;
END View_Is_Installed;

FUNCTION Logical_Unit_Is_Installed (
   lu_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER;
   CURSOR get_lu IS
      SELECT 1
      FROM   dictionary_sys_tab
      WHERE  lu_name = lu_name_;
BEGIN
   -- Reroute to Database_SYS during installation
   IF installation_ THEN
      RETURN(Database_SYS.Package_Exist(Clientnametodbname_(lu_name_)||'_API'));
   ELSE
      OPEN  get_lu;
      FETCH get_lu INTO dummy_;
      IF (get_lu%FOUND) THEN
         CLOSE get_lu;
         RETURN TRUE;
      ELSE
         CLOSE get_lu;
         RETURN FALSE;
      END IF;
   END IF;
END Logical_Unit_Is_Installed;

FUNCTION Component_Is_Installed (
   component_ IN VARCHAR2,
   version_   IN VARCHAR2 DEFAULT NULL ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   CURSOR get_component IS
      SELECT 1
      FROM   module
      WHERE  module = upper(component_)
      AND    upper(version) LIKE nvl(upper(version_), '%');
BEGIN
   OPEN  get_component;
   FETCH get_component INTO dummy_;
   IF (get_component%FOUND) THEN
      CLOSE get_component;
      RETURN TRUE;
   ELSE
      CLOSE get_component;
      RETURN FALSE;
   END IF;
END Component_Is_Installed;

FUNCTION Package_Is_Installed_Num (
   package_name_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF Package_Is_Installed(package_name_) THEN
      RETURN (1);
   ELSE
      RETURN (0);
   END IF;
END Package_Is_Installed_Num;

FUNCTION Method_Is_Installed_Num (
   package_name_ IN VARCHAR2,
   method_name_  IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF Method_Is_Installed(package_name_, method_name_) THEN
      RETURN (1);
   ELSE
      RETURN (0);
   END IF;
END Method_Is_Installed_Num;

FUNCTION View_Is_Installed_Num (
   view_name_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF View_Is_Installed(view_name_) THEN
      RETURN (1);
   ELSE
      RETURN (0);
   END IF;
END View_Is_Installed_Num;

FUNCTION Logical_Unit_Is_Installed_Num (
   lu_name_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF Logical_Unit_Is_Installed(lu_name_) THEN
      RETURN (1);
   ELSE
      RETURN (0);
   END IF;
END Logical_Unit_Is_Installed_Num;

FUNCTION Component_Is_Installed_Num (
   component_ IN VARCHAR2,
   version_   IN VARCHAR2 DEFAULT NULL ) RETURN NUMBER
IS
BEGIN
   IF Component_Is_Installed(component_, version_) THEN
      RETURN (1);
   ELSE
      RETURN (0);
   END IF;
END Component_Is_Installed_Num;

FUNCTION Get_No_Overloads(package_name_ VARCHAR2,
                          method_name_  VARCHAR2) RETURN NUMBER
IS
   CURSOR get_no_overloads_ IS
      SELECT MAX(overload)
      FROM dictionary_sys_argument_tab
      WHERE package_name = package_name_
        AND method_name = method_name_;

      count_      NUMBER;
BEGIN
   count_:=NULL;
   IF package_name_ IS NULL OR method_name_ IS NULL THEN
--      Error_SYS.Appl_General(service_, 'NON_EXISTING_METHOD: [:P1,:P2] method is non existing method', package_name_, method_name_);
      RETURN NULL;
   END IF;
   OPEN get_no_overloads_;
   FETCH get_no_overloads_ INTO count_;
   IF get_no_overloads_%NOTFOUND THEN
--      Error_SYS.Appl_General(service_, 'NON_EXISTING_METHOD: [:P1,:P2] method is non existing method', package_name_, method_name_);
      RETURN NULL;
   END IF;
   CLOSE get_no_overloads_;
   RETURN count_;
END Get_No_Overloads;

FUNCTION Get_No_Arguments(package_name_ VARCHAR2,
                          method_name_  VARCHAR2) RETURN  NUMBER
IS
   CURSOR get_no_args_ IS
      SELECT count(*) no_args
      FROM dictionary_sys_argument_tab
      WHERE package_name = package_name_
        AND method_name = method_name_
      GROUP BY package_name, method_name,overload;

      count_      NUMBER;
BEGIN
   count_:=NULL;
   IF package_name_ IS NULL OR method_name_ IS NULL THEN
--      Error_SYS.Appl_General(service_, 'NON_EXISTING_METHOD: [:P1,:P2] method is non existing method', package_name_, method_name_);
      RETURN NULL;
   END IF;
   OPEN get_no_args_;
   FETCH get_no_args_ INTO count_;
   IF get_no_args_%NOTFOUND THEN
--      Error_SYS.Appl_General(service_, 'NON_EXISTING_METHOD: [:P1,:P2] method is non existing method', package_name_, method_name_);
      RETURN NULL;
   END IF;
   CLOSE get_no_args_;
   RETURN count_;
END Get_No_Arguments;

FUNCTION Get_Min_No_Arguments(package_name_ VARCHAR2,
                              method_name_  VARCHAR2) RETURN NUMBER
IS
   CURSOR get_min_no_args_ IS
      SELECT MIN(no_args)
      FROM (SELECT package_name, method_name, count(*) no_args
            FROM dictionary_sys_argument_tab
            GROUP BY package_name, method_name)
      WHERE package_name = package_name_
        AND method_name = method_name_;

      count_      NUMBER;
BEGIN
   count_:=NULL;
   IF package_name_ IS NULL OR method_name_ IS NULL THEN
--      Error_SYS.Appl_General(service_, 'NON_EXISTING_METHOD: [:P1,:P2] method is non existing method', package_name_, method_name_);
      RETURN NULL;
   END IF;
   OPEN get_min_no_args_;
   FETCH get_min_no_args_ INTO count_;
   IF get_min_no_args_%NOTFOUND THEN
--      Error_SYS.Appl_General(service_, 'NON_EXISTING_METHOD: [:P1,:P2] method is non existing method', package_name_, method_name_);
      RETURN NULL;
   END IF;
   CLOSE get_min_no_args_;
   RETURN count_;
END Get_Min_No_Arguments;

FUNCTION Get_Max_No_Arguments(package_name_ VARCHAR2,
                              method_name_  VARCHAR2) RETURN NUMBER
IS
   CURSOR get_max_no_args_ IS
      SELECT MAX(no_args)
      FROM (SELECT package_name, method_name, count(*) no_args
            FROM dictionary_sys_argument_tab
            GROUP BY package_name, method_name)
      WHERE package_name = package_name_
        AND method_name = method_name_;

      count_      NUMBER;
BEGIN
   count_:=NULL;
   IF package_name_ IS NULL OR method_name_ IS NULL THEN
      --Error_SYS.Appl_General(service_, 'NON_EXISTING_METHOD: [:P1,:P2] method is non existing method', package_name_, method_name_);
      RETURN NULL;
   END IF;
   OPEN get_max_no_args_;
   FETCH get_max_no_args_ INTO count_;
   IF get_max_no_args_%NOTFOUND THEN
      --Error_SYS.Appl_General(service_, 'NON_EXISTING_METHOD: [:P1,:P2] method is non existing method', package_name_, method_name_);
      RETURN NULL;
   END IF;
   CLOSE get_max_no_args_;
   RETURN count_;
END Get_Max_No_Arguments;

FUNCTION Get_Argument_Type(package_name_ VARCHAR2,
                           method_name_  VARCHAR2,
                           arg_pos_      NUMBER) RETURN VARCHAR2
IS
   CURSOR get_arg_type_ IS
      SELECT argument_datatype
      FROM dictionary_sys_argument_tab
      WHERE package_name = package_name_
        AND method_name = method_name_
        AND argument_index = arg_pos_;

      type_      dictionary_sys_argument_tab.argument_datatype%TYPE;
BEGIN
   type_:=NULL;
   IF package_name_ IS NULL OR method_name_ IS NULL THEN
      --Error_SYS.Appl_General(service_, 'NON_EXISTING_METHOD: [:P1,:P2] method is non existing method', package_name_, method_name_);
      RETURN NULL;
   END IF;
   IF Get_No_Overloads(package_name_, method_name_) > 1 THEN
      RETURN NULL;
   END IF;
   OPEN get_arg_type_;
   FETCH get_arg_type_ INTO type_;
   IF get_arg_type_%NOTFOUND THEN
      --Error_SYS.Appl_General(service_, 'NON_EXISTING_METHOD: [:P1,:P2] method is non existing method', package_name_, method_name_);
      RETURN NULL;
   END IF;
   CLOSE get_arg_type_;
   RETURN type_;
END Get_Argument_Type;

PROCEDURE Set_Installation_Mode (
   installation_mode_ IN BOOLEAN DEFAULT FALSE )
IS
BEGIN
   General_SYS.Init_Method(service_, '&PKG', 'Set_Installation_Mode');
   installation_ := installation_mode_;
END Set_Installation_Mode;

FUNCTION Get_Installation_Mode RETURN BOOLEAN
IS
BEGIN
   General_SYS.Init_Method(service_, '&PKG', 'Get_Installation_Mode');
   RETURN(installation_);
END Get_Installation_Mode;

-----------------------------------------------------------------------------
-------------------- FOUNDATION1 METHODS ------------------------------------
-----------------------------------------------------------------------------
-- Init
--   Dummy procedure that can be called at database startup to ensure that
--   this package is loaded into memory for performance reasons only.
-----------------------------------------------------------------------------

PROCEDURE Init
IS
BEGIN
   NULL;
END Init;


END &PKG;
/
SHOW ERROR

UNDEFINE MODULE
UNDEFINE SERVICE
UNDEFINE PKG
UNDEFINE VIEW
UNDEFINE VIEW2
UNDEFINE VIEW3
UNDEFINE VIEW4
UNDEFINE VIEW5
UNDEFINE VIEW6
UNDEFINE VIEW7
UNDEFINE VIEW8
UNDEFINE VIEW9
UNDEFINE OBJID
-----------------------------------------------------------------------------


